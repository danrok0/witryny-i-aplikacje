# ============= TŁUMACZENIE KODU LINIA PO LINII =============

#analyzers\__init__.py
# Ten plik jest inicjalizacyjnym modułem pakietu analyzers

"""
Moduł analizy danych tekstowych dla systemu rekomendacji tras turystycznych.
Zawiera klasy do przetwarzania opisów tras i analizy recenzji użytkowników.
"""
# Powyższy komentarz dokumentacyjny (docstring) opisuje ogólne przeznaczenie modułu

# Importujemy klasy z poszczególnych modułów pakietu:
from .text_processor import TextProcessor  # Klasa odpowiedzialna za przetwarzanie tekstu
from .review_analyzer import ReviewAnalyzer  # Klasa odpowiedzialna za analizę recenzji

# Lista określająca publiczne API modułu - tylko te klasy będą dostępne przy imporcie z gwiazdką
__all__ = ['TextProcessor', 'ReviewAnalyzer']

# ============= KONIEC PLIKU __init__.py ============= 

#analyzers\review_analyzer.py
# Ten plik implementuje główną funkcjonalność analizy recenzji

"""
Klasa ReviewAnalyzer do analizy sentymentu i ekstrakcji informacji z recenzji użytkowników
tras turystycznych zgodnie z wymaganiami z updatelist.txt.
"""
# Powyższy docstring opisuje główne przeznaczenie klasy ReviewAnalyzer

# Importy niezbędnych bibliotek:
import re  # Moduł do obsługi wyrażeń regularnych
from typing import Dict, List, Optional, Any, Tuple  # Typy do annotacji typów
from dataclasses import dataclass  # Dekorator do tworzenia klas danych
import logging  # Moduł do logowania
from datetime import datetime  # Do obsługi dat
import statistics  # Do obliczeń statystycznych

# Konfiguracja systemu logowania
logging.basicConfig(level=logging.INFO)  # Ustawienie poziomu logowania na INFO
logger = logging.getLogger(__name__)  # Utworzenie loggera dla tego modułu

@dataclass  # Dekorator tworzący klasę danych z automatyczną implementacją metod
class ReviewData:
    """Struktura danych pojedynczej recenzji."""
    # Definicja pól klasy z ich typami i wartościami domyślnymi:
    text: str  # Pole przechowujące surowy tekst recenzji
    rating: Optional[float] = None  # Ocena liczbowa (opcjonalna)
    sentiment: Optional[str] = None  # Sentyment recenzji: 'positive', 'negative', 'neutral' (opcjonalny)
    date: Optional[str] = None  # Data napisania recenzji (opcjonalna)
    aspects: List[str] = None  # Lista aspektów trasy wspomnianych w recenzji
    season: Optional[str] = None  # Pora roku wspomniana w recenzji (opcjonalna)
    
    def __post_init__(self):
        """Metoda wywoływana automatycznie po inicjalizacji obiektu"""
        if self.aspects is None:
            self.aspects = []  # Inicjalizacja pustej listy aspektów jeśli nie podano żadnych

@dataclass  # Dekorator tworzący klasę danych z automatyczną implementacją metod
class ReviewAnalysis:
    """Struktura wyników analizy recenzji."""
    # Definicja pól klasy przechowujących zagregowane statystyki:
    total_reviews: int = 0  # Całkowita liczba przeanalizowanych recenzji
    average_rating: Optional[float] = None  # Średnia ocena ze wszystkich recenzji
    sentiment_distribution: Dict[str, int] = None  # Rozkład sentymentów (pozytywne/negatywne/neutralne)
    common_aspects: List[Tuple[str, int]] = None  # Lista najpopularniejszych aspektów z ich częstością
    seasonal_preferences: Dict[str, int] = None  # Rozkład preferencji według pór roku
    rating_distribution: Dict[str, int] = None  # Rozkład ocen (histogram ocen)
    
    def __post_init__(self):
        """Metoda inicjalizująca domyślne wartości dla pól słownikowych i list"""
        # Inicjalizacja słownika rozkładu sentymentów
        if self.sentiment_distribution is None:
            self.sentiment_distribution = {'positive': 0, 'negative': 0, 'neutral': 0}
        # Inicjalizacja listy popularnych aspektów
        if self.common_aspects is None:
            self.common_aspects = []
        # Inicjalizacja słownika preferencji sezonowych
        if self.seasonal_preferences is None:
            self.seasonal_preferences = {}
        # Inicjalizacja słownika rozkładu ocen
        if self.rating_distribution is None:
            self.rating_distribution = {}

class ReviewAnalyzer:
    """
    Klasa do analizy recenzji użytkowników tras turystycznych.
    Implementuje funkcjonalność analizy tekstu, wydobywania informacji i oceny sentymentu.
    """
    
    def __init__(self):
        """Inicjalizacja wzorców wyrażeń regularnych i słowników do analizy sentymentu."""
        # Definicja wzorców wyrażeń regularnych zgodnie z wymaganiami z updatelist.txt
        self.patterns = {
            # Wzorce do wydobywania ocen w różnych formatach:
            'ratings': [
                re.compile(r'(\d(?:\.\d)?)/5', re.IGNORECASE),  # Format X/5 (np. 4.5/5)
                re.compile(r'(\d{1,2})/10', re.IGNORECASE),  # Format X/10 (np. 8/10)
                re.compile(r'(★{1,5})', re.IGNORECASE),  # Format gwiazdek (np. ★★★★)
                re.compile(r'(\d(?:\.\d)?)\s*(?:stars?|gwiazdek?|gwiazd)', re.IGNORECASE),  # Format tekstowy (np. "4 gwiazdki")
                re.compile(r'ocena[:\s]*(\d(?:\.\d)?)', re.IGNORECASE)  # Format "ocena: X"
            ],
            
            # Wzorce do wydobywania dat w różnych formatach:
            'dates': [
                re.compile(r'(\d{1,2})[-./](\d{1,2})[-./](\d{2,4})'),  # Standardowy format daty (np. 01-02-2024)
                re.compile(r'(\d{4})[-./](\d{1,2})[-./](\d{1,2})'),  # Format ISO (np. 2024-02-01)
                re.compile(r'byłem\s*(\d{1,2})\.(\d{1,2})\.(\d{2,4})', re.IGNORECASE),  # Format tekstowy (np. "byłem 01.02.2024")
                re.compile(r'(styczeń|luty|marzec|kwiecień|maj|czerwiec|lipiec|sierpień|wrzesień|październik|listopad|grudzień)\s*(\d{2,4})', re.IGNORECASE)  # Format z nazwą miesiąca
            ],
            
            # Wzorce do wydobywania aspektów tras turystycznych:
            'aspects': [
                re.compile(r'(widoki?|panorama|krajobraz)', re.IGNORECASE),  # Aspekty wizualne
                re.compile(r'(trudność|trudne|łatwe|poziom)', re.IGNORECASE),  # Poziom trudności
                re.compile(r'(oznakowanie|znaki|tablice)', re.IGNORECASE),  # Oznakowanie szlaku
                re.compile(r'(parking|dojazd|dostęp)', re.IGNORECASE),  # Dostępność i infrastruktura
                re.compile(r'(czas|długość|dystans)', re.IGNORECASE),  # Parametry trasy
                re.compile(r'(pogoda|warunki|klimat)', re.IGNORECASE),  # Warunki pogodowe
                re.compile(r'(tłumy?|ludzie|turyści)', re.IGNORECASE),  # Zatłoczenie
                re.compile(r'(bezpieczeństwo|niebezpieczne|bezpieczne)', re.IGNORECASE)  # Aspekty bezpieczeństwa
            ],
            
            # Wzorce do identyfikacji pór roku:
            'seasons': [
                re.compile(r'(wiosną|na\s+wiosnę|w\s+marcu|w\s+kwietniu|w\s+maju)', re.IGNORECASE),  # Wiosna i miesiące wiosenne
                re.compile(r'(latem|w\s+lecie|w\s+czerwcu|w\s+lipcu|w\s+sierpniu)', re.IGNORECASE),  # Lato i miesiące letnie
                re.compile(r'(jesienią|na\s+jesień|we\s+wrześniu|w\s+październiku|w\s+listopadzie)', re.IGNORECASE),  # Jesień i miesiące jesienne
                re.compile(r'(zimą|w\s+zimie|w\s+grudniu|w\s+styczniu|w\s+lutym)', re.IGNORECASE)  # Zima i miesiące zimowe
            ]
        }
        
        # Słowniki słów kluczowych do analizy sentymentu
        # Zbiór słów wskazujących na pozytywną opinię
        self.positive_words = {
            # Ogólne określenia pozytywne
            'wspaniały', 'piękny', 'fantastyczny', 'świetny', 'doskonały', 'polecam',
            'rewelacyjny', 'cudowny', 'zachwycający', 'niesamowity', 'super',
            # Określenia związane z atrakcyjnością trasy
            'widoki', 'przepiękny', 'warto',
            # Określenia związane z bezpieczeństwem i komfortem
            'bezpieczny', 'komfortowy', 'przyjemny',
            # Określenia związane z poziomem trudności
            'łatwy', 'dobry',
            # Określenia związane z atmosferą
            'fajny', 'miły', 'relaksujący', 'spokojny'
        }
        
        # Zbiór słów wskazujących na negatywną opinię
        self.negative_words = {
            # Określenia związane z trudnością
            'trudny', 'bardzo trudne', 'wyczerpujący',
            # Określenia związane z bezpieczeństwem
            'niebezpieczny', 'zagrożenie',
            # Określenia związane z dyskomfortem
            'męczący', 'strasznie', 'okropny', 'zły',
            # Wyraźne niezalecenia
            'nie polecam', 'unikać',
            # Określenia problemów
            'problem', 'problemy', 'źle', 'kiepski', 'trudności',
            # Określenia związane z warunkami
            'błoto', 'śliskie', 'stromość', 'długie',
            # Określenia związane z dostępnością
            'zbyt', 'niedostępny', 'zamknięte'
        }
    
    def extract_rating(self, text: str) -> Optional[float]:
        """
        Ekstraktuje oceny numeryczne z różnych formatów tekstu recenzji.
        
        Metoda przeszukuje tekst w poszukiwaniu różnych formatów ocen:
        - Oceny w skali 1-5 (np. "4/5")
        - Oceny w skali 1-10 (automatycznie konwertowane do skali 1-5)
        - Oceny w formie gwiazdek (np. "★★★★")
        - Oceny tekstowe (np. "4 gwiazdki" lub "ocena: 4")
        
        Args:
            text: Tekst recenzji do przeanalizowania
            
        Returns:
            float: Znormalizowana ocena w skali 1-5
            None: Jeśli nie znaleziono oceny lub wystąpił błąd konwersji
        """
        # Iteracja po wszystkich wzorcach ocen
        for pattern in self.patterns['ratings']:
            matches = pattern.findall(text)  # Szukanie wszystkich dopasowań
            if matches:  # Jeśli znaleziono jakieś dopasowania
                try:
                    match = matches[0]  # Bierzemy pierwsze dopasowanie
                    
                    # Przypadek gdy dopasowanie jest pojedynczym stringiem
                    if isinstance(match, str):
                        if '★' in match:
                            # Dla formatu gwiazdek - zliczamy ich liczbę
                            return float(len(match))
                        else:
                            # Dla zwykłego stringa - konwertujemy na float
                            return float(match)
                            
                    # Przypadek gdy dopasowanie jest krotką (może zawierać grupy)
                    elif isinstance(match, tuple):
                        # Szukamy pierwszej niepustej wartości w krotce
                        for value in match:
                            if value:  # Jeśli wartość nie jest pusta
                                if '★' in value:
                                    # Dla formatu gwiazdek - zliczamy ich liczbę
                                    return float(len(value))
                                else:
                                    # Konwersja na float i normalizacja skali
                                    rating = float(value)
                                    # Jeśli ocena jest w skali 1-10, konwertujemy ją do skali 1-5
                                    if rating > 5:
                                        rating = rating / 2
                                    return rating
                                    
                except (ValueError, TypeError):
                    # Ignorujemy błędy konwersji i próbujemy następny wzorzec
                    continue
                    
        # Jeśli nie znaleziono żadnej oceny lub wszystkie konwersje się nie powiodły
        return None
    
    def extract_date(self, text: str) -> Optional[str]:
        """
        Wydobywa daty z opinii użytkowników i normalizuje je do standardowego formatu.
        
        Metoda obsługuje różne formaty dat:
        - Standardowy format numeryczny (DD-MM-YYYY, DD.MM.YYYY, DD/MM/YYYY)
        - Format ISO (YYYY-MM-DD)
        - Format tekstowy (np. "byłem 01.02.2024")
        - Format z nazwą miesiąca (np. "maj 2024")
        
        Args:
            text: Tekst recenzji do przeanalizowania
            
        Returns:
            str: Data w ustandaryzowanym formacie YYYY-MM-DD
            None: Jeśli nie znaleziono daty lub wystąpił błąd konwersji
        """
        # Iteracja po wszystkich wzorcach dat
        for pattern in self.patterns['dates']:
            matches = pattern.findall(text)  # Szukanie wszystkich dopasowań
            if matches:  # Jeśli znaleziono jakieś dopasowania
                try:
                    match = matches[0]  # Bierzemy pierwsze dopasowanie
                    
                    # Obsługa standardowego formatu daty (DD-MM-YYYY)
                    if isinstance(match, tuple) and len(match) >= 3:
                        day, month, year = match[:3]  # Wyodrębnienie składowych daty
                        
                        # Konwersja dwucyfrowego roku na czterocyfrowy
                        if len(year) == 2:
                            # Lata < 50 traktujemy jako 20XX, >= 50 jako 19XX
                            year = '20' + year if int(year) < 50 else '19' + year
                            
                        # Zwracamy datę w formacie ISO z uzupełnionymi zerami
                        return f"{year}-{month.zfill(2)}-{day.zfill(2)}"
                        
                    # Obsługa formatu z nazwą miesiąca (np. "maj 2024")
                    elif isinstance(match, tuple) and len(match) == 2:
                        month_name, year = match
                        
                        # Mapowanie polskich nazw miesięcy na numery
                        month_map = {
                            'styczeń': '01', 'luty': '02', 'marzec': '03', 'kwiecień': '04',
                            'maj': '05', 'czerwiec': '06', 'lipiec': '07', 'sierpień': '08',
                            'wrzesień': '09', 'październik': '10', 'listopad': '11', 'grudzień': '12'
                        }
                        
                        # Konwersja nazwy miesiąca na numer (domyślnie '01' jeśli nie znaleziono)
                        month_num = month_map.get(month_name.lower(), '01')
                        
                        # Zwracamy pierwszy dzień miesiąca jako datę
                        return f"{year}-{month_num}-01"
                        
                except (ValueError, TypeError):
                    # Ignorujemy błędy konwersji i próbujemy następny wzorzec
                    continue
                    
        # Jeśli nie znaleziono żadnej daty lub wszystkie konwersje się nie powiodły
        return None
    
    def extract_aspects(self, text: str) -> List[str]:
        """
        Wydobywa aspekty trasy turystycznej wspomniane w tekście recenzji.
        
        Metoda przeszukuje tekst w poszukiwaniu różnych aspektów trasy, takich jak:
        - Walory wizualne (widoki, panorama, krajobraz)
        - Poziom trudności trasy
        - Oznakowanie i nawigacja
        - Dostępność i infrastruktura
        - Parametry trasy (długość, czas)
        - Warunki pogodowe
        - Zatłoczenie
        - Aspekty bezpieczeństwa
        
        Args:
            text: Tekst recenzji do przeanalizowania
            
        Returns:
            List[str]: Lista unikalnych aspektów znalezionych w tekście
        """
        # Inicjalizacja pustej listy na znalezione aspekty
        aspects = []
        
        # Definicja kategorii aspektów i ich słów kluczowych
        aspect_categories = {
            'widoki': ['widoki', 'panorama', 'krajobraz'],  # Aspekty wizualne
            'trudność': ['trudność', 'trudne', 'łatwe', 'poziom'],  # Poziom trudności
            'oznakowanie': ['oznakowanie', 'znaki', 'tablice'],  # Oznaczenia na trasie
            'dojazd': ['parking', 'dojazd', 'dostęp'],  # Dostępność
            'czas': ['czas', 'długość', 'dystans'],  # Parametry trasy
            'pogoda': ['pogoda', 'warunki', 'klimat'],  # Warunki atmosferyczne
            'tłumy': ['tłumy', 'ludzie', 'turyści'],  # Zatłoczenie
            'bezpieczeństwo': ['bezpieczeństwo', 'niebezpieczne', 'bezpieczne']  # Aspekty bezpieczeństwa
        }
        
        # Konwersja tekstu na małe litery dla ujednolicenia porównań
        text_lower = text.lower()
        
        # Przeszukiwanie tekstu dla każdej kategorii aspektów
        for category, keywords in aspect_categories.items():
            # Sprawdzenie czy którekolwiek ze słów kluczowych występuje w tekście
            if any(keyword in text_lower for keyword in keywords):
                # Dodanie kategorii do listy znalezionych aspektów
                aspects.append(category)
        
        # Zwrócenie listy unikalnych aspektów (bez duplikatów)
        return aspects
    
    def extract_season(self, text: str) -> Optional[str]:
        """
        Wydobywa informacje o porze roku wspomnianej w recenzji.
        
        Metoda analizuje tekst w poszukiwaniu wzmianek o porach roku, uwzględniając:
        - Bezpośrednie nazwy pór roku (np. "wiosna", "lato")
        - Określenia sezonowe (np. "na wiosnę", "w lecie")
        - Nazwy miesięcy przypisane do pór roku
        
        Args:
            text: Tekst recenzji do przeanalizowania
            
        Returns:
            str: Nazwa zidentyfikowanej pory roku ('wiosna', 'lato', 'jesień', 'zima')
            None: Jeśli nie znaleziono wzmianki o porze roku
        """
        # Mapowanie wzorców wyrażeń regularnych na pory roku
        season_patterns = {
            'wiosna': self.patterns['seasons'][0],  # Wzorzec dla wiosny i miesięcy wiosennych
            'lato': self.patterns['seasons'][1],    # Wzorzec dla lata i miesięcy letnich
            'jesień': self.patterns['seasons'][2],  # Wzorzec dla jesieni i miesięcy jesiennych
            'zima': self.patterns['seasons'][3]     # Wzorzec dla zimy i miesięcy zimowych
        }
        
        # Przeszukiwanie tekstu dla każdej pory roku
        for season, pattern in season_patterns.items():
            # Sprawdzenie czy wzorzec występuje w tekście
            if pattern.search(text):
                # Zwrócenie znalezionej pory roku
                return season
                
        # Jeśli nie znaleziono żadnej wzmianki o porze roku
        return None
    
    def analyze_sentiment(self, text: str) -> str:
        """
        Analizuje sentyment (wydźwięk emocjonalny) tekstu recenzji.
        
        Metoda wykorzystuje słowniki słów pozytywnych i negatywnych oraz uwzględnia:
        - Zliczanie wystąpień słów pozytywnych i negatywnych
        - Kontekst negacji (np. "nie polecam" jako wyrażenie negatywne)
        - Porównanie liczby wyrażeń pozytywnych i negatywnych
        
        Args:
            text: Tekst recenzji do przeanalizowania
            
        Returns:
            str: Określenie sentymentu:
                'positive' - przewaga wyrażeń pozytywnych
                'negative' - przewaga wyrażeń negatywnych
                'neutral' - brak wyraźnej przewagi lub brak wyrażeń nacechowanych
        """
        # Konwersja tekstu na małe litery dla ujednolicenia porównań
        text_lower = text.lower()
        
        # Zliczanie wystąpień słów pozytywnych
        positive_count = sum(1 for word in self.positive_words if word in text_lower)
        
        # Zliczanie wystąpień słów negatywnych
        negative_count = sum(1 for word in self.negative_words if word in text_lower)
        
        # Analiza kontekstu negacji (np. "nie polecam")
        # Tworzymy wzorce dla zaprzeczeń słów pozytywnych
        negation_patterns = [r'nie\s+' + word for word in self.positive_words]
        
        # Sprawdzanie wystąpień zaprzeczeń
        for pattern in negation_patterns:
            if re.search(pattern, text_lower):
                # Każde znalezione zaprzeczenie:
                negative_count += 1  # Dodaje punkt negatywny
                positive_count = max(0, positive_count - 1)  # Usuwa punkt pozytywny (jeśli był)
        
        # Określenie ostatecznego sentymentu na podstawie przewagi
        if positive_count > negative_count:
            return 'positive'  # Przewaga pozytywna
        elif negative_count > positive_count:
            return 'negative'  # Przewaga negatywna
        else:
            return 'neutral'  # Brak wyraźnej przewagi
    
    def process_review(self, review_text: str) -> ReviewData:
        """
        Kompleksowo przetwarza pojedynczą recenzję, wydobywając wszystkie istotne informacje.
        
        Metoda wykonuje pełną analizę tekstu recenzji, w tym:
        - Ekstrakcję oceny liczbowej
        - Analizę sentymentu (wydźwięk emocjonalny)
        - Identyfikację daty napisania recenzji
        - Wyodrębnienie wspomnianych aspektów trasy
        - Identyfikację pory roku
        
        Args:
            review_text: Tekst recenzji do przeanalizowania
            
        Returns:
            ReviewData: Obiekt zawierający wszystkie wyekstraktowane informacje
                       Jeśli tekst jest pusty lub nieprawidłowy, zwraca obiekt
                       z pustym tekstem i domyślnymi wartościami pozostałych pól
        """
        # Sprawdzenie poprawności danych wejściowych
        if not review_text or not isinstance(review_text, str):
            # Zwrócenie pustego obiektu w przypadku nieprawidłowych danych
            return ReviewData(text='')
        
        # Utworzenie i zwrócenie obiektu ReviewData ze wszystkimi wyekstraktowanymi informacjami
        return ReviewData(
            text=review_text,                           # Oryginalny tekst recenzji
            rating=self.extract_rating(review_text),    # Ocena liczbowa (jeśli występuje)
            sentiment=self.analyze_sentiment(review_text),  # Wydźwięk emocjonalny
            date=self.extract_date(review_text),        # Data napisania recenzji
            aspects=self.extract_aspects(review_text),  # Lista wspomnianych aspektów
            season=self.extract_season(review_text)     # Wspomniana pora roku
        )
    
    def analyze_reviews(self, reviews: List[str]) -> ReviewAnalysis:
        """
        Analizuje listę recenzji i generuje zbiorczy raport.
        
        Args:
            reviews: Lista tekstów recenzji
            
        Returns:
            ReviewAnalysis ze zbiorczymi wynikami
        """
        if not reviews:
            return ReviewAnalysis()
        
        processed_reviews = [self.process_review(review) for review in reviews]
        analysis = ReviewAnalysis()
        
        analysis.total_reviews = len(processed_reviews)
        
        # Analiza ocen
        ratings = [r.rating for r in processed_reviews if r.rating is not None]
        if ratings:
            analysis.average_rating = statistics.mean(ratings)
            # Rozkład ocen
            analysis.rating_distribution = {}
            for rating in ratings:
                rating_str = str(int(rating)) if rating == int(rating) else str(rating)
                analysis.rating_distribution[rating_str] = analysis.rating_distribution.get(rating_str, 0) + 1
        
        # Analiza sentymentu
        for review in processed_reviews:
            if review.sentiment:
                analysis.sentiment_distribution[review.sentiment] += 1
        
        # Analiza aspektów
        aspect_counts = {}
        for review in processed_reviews:
            for aspect in review.aspects:
                aspect_counts[aspect] = aspect_counts.get(aspect, 0) + 1
        
        analysis.common_aspects = sorted(aspect_counts.items(), key=lambda x: x[1], reverse=True)
        
        # Analiza sezonowości
        for review in processed_reviews:
            if review.season:
                analysis.seasonal_preferences[review.season] = analysis.seasonal_preferences.get(review.season, 0) + 1
        
        # Logowanie wyników
        avg_rating_str = f"{analysis.average_rating:.2f}" if analysis.average_rating is not None else "brak"
        logger.info(f"Przeanalizowano {analysis.total_reviews} recenzji. Średnia ocena: {avg_rating_str}")
        
        return analysis
    
    def enhance_trail_with_reviews(self, trail_data: Dict[str, Any], reviews: List[str]) -> Dict[str, Any]:
        """
        Rozszerza dane trasy o analizę recenzji użytkowników.
        
        Args:
            trail_data: Słownik z danymi trasy
            reviews: Lista recenzji użytkowników
            
        Returns:
            Rozszerzony słownik z analizą recenzji
        """
        enhanced_trail = trail_data.copy()
        
        if not reviews:
            enhanced_trail['reviews'] = []
            enhanced_trail['review_analysis'] = ReviewAnalysis().__dict__
            return enhanced_trail
        
        # Dodaj surowe recenzje
        enhanced_trail['reviews'] = reviews
        
        # Przeprowadź analizę
        analysis = self.analyze_reviews(reviews)
        
        # Dodaj wyniki analizy
        enhanced_trail['review_analysis'] = {
            'total_reviews': analysis.total_reviews,
            'average_rating': analysis.average_rating,
            'sentiment_distribution': analysis.sentiment_distribution,
            'common_aspects': analysis.common_aspects[:5],  # Top 5 aspektów
            'seasonal_preferences': analysis.seasonal_preferences,
            'rating_distribution': analysis.rating_distribution,
            'analysis_timestamp': datetime.now().isoformat()
        }
        
        # Dodaj podsumowanie do głównych danych trasy
        if analysis.average_rating:
            enhanced_trail['user_rating'] = round(analysis.average_rating, 1)
        
        # Dodaj najczęstsze aspekty jako tagi
        if analysis.common_aspects:
            existing_tags = enhanced_trail.get('tags', [])
            new_tags = [aspect for aspect, _ in analysis.common_aspects[:3]]
            enhanced_trail['tags'] = list(set(existing_tags + new_tags))
        
        return enhanced_trail 

        #analyzers\text_processor.py

#api\__init__.py

"""
API package for trail and weather data retrieval.
"""

from .trails_api import TrailsAPI
from .weather_api import WeatherAPI

__all__ = ['TrailsAPI', 'WeatherAPI'] 

#api\trails_api.py

import requests
import re
import os
import json
from typing import List, Dict, Any
from functools import reduce
from config import OVERPASS_API, OVERPASS_QUERY_TEMPLATE

class TrailsAPI:
    def __init__(self):
        self.base_url = OVERPASS_API
        self.data_dir = "api"
        if not os.path.exists(self.data_dir):
            os.makedirs(self.data_dir)

    def _parse_distance(self, distance_str: str) -> float:
        """Konwertuje ciąg znaków z odległością na kilometry."""
        if not distance_str:
            return 0.0
        
        try:
            # Usuwa wszystkie znaki niebędące cyframi lub kropkami i konwertuje na float
            value = float(''.join(c for c in str(distance_str) if c.isdigit() or c == '.'))
            
            # Jeśli ciąg zawiera 'm' lub 'km', używa tego jako jednostki
            if isinstance(distance_str, str):
                distance_str = distance_str.lower().strip()
                if 'km' in distance_str:
                    return value
                elif 'm' in distance_str:
                    return value / 1000
                else:
                    # Jeśli nie podano jednostki, zakłada metry jeśli wartość > 100, w przeciwnym razie kilometry
                    return value / 1000 if value > 100 else value
            else:
                # Jeśli nie podano jednostki, zakłada metry jeśli wartość > 100, w przeciwnym razie kilometry
                return value / 1000 if value > 100 else value
                
        except (ValueError, AttributeError):
            return 0.0

    def _parse_elevation(self, elevation_str: str) -> float:
        """Konwertuje ciąg znaków z wysokością na metry."""
        if not elevation_str:
            return 0.0
        
        try:
            # Usuwa wszystkie znaki niebędące cyframi lub kropkami i konwertuje na float
            value = float(''.join(c for c in str(elevation_str) if c.isdigit() or c == '.'))
            
            # Jeśli ciąg zawiera 'm' lub 'km', używa tego jako jednostki
            if isinstance(elevation_str, str):
                elevation_str = elevation_str.lower().strip()
                if 'km' in elevation_str:
                    return value * 1000
                elif 'm' in elevation_str:
                    return value
                else:
                    return value  # Domyślnie zakłada metry
            else:
                return value  # Domyślnie zakłada metry
                
        except (ValueError, AttributeError):
            return 0.0

    def _calculate_difficulty_components(self, tags: Dict[str, str], length_km: float, elevation_m: float) -> List[int]:
        """Oblicza komponenty trudności trasy używając programowania funkcyjnego."""
        components = []
        
        # Komponent długości
        components.append(3 if length_km > 20 else (2 if length_km > 10 else 1))
        
        # Komponent wysokości
        components.append(3 if elevation_m > 1000 else (2 if elevation_m > 500 else 1))
        
        # Komponent skali SAC
        sac_scale = tags.get("sac_scale", "").lower()
        components.append(3 if "alpine" in sac_scale else (2 if "mountain" in sac_scale else 1))
        
        # Komponent powierzchni
        surface = tags.get("surface", "").lower()
        components.append(3 if any(s in surface for s in ["rock", "scree"]) else 
                         (2 if any(s in surface for s in ["gravel", "dirt"]) else 1))
        
        # Komponent nachylenia
        try:
            incline_str = tags.get("incline", "0")
            if incline_str and isinstance(incline_str, str):
                # Usuń znaki % i inne niebędące cyframi
                incline_clean = ''.join(c for c in incline_str if c.isdigit() or c == '.' or c == '-')
                incline = float(incline_clean) if incline_clean else 0
            else:
                incline = 0
        except (ValueError, TypeError):
            incline = 0
        components.append(3 if incline > 15 else (2 if incline > 10 else 1))
        
        return components

    def _calculate_difficulty(self, tags: Dict[str, str], length_km: float, elevation_m: float) -> int:
        """Oblicza trudność trasy używając funkcji reduce (skala 1-3)."""
        components = self._calculate_difficulty_components(tags, length_km, elevation_m)
        # Używa reduce aby znaleźć maksymalny komponent trudności
        max_difficulty = reduce(lambda x, y: max(x, y), components)
        # Upewnij się, że trudność jest w zakresie 1-3
        return max(1, min(3, max_difficulty))

    def get_hiking_trails(self, city: str) -> List[Dict[str, Any]]:
        """Pobiera szlaki turystyczne dla miasta używając API Overpass."""
        print(f"\nPróba pobrania tras dla miasta: {city}")

        # Expanded Overpass query to find more trails
        query = f"""
        [out:json][timeout:25];
        area["name"="{city}"]["boundary"="administrative"]->.searchArea;
        (
          // Main hiking and walking routes
          relation["route"~"hiking|foot|walking|running"](area.searchArea);
          way["route"~"hiking|foot|walking|running"](area.searchArea);
          
          // Parks and nature reserves
          relation["leisure"~"park|nature_reserve|garden"](area.searchArea);
          way["leisure"~"park|nature_reserve|garden"](area.searchArea);
          
          // Natural areas
          relation["natural"~"wood|forest|park|heath|grassland|scrub"](area.searchArea);
          way["natural"~"wood|forest|park|heath|grassland|scrub"](area.searchArea);
          
          // Tourist attractions
          relation["tourism"~"attraction|viewpoint|picnic_site"](area.searchArea);
          way["tourism"~"attraction|viewpoint|picnic_site"](area.searchArea);
          
          // Waterways and coastlines
          relation["waterway"~"river|stream|canal"](area.searchArea);
          way["waterway"~"river|stream|canal"](area.searchArea);
          relation["natural"~"coastline|beach"](area.searchArea);
          way["natural"~"coastline|beach"](area.searchArea);
          
          // Historical and cultural sites
          relation["historic"~"monument|memorial|castle|ruins"](area.searchArea);
          way["historic"~"monument|memorial|castle|ruins"](area.searchArea);
        );
        out body;
        >;
        out skel qt;
        """

        try:
            print(f"Wysyłanie zapytania do API Overpass dla {city}")
            response = requests.post(self.base_url, data={"data": query})
            response.raise_for_status()
            data = response.json()
            print(f"Otrzymano odpowiedź z API dla {city}")

            # Use map to process all elements
            trails = list(map(lambda element: self._process_trail_element(element, city), 
                            filter(lambda e: e.get("type") in ["relation", "way"], 
                                  data.get("elements", []))))

            # Filter out None values and empty trails
            trails = list(filter(None, trails))
            
            print(f"Znaleziono łącznie {len(trails)} tras dla {city}")
            
            # Save trails to file
            file_path = os.path.join(self.data_dir, "trails_data.json")
            try:
                with open(file_path, 'w', encoding='utf-8') as f:
                    json.dump(trails, f, ensure_ascii=False, indent=2)
                print(f"Zapisano dane o szlakach do pliku {file_path}")
            except Exception as e:
                print(f"Błąd podczas zapisywania danych o szlakach: {e}")
            
            return trails

        except requests.RequestException as e:
            print(f"Błąd podczas pobierania danych dla {city}: {e}")
            return []

    def _process_trail_element(self, element: Dict[str, Any], city: str) -> Dict[str, Any]:
        """Przetwarza pojedynczy element szlaku."""
        tags = element.get("tags", {})
        
        # Skip if no name
        if not tags.get("name"):
            return None
            
        # Calculate length from various possible sources
        length_sources = [
            tags.get("distance"),
            tags.get("length"),
            tags.get("way_length"),
            tags.get("route_length")
        ]
        
        length_km = 0.0
        for source in length_sources:
            if source:
                length_km = self._parse_distance(source)
                if length_km > 0:
                    break
        
        # If no length found in tags, estimate based on element type and generate reasonable values
        if length_km == 0:
            # Generate realistic trail lengths based on element type and tags
            import random
            
            # Determine trail type for length estimation
            route_type = tags.get("route", "")
            leisure_type = tags.get("leisure", "")
            natural_type = tags.get("natural", "")
            tourism_type = tags.get("tourism", "")
            
            if "hiking" in route_type or "foot" in route_type:
                # Hiking trails: 2-25 km
                length_km = random.uniform(2.0, 25.0)
            elif "park" in leisure_type or "garden" in leisure_type:
                # Park trails: 0.5-8 km
                length_km = random.uniform(0.5, 8.0)
            elif "forest" in natural_type or "wood" in natural_type:
                # Forest trails: 1-15 km
                length_km = random.uniform(1.0, 15.0)
            elif "viewpoint" in tourism_type or "attraction" in tourism_type:
                # Tourist attractions: 0.3-5 km
                length_km = random.uniform(0.3, 5.0)
            elif "waterway" in tags or "river" in natural_type:
                # Riverside trails: 1-12 km
                length_km = random.uniform(1.0, 12.0)
            else:
                # Default trails: 1-10 km
                length_km = random.uniform(1.0, 10.0)
            
            # Round to 1 decimal place
            length_km = round(length_km, 1)

        # Get elevation data
        elevation_sources = [
            tags.get("ele"),
            tags.get("elevation"),
            tags.get("height")
        ]
        
        elevation_m = 0.0
        for source in elevation_sources:
            if source:
                elevation_m = self._parse_elevation(source)
                if elevation_m > 0:
                    break

        # Get coordinates if available
        coordinates = None
        try:
            if "center" in element and isinstance(element["center"], dict):
                coordinates = {
                    "lat": element["center"].get("lat"),
                    "lon": element["center"].get("lon")
                }
            elif "nodes" in element and element["nodes"] and isinstance(element["nodes"], list):
                # Use first node as approximate location
                first_node = element["nodes"][0]
                if isinstance(first_node, dict):
                    coordinates = {
                        "lat": first_node.get("lat"),
                        "lon": first_node.get("lon")
                    }
        except (KeyError, IndexError, TypeError) as e:
            print(f"Błąd podczas pobierania współrzędnych: {e}")
            coordinates = None
        
        trail = {
            "id": str(element.get("id")),
            "name": tags.get("name", "Unknown Trail"),
            "region": city,
            "coordinates": coordinates,
            "length_km": length_km,
            "elevation_m": elevation_m,
            "difficulty": self._calculate_difficulty(tags, length_km, elevation_m),
            "terrain_type": self._determine_terrain_type(tags),
            "tags": [k for k, v in tags.items() if v == "yes"]
        }
        
        print(f"Znaleziono trasę: {trail['name']} ({trail['length_km']:.2f} km, trudność: {trail['difficulty']})")
        return trail

    def _determine_terrain_type(self, tags: Dict[str, str]) -> str:
        """Określa typ terenu używając list składanych."""
        terrain_mapping = {
            "waterway": "riverside",
            "natural=coast": "coastal",
            "leisure=park": "park",
            "historic": "historical",
            "place=city": "urban",
            "place=town": "urban"
        }
        
        # Use dictionary comprehension to find matching terrain type
        terrain_type = next((v for k, v in terrain_mapping.items() 
                           if k in tags or any(k in str(v).lower() for v in tags.values())), 
                          "mixed")
        return terrain_type

#api\update_data.py

import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from api.trails_api import TrailsAPI
from api.weather_api import WeatherAPI
from config import CITY_COORDINATES
import json
from datetime import datetime, timedelta

def update_trails_data():
    api = TrailsAPI()
    all_trails = []

    print("Pobieranie danych o szlakach dla wszystkich regionów...")
    
    for region in CITY_COORDINATES.keys():
        print(f"\nPobieranie szlaków dla regionu: {region}")
        try:
            trails = api.get_hiking_trails(region)
            if trails:
                all_trails.extend(trails)
                print(f"Znaleziono {len(trails)} szlaków dla {region}")
        except Exception as e:
            print(f"Błąd podczas pobierania szlaków dla {region}: {e}")

    print(f"\nŁącznie znaleziono {len(all_trails)} szlaków")

    # Initialize empty file if it doesn't exist
    if not os.path.exists('trails_data.json'):
        with open('trails_data.json', 'w', encoding='utf-8') as f:
            json.dump([], f)

    # Save to trails_data.json
    try:
        with open('trails_data.json', 'w', encoding='utf-8') as f:
            json.dump(all_trails, f, ensure_ascii=False, indent=2)
        print("Dane o szlakach zostały zapisane do pliku trails_data.json")
    except Exception as e:
        print(f"Błąd podczas zapisywania danych o szlakach: {e}")

def update_weather_data():
    api = WeatherAPI()
    all_weather = []

    print("\nPobieranie danych pogodowych dla wszystkich regionów...")
    
    # Get weather for next 7 days for each region
    for region in CITY_COORDINATES.keys():
        print(f"\nPobieranie prognozy pogody dla regionu: {region}")
        try:
            for i in range(7):  # Get forecast for next 7 days
                date = (datetime.now() + timedelta(days=i)).strftime("%Y-%m-%d")
                weather = api.get_weather_forecast(region, date)
                if weather:
                    all_weather.append(weather)
                    print(f"Pobrano prognozę dla {region} na {date}")
        except Exception as e:
            print(f"Błąd podczas pobierania prognozy pogody dla {region}: {e}")

    print(f"\nŁącznie pobrano {len(all_weather)} prognoz pogody")

    # Initialize empty file if it doesn't exist
    if not os.path.exists('weather_dataa.json'):
        with open('weather_dataa.json', 'w', encoding='utf-8') as f:
            json.dump([], f)

    # Save to weather_dataa.json
    try:
        with open('weather_dataa.json', 'w', encoding='utf-8') as f:
            json.dump(all_weather, f, ensure_ascii=False, indent=2)
        print("Dane pogodowe zostały zapisane do pliku weather_dataa.json")
    except Exception as e:
        print(f"Błąd podczas zapisywania danych pogodowych: {e}")

if __name__ == "__main__":
    update_trails_data()
    update_weather_data()

#api\update_trails_data.py

import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from api.trails_api import TrailsAPI
from config import CITY_COORDINATES
import json

def update_trails_data():
    api = TrailsAPI()
    all_trails = []

    print("Pobieranie danych o szlakach dla wszystkich regionów...")
    
    for region in CITY_COORDINATES.keys():
        print(f"\nPobieranie szlaków dla regionu: {region}")
        try:
            trails = api.get_hiking_trails(region)
            all_trails.extend(trails)
            print(f"Znaleziono {len(trails)} szlaków dla {region}")
        except Exception as e:
            print(f"Błąd podczas pobierania szlaków dla {region}: {e}")

    print(f"\nŁącznie znaleziono {len(all_trails)} szlaków")

    # Save to trails_data.json
    try:
        with open('trails_data.json', 'w', encoding='utf-8') as f:
            json.dump(all_trails, f, ensure_ascii=False, indent=2)
        print("Dane zostały zapisane do pliku trails_data.json")
    except Exception as e:
        print(f"Błąd podczas zapisywania danych: {e}")

if __name__ == "__main__":
    update_trails_data() 

#api\weather_api.py

import requests
import os
import json
from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional
from functools import reduce
from config import OPEN_METEO_API, CITY_COORDINATES

class WeatherAPI:
    def __init__(self):
        self.base_url = "https://api.open-meteo.com/v1"
        self.forecast_url = f"{self.base_url}/forecast"
        self.history_url = f"{self.base_url}/archive"
        self.visual_crossing_url = "https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline"
        self.visual_crossing_api_key = "YOUR_API_KEY"  # Należy zastąpić prawdziwym kluczem API
        self.openweather_url = "https://api.openweathermap.org/data/3.0/onecall/timemachine"
        self.openweather_api_key = "YOUR_API_KEY"  # Należy zastąpić prawdziwym kluczem API
        self.worldweather_url = "http://api.worldweatheronline.com/premium/v1/past-weather.ashx"
        self.worldweather_api_key = "YOUR_API_KEY"  # Należy zastąpić prawdziwym kluczem API
        self.weather_data_file = "api/weather_data.json"

    def _calculate_average_temperature(self, daily_data: Dict[str, List[float]]) -> float:
        """Calculate average temperature using reduce."""
        temps = [daily_data.get("temperature_2m_max", [0])[0], 
                daily_data.get("temperature_2m_min", [0])[0]]
        return reduce(lambda x, y: x + y, temps) / len(temps)

    def _process_weather_data(self, data: Dict[str, Any], city: str, date: str) -> Dict[str, Any]:
        """Process weather data using dictionary comprehension."""
        daily_data = data.get("daily", {})
        
        # Use dictionary comprehension to create weather data
        weather_data = {
            "date": date,
            "region": city,
            "temperature_min": daily_data.get("temperature_2m_min", [0])[0],
            "temperature_max": daily_data.get("temperature_2m_max", [0])[0],
            "temperature_avg": self._calculate_average_temperature(daily_data),
            "precipitation": daily_data.get("precipitation_sum", [0])[0],
            "cloud_cover": daily_data.get("cloudcover_mean", [0])[0],
            "wind_speed": daily_data.get("windspeed_10m_max", [0])[0],
            "sunshine_hours": daily_data.get("sunshine_duration", [0])[0] / 3600
        }
        
        return weather_data

    def get_weather_forecast(self, city: str, date: str) -> Optional[Dict[str, Any]]:
        """Get weather forecast for a specific date."""
        try:
            # Convert date string to datetime
            target_date = datetime.strptime(date, "%Y-%m-%d")
            today = datetime.now().date()
            
            # Choose appropriate API endpoint based on date
            if target_date.date() < today:
                print(f"Pobieranie historycznych danych pogodowych dla {city} na dzień {date}...")
                return self._get_historical_weather(city, date)
            else:
                print(f"Pobieranie prognozy pogody dla {city} na dzień {date}...")
                return self._get_future_weather(city, date)
                
        except Exception as e:
            print(f"Błąd podczas pobierania danych pogodowych: {e}")
            return None

    def _get_future_weather(self, city: str, date: str) -> Optional[Dict[str, Any]]:
        """Get weather forecast for future dates."""
        try:
            # Get coordinates for the city
            coordinates = self._get_city_coordinates(city)
            if not coordinates:
                return None

            # Prepare parameters for the API request
            params = {
                "latitude": coordinates["latitude"],
                "longitude": coordinates["longitude"],
                "start_date": date,
                "end_date": date,
                "daily": [
                    "temperature_2m_max",
                    "temperature_2m_min",
                    "precipitation_sum",
                    "sunshine_duration",
                    "cloudcover_mean",
                    "windspeed_10m_max",
                    "winddirection_10m_dominant"
                ],
                "timezone": "Europe/Warsaw"
            }

            # Make the API request
            response = requests.get(self.forecast_url, params=params)
            response.raise_for_status()
            data = response.json()

            # Extract and format the weather data
            daily = data["daily"]
            return {
                "temperature_max": daily["temperature_2m_max"][0],
                "temperature_min": daily["temperature_2m_min"][0],
                "temperature_avg": (daily["temperature_2m_max"][0] + daily["temperature_2m_min"][0]) / 2,
                "precipitation": daily["precipitation_sum"][0],
                "sunshine_hours": daily["sunshine_duration"][0] / 3600,  # Convert seconds to hours
                "cloud_cover": daily["cloudcover_mean"][0],
                "wind_speed": daily["windspeed_10m_max"][0]
            }

        except Exception as e:
            print(f"Błąd podczas pobierania prognozy pogody: {e}")
            return None

    def _get_historical_weather(self, city: str, date: str) -> Optional[Dict[str, Any]]:
        """Get historical weather data from local JSON file."""
        try:
            # Load weather data from file
            with open(self.weather_data_file, 'r', encoding='utf-8') as f:
                weather_data = json.load(f)

            # Check if we have data for this city and date
            if city in weather_data and date in weather_data[city]:
                return weather_data[city][date]
            else:
                # If no exact match, return average values for the city
                if city in weather_data:
                    city_data = weather_data[city]
                    dates = list(city_data.keys())
                    if dates:
                        # Return data from the first available date
                        return city_data[dates[0]]
                
                print(f"Brak danych historycznych dla {city} na dzień {date}")
                return None

        except Exception as e:
            print(f"Błąd podczas pobierania historycznych danych pogodowych: {e}")
            return None

    def _get_city_coordinates(self, city: str) -> Optional[Dict[str, float]]:
        """Get coordinates for a given city."""
        city_coordinates = {
            "Gdańsk": {"latitude": 54.3520, "longitude": 18.6466},
            "Warszawa": {"latitude": 52.2297, "longitude": 21.0122},
            "Kraków": {"latitude": 50.0647, "longitude": 19.9450},
            "Wrocław": {"latitude": 51.1079, "longitude": 17.0385}
        }
        return city_coordinates.get(city)

    def get_weather_for_date_range(self, city: str, start_date: str, end_date: str) -> List[Dict[str, Any]]:
        """Get weather for a date range using map."""
        try:
            start = datetime.strptime(start_date, "%Y-%m-%d")
            end = datetime.strptime(end_date, "%Y-%m-%d")
            
            # Generate list of dates
            date_list = [start + timedelta(days=x) for x in range((end - start).days + 1)]
            
            # Use map to get weather for each date
            weather_data = list(map(
                lambda date: self.get_weather_forecast(city, date.strftime("%Y-%m-%d")),
                date_list
            ))
            
            # Filter out None values
            return list(filter(None, weather_data))
            
        except ValueError as e:
            print(f"Nieprawidłowy format daty: {e}")
            return [] 

#data_handlers\__init__.py

"""
Data handlers for trail and weather information.
"""

from .trail_data import TrailDataHandler
from .weather_data import WeatherDataHandler

__all__ = ['TrailDataHandler', 'WeatherDataHandler'] 

#data_handlers\trail_data.py

import json
from functools import reduce
from typing import List, Dict, Any
import os
import sys
from datetime import datetime
import inspect

# Dodaj katalog projektu do ścieżki Pythona
project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(project_root)

# Dodaj ścieżkę do nowych modułów
currentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.insert(0, currentdir)

from api.trails_api import TrailsAPI
from api.weather_api import WeatherAPI
from config import CITY_COORDINATES

try:
    from analyzers.text_processor import TextProcessor
    from analyzers.review_analyzer import ReviewAnalyzer
    from extractors.web_data_collector import WebDataCollector
except ImportError as e:
    print(f"Ostrzeżenie: Nie można zaimportować nowych modułów: {e}")
    # Definicje zastępcze
    class TextProcessor:
        def enhance_trail_data(self, trail_data):
            return trail_data
    
    class ReviewAnalyzer:
        def enhance_trail_with_reviews(self, trail_data, reviews):
            return trail_data
    
    class WebDataCollector:
        def collect_sample_data(self):
            return []

class TrailDataHandler:
    def __init__(self):
        self.api = TrailsAPI()
        self.weather_api = WeatherAPI()
        self.data_file = "api/trails_data.json"
        
        # Inicjalizuj nowe moduły analizy
        self.text_processor = TextProcessor()
        self.review_analyzer = ReviewAnalyzer()
        self.web_collector = WebDataCollector()
        
        print("Pobieranie danych o szlakach z API...")
        self._update_trails_data()
        self.trails_data = self._load_trails_data()

    def _load_trails_data(self) -> List[Dict[str, Any]]:
        """Load trails data from JSON file."""
        try:
            with open(self.data_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            print(f"Błąd podczas wczytywania danych o trasach: {e}")
            return []

    def _update_trails_data(self):
        """Update trails data by fetching from API and saving to file."""
        print("Aktualizacja danych o szlakach...")
        all_trails = []
        
        # Get trails for all regions
        for region in CITY_COORDINATES.keys():
            print(f"\nPobieranie szlaków dla regionu: {region}")
            try:
                trails = self.api.get_hiking_trails(region)
                if trails:
                    all_trails.extend(trails)
                    print(f"Znaleziono {len(trails)} szlaków dla {region}")
            except Exception as e:
                print(f"Błąd podczas pobierania szlaków dla {region}: {e}")

        print(f"\nŁącznie znaleziono {len(all_trails)} szlaków")

        # Save to trails_data.json
        try:
            with open(self.data_file, 'w', encoding='utf-8') as f:
                json.dump(all_trails, f, ensure_ascii=False, indent=2)
            print("Dane o szlakach zostały zapisane do pliku trails_data.json")
        except Exception as e:
            print(f"Błąd podczas zapisywania danych o szlakach: {e}")

    def _validate_trail(self, trail: Any) -> Dict[str, Any]:
        """Waliduje i formatuje dane szlaku."""
        if not isinstance(trail, dict):
            return None
            
        # Required fields with default values
        default_trail = {
            "id": "unknown",
            "name": "Unknown Trail",
            "region": "unknown",
            "length_km": 0.0,
            "difficulty": 1,
            "terrain_type": "mixed",
            "tags": []
        }
        
        # Update default values with actual data if valid
        if isinstance(trail, dict):
            for key in default_trail:
                if key in trail and trail[key] is not None:
                    default_trail[key] = trail[key]
                    
            # Ensure numeric fields are correct type
            try:
                default_trail["length_km"] = float(default_trail["length_km"])
                default_trail["difficulty"] = int(default_trail["difficulty"])
            except (ValueError, TypeError):
                default_trail["length_km"] = 0.0
                default_trail["difficulty"] = 1
                
        return default_trail

    def get_trails(self) -> List[Dict[str, Any]]:
        """Get all available trails."""
        all_trails = []
        for city in CITY_COORDINATES.keys():
            city_trails = self.get_trails_for_city(city)
            all_trails.extend(trail for trail in city_trails if trail is not None)
        return self._remove_duplicates(all_trails)
    
    def _remove_duplicates(self, trails: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Usuwa duplikaty tras na podstawie nazwy, długości i regionu."""
        seen = set()
        unique_trails = []
        
        for trail in trails:
            # Utwórz klucz unikalności na podstawie nazwy, długości i regionu
            key = (
                trail.get('name', '').lower().strip(),
                trail.get('length_km', 0),
                trail.get('region', '').lower().strip()
            )
            
            if key not in seen:
                seen.add(key)
                unique_trails.append(trail)
        
        if len(trails) != len(unique_trails):
            print(f"Usunięto {len(trails) - len(unique_trails)} duplikatów tras")
        
        return unique_trails

    def get_trails_for_city(self, city: str) -> List[Dict[str, Any]]:
        """Get trails for a specific city from the data file."""
        try:
            with open(self.data_file, 'r', encoding='utf-8') as f:
                all_trails = json.load(f)
                city_trails = [trail for trail in all_trails if trail.get("region", "").lower() == city.lower()]
                unique_trails = self._remove_duplicates(city_trails)
                print(f"Znaleziono {len(unique_trails)} unikalnych szlaków dla miasta {city}")
                return unique_trails
        except (FileNotFoundError, json.JSONDecodeError) as e:
            print(f"Błąd podczas wczytywania danych o szlakach: {e}")
            return []

    def get_trail_by_id(self, trail_id: str) -> Dict[str, Any]:
        """Get a specific trail by its ID from the data file."""
        try:
            with open(self.data_file, 'r', encoding='utf-8') as f:
                all_trails = json.load(f)
                for trail in all_trails:
                    if trail.get("id") == trail_id:
                        return trail
                return None
        except (FileNotFoundError, json.JSONDecodeError) as e:
            print(f"Błąd podczas wczytywania danych o szlakach: {e}")
            return None

    def get_trails_by_difficulty(self, difficulty: int) -> List[Dict[str, Any]]:
        """Get trails with specific difficulty level from the data file."""
        try:
            with open(self.data_file, 'r', encoding='utf-8') as f:
                all_trails = json.load(f)
                difficulty_trails = [trail for trail in all_trails if trail.get("difficulty") == difficulty]
                print(f"Znaleziono {len(difficulty_trails)} szlaków o trudności {difficulty}")
                return difficulty_trails
        except (FileNotFoundError, json.JSONDecodeError) as e:
            print(f"Błąd podczas wczytywania danych o szlakach: {e}")
            return []

    def get_trails_by_terrain(self, terrain_type: str) -> List[Dict[str, Any]]:
        """Get trails with specific terrain type from the data file."""
        try:
            with open(self.data_file, 'r', encoding='utf-8') as f:
                all_trails = json.load(f)
                terrain_trails = [trail for trail in all_trails if trail.get("terrain_type", "").lower() == terrain_type.lower()]
                print(f"Znaleziono {len(terrain_trails)} szlaków o typie terenu {terrain_type}")
                return terrain_trails
        except (FileNotFoundError, json.JSONDecodeError) as e:
            print(f"Błąd podczas wczytywania danych o szlakach: {e}")
            return []

    def filter_by_region(self, region: str) -> List[Dict[str, Any]]:
        """Filter trails by region."""
        return [trail for trail in self.get_trails() 
                if isinstance(trail, dict) and 
                trail.get('region', '').lower() == region.lower()]

    def filter_by_length(self, min_length: float, max_length: float) -> List[Dict[str, Any]]:
        """Filter trails by length range."""
        return [trail for trail in self.get_trails()
                if isinstance(trail, dict) and
                min_length <= trail.get('length_km', 0) <= max_length]

    def filter_by_difficulty(self, difficulty: int) -> List[Dict[str, Any]]:
        """Filter trails by difficulty level."""
        return [trail for trail in self.get_trails()
                if isinstance(trail, dict) and
                trail.get('difficulty') == difficulty]

    def get_average_length(self) -> float:
        """Calculate average length of all trails."""
        trails = [trail for trail in self.get_trails() if isinstance(trail, dict)]
        if not trails:
            return 0
        return sum(trail.get('length_km', 0) for trail in trails) / len(trails)

    def save_trails(self, filename: str):
        """Save all trails to a JSON file."""
        trails = [trail for trail in self.get_trails() if isinstance(trail, dict)]
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(trails, f, ensure_ascii=False, indent=2)

    def get_trails_by_weather_conditions(self, city: str, date: str, 
                                       max_precipitation: float = None,
                                       min_temperature: float = None,
                                       max_temperature: float = None) -> List[Dict[str, Any]]:
        """Get trails filtered by weather conditions."""
        try:
            # Get weather forecast for the specified date
            weather = self.weather_api.get_weather_forecast(city, date)
            if not weather:
                print(f"Brak danych pogodowych dla {city} na dzień {date}")
                return []
            
            # Calculate hiking comfort index
            from utils.weather_utils import WeatherUtils
            comfort_index = WeatherUtils.calculate_hiking_comfort(weather)

            # Get all trails for the city
            trails = self.get_trails_for_city(city)
            if not trails:
                return []

            # Filter trails based on weather conditions
            filtered_trails = []
            for trail in trails:
                # Check precipitation
                if max_precipitation is not None and weather["precipitation"] > max_precipitation:
                    continue
                
                # Check temperature
                if min_temperature is not None and weather["temperature_avg"] < min_temperature:
                    continue
                if max_temperature is not None and weather["temperature_avg"] > max_temperature:
                    continue
                
                # Add comfort index to trail data
                trail_with_comfort = trail.copy()
                trail_with_comfort['comfort_index'] = WeatherUtils.calculate_hiking_comfort(weather)
                filtered_trails.append(trail_with_comfort)

            print(f"Znaleziono {len(filtered_trails)} szlaków spełniających kryteria pogodowe")
            return filtered_trails

        except Exception as e:
            print(f"Błąd podczas filtrowania tras według warunków pogodowych: {e}")
            return []

    def get_trails_by_all_criteria(self, city: str, date: str,
                                 difficulty: int = None,
                                 terrain_type: str = None,
                                 max_precipitation: float = None,
                                 min_temperature: float = None,
                                 max_temperature: float = None,
                                 min_length: float = None,
                                 max_length: float = None,
                                 min_sunshine: float = None) -> List[Dict[str, Any]]:
        """Get trails filtered by all criteria."""
        try:
            # Filter trails by city
            city_trails = [trail for trail in self.trails_data if trail.get('region', '').lower() == city.lower()]
            print(f"Znaleziono {len(city_trails)} szlaków dla miasta {city}")

            if not city_trails:
                print(f"Nie znaleziono szlaków dla miasta {city}")
                return []

            # Get weather data
            print(f"Pobieranie danych pogodowych dla {city} na dzień {date}...")
            weather = self.weather_api.get_weather_forecast(city, date)
            if not weather:
                print(f"Brak danych pogodowych dla {city} na dzień {date}")
                return []

            # Filter trails by all criteria
            filtered_trails = []
            for trail in city_trails:
                # Check difficulty
                if difficulty is not None and trail.get('difficulty') != difficulty:
                    continue

                # Check terrain type
                if terrain_type and trail.get('terrain_type', '').lower() != terrain_type.lower():
                    continue

                # Check length
                if min_length is not None and trail.get('length_km', 0) < min_length:
                    continue
                if max_length is not None and trail.get('length_km', 0) > max_length:
                    continue

                # Check weather conditions
                if max_precipitation is not None and weather.get('precipitation', 0) > max_precipitation:
                    continue
                if min_temperature is not None and weather.get('temperature_min', 0) < min_temperature:
                    continue
                if max_temperature is not None and weather.get('temperature_max', 0) > max_temperature:
                    continue
                if min_sunshine is not None and weather.get('sunshine_hours', 0) < min_sunshine:
                    continue

                filtered_trails.append(trail)

            if not filtered_trails:
                print("Nie znaleziono tras spełniających podane kryteria")
                return []

            return filtered_trails

        except Exception as e:
            print(f"Błąd podczas filtrowania tras: {e}")
            return []

    def enhance_trail_with_analysis(self, trail_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Rozszerza dane trasy o analizę tekstu i recenzji.
        
        Args:
            trail_data: Podstawowe dane trasy
            
        Returns:
            Rozszerzone dane trasy z analizą
        """
        enhanced_trail = trail_data.copy()
        
        # Przetwarzanie opisu trasy za pomocą TextProcessor
        if trail_data.get('description'):
            enhanced_trail = self.text_processor.enhance_trail_data(enhanced_trail)
        
        # Dodaj przykładowe recenzje jeśli ich brak
        if not enhanced_trail.get('reviews'):
            # Generuj przykładowe recenzje na podstawie nazwy i kategorii trasy
            enhanced_trail['reviews'] = self._generate_sample_reviews(enhanced_trail)
        
        # Analiza recenzji
        reviews = enhanced_trail.get('reviews', [])
        if reviews:
            enhanced_trail = self.review_analyzer.enhance_trail_with_reviews(enhanced_trail, reviews)
        
        return enhanced_trail
    
    def _generate_sample_reviews(self, trail_data: Dict[str, Any]) -> List[str]:
        """
        Generuje przykładowe recenzje dla tras, które ich nie mają.
        
        Args:
            trail_data: Dane trasy
            
        Returns:
            Lista przykładowych recenzji
        """
        trail_name = trail_data.get('name', 'trasa')
        difficulty = trail_data.get('difficulty', 2)
        length = trail_data.get('length_km', 10)
        category = trail_data.get('category', 'sportowa')
        terrain = trail_data.get('terrain_type', 'mixed')
        
        sample_reviews = []
        
        # Pozytywne recenzje (60% szans)
        positive_reviews = [
            f"Fantastyczna trasa! {trail_name} zachwyca na każdym kroku. Polecam wszystkim miłośnikom przyrody. 5/5",
            f"Wspaniałe widoki i dobrze oznakowana trasa. Spędziłem tu cudowny dzień. Zdecydowanie wrócę! 5/5",
            f"Jedna z najpiękniejszych tras jakie przeszedłem. {trail_name} to prawdziwa perła. 4/5",
            f"Świetna organizacja, czyste szlaki, piękne krajobrazy. Bardzo polecam! 5/5",
            f"Trasa idealna na weekend z rodziną. Dzieci były zachwycone! 4/5",
            f"Doskonałe miejsce na aktywny wypoczynek. Powietrze czyste, widoki przepiękne. 5/5"
        ]
        
        # Neutralne recenzje (25% szans)
        neutral_reviews = [
            f"Trasa w porządku, nic szczególnego ale da się przejść. Oznakowanie mogłoby być lepsze. 3/5",
            f"Przeciętna trasa, widoki średnie. Dla początkujących może być ok. 3/5",
            f"Nie najgorsza trasa, ale są lepsze w okolicy. Parking płatny. 3/5",
            f"Standardowa trasa turystyczna. Nic co by mnie zaskoczyło pozytywnie. 3/5",
            f"Trasa jak trasa. Przeszedłem, ale nie zostanie mi w pamięci. 3/5"
        ]
        
        # Negatywne recenzje (15% szans)
        negative_reviews = [
            f"Rozczarowanie. Trasa przeceniona, widoki słabe. Nie polecam. 2/5",
            f"Źle oznakowana trasa, zgubiłem się kilka razy. Frustrujące doświadczenie. 2/5",
            f"Za dużo ludzi, hałas, śmieci na szlaku. Nie wrócę tu więcej. 2/5",
            f"Trasa w złym stanie, błoto wszędzie. Lepiej wybrać inną trasę. 1/5",
            f"Przepłacone i przereklamowane. Oczekiwałem więcej. 2/5"
        ]
        
        # Recenzje specyficzne dla trudności
        if difficulty == 1:
            sample_reviews.extend([
                "Łatwa trasa, idealna dla początkujących. Przeszedłem z dziećmi bez problemu. 4/5",
                "Spokojna trasa, można iść w zwykłych butach. Polecam seniorom. 4/5"
            ])
        elif difficulty == 2:
            sample_reviews.extend([
                "Średnia trudność, trzeba mieć podstawową kondycję. Warto się wybrać. 4/5",
                "Trasa wymagająca ale do przejścia. Kilka stromych odcinków. 3/5"
            ])
        else:
            sample_reviews.extend([
                "Bardzo trudna trasa! Tylko dla doświadczonych. Ale widoki niesamowite! 4/5",
                "Ekstremalna trasa, wymaga doskonałej kondycji. Nie dla każdego. 3/5"
            ])
        
        # Recenzje specyficzne dla długości
        if length < 5:
            sample_reviews.append("Krótka ale przyjemna trasa. Idealna na popołudniowy spacer. 4/5")
        elif length > 15:
            sample_reviews.append("Długa trasa na cały dzień. Zabierz dużo wody i jedzenia! 4/5")
        
        # Recenzje specyficzne dla terenu
        if terrain == 'górski':
            sample_reviews.extend([
                "Górska trasa z pięknymi widokami na szczyty. Uwaga na pogodę! 4/5",
                "Strome podejścia ale warto! Panorama z góry zapiera dech. 5/5"
            ])
        elif terrain == 'leśny':
            sample_reviews.extend([
                "Spokojna trasa przez las. Dużo cienia, przyjemnie w upały. 4/5",
                "Piękny las, świeże powietrze. Widziałem sarny! 4/5"
            ])
        elif terrain == 'miejski':
            sample_reviews.extend([
                "Miejska trasa, dobre połączenia komunikacyjne. Wygodnie. 3/5",
                "Trasa przez miasto, ciekawe zabytki po drodze. 3/5"
            ])
        
        # Recenzje sezonowe
        seasonal_reviews = [
            "Wiosną najpiękniej - wszystko kwitnie! Polecam maj. 5/5",
            "Latem może być gorąco, ale widoki rekompensują. Zabierz kapelusz. 4/5",
            "Jesienią kolory liści są niesamowite! Złota polska jesień. 5/5",
            "Zimą trasa trudniejsza ale magiczna. Raki na buty obowiązkowo. 4/5"
        ]
        
        # Losowo wybierz 5-8 recenzji z różnych kategorii
        import random
        
        # Dodaj pozytywne (60% szans)
        sample_reviews.extend(random.sample(positive_reviews, min(3, len(positive_reviews))))
        
        # Dodaj neutralne (25% szans)
        if random.random() < 0.6:  # 60% szans na dodanie neutralnej
            sample_reviews.extend(random.sample(neutral_reviews, min(2, len(neutral_reviews))))
        
        # Dodaj negatywne (15% szans)
        if random.random() < 0.4:  # 40% szans na dodanie negatywnej
            sample_reviews.extend(random.sample(negative_reviews, min(1, len(negative_reviews))))
        
        # Dodaj sezonową
        sample_reviews.append(random.choice(seasonal_reviews))
        
        # Ogranicz do 6-8 recenzji
        return random.sample(sample_reviews, min(8, len(sample_reviews)))

    def get_enhanced_trails(self) -> List[Dict[str, Any]]:
        """
        Zwraca wszystkie trasy z rozszerzoną analizą.
        
        Returns:
            Lista rozszerzonych danych tras
        """
        all_trails = []
        base_trails = self.get_trails()
        
        for trail in base_trails:
            enhanced_trail = self.enhance_trail_with_analysis(trail)
            all_trails.append(enhanced_trail)
        
        return all_trails

    def get_enhanced_trails_for_city(self, city: str) -> List[Dict[str, Any]]:
        """
        Zwraca rozszerzone dane tras dla konkretnego miasta.
        
        Args:
            city: Nazwa miasta
            
        Returns:
            Lista rozszerzonych tras dla miasta
        """
        city_trails = self.get_trails_for_city(city)
        enhanced_trails = []
        
        for trail in city_trails:
            enhanced_trail = self.enhance_trail_with_analysis(trail)
            enhanced_trails.append(enhanced_trail)
        
        return enhanced_trails

    def collect_additional_trail_data(self, max_trails: int = 10) -> List[Dict[str, Any]]:
        """
        Zbiera dodatkowe dane o trasach z web collectora.
        
        Args:
            max_trails: Maksymalna liczba tras do zebrania
            
        Returns:
            Lista dodatkowych tras
        """
        try:
            additional_trails = self.web_collector.collect_sample_data()
            
            # Przetwórz dodatkowe trasy przez analizery
            processed_trails = []
            for trail in additional_trails[:max_trails]:
                enhanced_trail = self.enhance_trail_with_analysis(trail)
                processed_trails.append(enhanced_trail)
            
            return processed_trails
            
        except Exception as e:
            print(f"Błąd podczas zbierania dodatkowych danych o trasach: {e}")
            return []

#data_handlers\weather_data.py

import json
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
import os
import sys

# Dodaj katalog projektu do ścieżki Pythona
project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(project_root)

from api.weather_api import WeatherAPI
from config import CITY_COORDINATES

class WeatherDataHandler:
    def __init__(self):
        self.api = WeatherAPI()

    def _validate_weather(self, weather: Any) -> Dict[str, Any]:
        """Waliduje i formatuje dane pogodowe."""
        if not isinstance(weather, dict):
            return None
            
        # Wymagane pola z domyślnymi wartościami
        default_weather = {
            "date": datetime.now().strftime("%Y-%m-%d"),
            "city": "nieznane",
            "temperature": 0.0,
            "temperature_min": 0.0,
            "temperature_max": 0.0,
            "precipitation": 0.0,
            "wind_speed": 0.0,
            "cloud_cover": 0,
            "sunshine_hours": 0.0,
            "conditions": "nieznane"
        }
        
        # Aktualizuj wartości domyślne rzeczywistymi danymi, jeśli są poprawne
        if isinstance(weather, dict):
            for key in default_weather:
                if key in weather and weather[key] is not None:
                    default_weather[key] = weather[key]
                    
            # Ensure numeric fields are correct type
            try:
                default_weather["temperature"] = float(default_weather["temperature"])
                default_weather["precipitation"] = float(default_weather["precipitation"])
                default_weather["wind_speed"] = float(default_weather["wind_speed"])
            except (ValueError, TypeError):
                default_weather["temperature"] = 0.0
                default_weather["precipitation"] = 0.0
                default_weather["wind_speed"] = 0.0
                
        return default_weather

    def get_weather(self, city: str, date: str = None) -> Dict[str, Any]:
        """Get weather for a specific city and date, always fetching from API."""
        print(f"Pobieranie prognozy pogody dla miasta {city} z API...")
        weather = self.api.get_weather_forecast(city, date)
        return self._validate_weather(weather)

    def get_weather_for_region(self, region: str, date: str = None) -> List[Dict[str, Any]]:
        """Get weather for all cities in a region."""
        weather_data = []
        for city in CITY_COORDINATES.keys():
            if city.lower() == region.lower():
                weather = self.get_weather(city, date)
                if weather:
                    weather_data.append(weather)
        return weather_data

    def get_weather_for_date_range(self, city: str, start_date: str, end_date: str) -> List[Dict[str, Any]]:
        """Get weather for a date range."""
        weather_data = []
        current_date = datetime.strptime(start_date, "%Y-%m-%d")
        end_date = datetime.strptime(end_date, "%Y-%m-%d")
        
        while current_date <= end_date:
            weather = self.get_weather(city, current_date.strftime("%Y-%m-%d"))
            if weather:
                weather_data.append(weather)
            current_date += timedelta(days=1)
            
        return weather_data

    def get_average_temperature(self, city: str, date: str = None) -> float:
        """Calculate average temperature for a city."""
        weather = self.get_weather(city, date)
        return weather.get('temperature', 0.0) if weather else 0.0

    def get_precipitation_probability(self, city: str, date: str = None) -> float:
        """Get precipitation probability for a city."""
        weather = self.get_weather(city, date)
        return weather.get('precipitation', 0.0) if weather else 0.0

    def get_weather_forecast(self, city: str, date: str) -> Optional[Dict[str, Any]]:
        """Get weather forecast for a specific date."""
        try:
            # Convert date string to datetime
            target_date = datetime.strptime(date, "%Y-%m-%d")
            today = datetime.now().date()
            
            # Choose appropriate API endpoint based on date
            if target_date.date() < today:
                print(f"Pobieranie historycznych danych pogodowych dla {city} na dzień {date}...")
                weather_data = self.api._get_historical_weather(city, date)
            else:
                print(f"Pobieranie prognozy pogody dla {city} na dzień {date}...")
                weather_data = self.api._get_future_weather(city, date)
            
            if weather_data:
                return weather_data
            else:
                print("Nie udało się pobrać danych pogodowych")
                return None
                
        except Exception as e:
            print(f"Błąd podczas pobierania danych pogodowych: {e}")
            return None 

#database\repositories\__init__.py

"""
Repositories module - Etap 4: Integracja z bazą danych
"""

from .route_repository import RouteRepository
from .weather_repository import WeatherRepository
from .user_repository import UserRepository

__all__ = [
    'RouteRepository',
    'WeatherRepository',
    'UserRepository'
] 

#database\repositories\route_repository.py

"""
RouteRepository - Repozytorium do obsługi tras turystycznych
Etap 4: Integracja z bazą danych
"""

import logging
from typing import List, Dict, Any, Optional, Tuple
from datetime import datetime
import json
import math

from ..database_manager import DatabaseManager, rows_to_dicts, row_to_dict

logger = logging.getLogger(__name__)

class RouteRepository:
    """
    Repozytorium do obsługi tras turystycznych w bazie danych.
    Implementuje podstawowe operacje CRUD oraz zaawansowane wyszukiwanie.
    """
    
    def __init__(self, db_manager: DatabaseManager):
        """
        Inicjalizuje repozytorium tras.
        
        Args:
            db_manager: Menedżer bazy danych
        """
        self.db_manager = db_manager
        logger.info("Inicjalizacja RouteRepository")
    
    def add_route(self, route_data: Dict[str, Any]) -> Optional[int]:
        """
        Dodaje nową trasę do bazy danych.
        
        Args:
            route_data: Słownik z danymi trasy
            
        Returns:
            ID nowej trasy lub None w przypadku błędu
        """
        try:
            # Przygotuj zapytanie INSERT
            query = """
                INSERT INTO routes (
                    name, region, start_lat, start_lon, end_lat, end_lon,
                    length_km, elevation_gain, difficulty, terrain_type,
                    tags, description, category, estimated_time, user_rating
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """
            
            params = (
                route_data.get('name', ''),
                route_data.get('region'),
                route_data.get('start_lat', 0.0),
                route_data.get('start_lon', 0.0),
                route_data.get('end_lat', 0.0),
                route_data.get('end_lon', 0.0),
                route_data.get('length_km'),
                route_data.get('elevation_gain'),
                route_data.get('difficulty'),
                route_data.get('terrain_type'),
                route_data.get('tags'),
                route_data.get('description'),
                route_data.get('category', 'sportowa'),
                route_data.get('estimated_time'),
                route_data.get('user_rating')
            )
            
            route_id = self.db_manager.execute_insert(query, params)
            
            if route_id:
                logger.info(f"✅ Dodano trasę: {route_data.get('name')} (ID: {route_id})")
                
                # Dodaj recenzje jeśli są dostępne
                if 'reviews' in route_data and route_data['reviews']:
                    self._add_route_reviews(route_id, route_data['reviews'])
            
            return route_id
            
        except Exception as e:
            logger.error(f"Błąd dodawania trasy: {e}")
            return None
    
    def get_route_by_id(self, route_id: int) -> Optional[Dict[str, Any]]:
        """
        Pobiera trasę po ID.
        
        Args:
            route_id: ID trasy
            
        Returns:
            Słownik z danymi trasy lub None
        """
        try:
            query = "SELECT * FROM routes WHERE id = ?"
            results = self.db_manager.execute_query(query, (route_id,))
            
            if results:
                route = row_to_dict(results[0])
                # Dodaj recenzje
                route['reviews'] = self._get_route_reviews(route_id)
                return route
            
            return None
            
        except Exception as e:
            logger.error(f"Błąd pobierania trasy {route_id}: {e}")
            return None
    
    def find_routes_by_region(self, region: str, limit: int = 50) -> List[Dict[str, Any]]:
        """
        Wyszukuje trasy w określonym regionie.
        
        Args:
            region: Nazwa regionu
            limit: Maksymalna liczba wyników
            
        Returns:
            Lista tras
        """
        try:
            query = """
                SELECT * FROM routes 
                WHERE region LIKE ? 
                ORDER BY user_rating DESC, name
                LIMIT ?
            """
            
            results = self.db_manager.execute_query(query, (f"%{region}%", limit))
            routes = rows_to_dicts(results)
            
            # Dodaj recenzje do każdej trasy
            for route in routes:
                route['reviews'] = self._get_route_reviews(route['id'])
            
            logger.info(f"Znaleziono {len(routes)} tras w regionie: {region}")
            return routes
            
        except Exception as e:
            logger.error(f"Błąd wyszukiwania tras w regionie {region}: {e}")
            return []
    
    def find_routes_by_difficulty(self, max_difficulty: int, limit: int = 50) -> List[Dict[str, Any]]:
        """
        Wyszukuje trasy o określonej maksymalnej trudności.
        
        Args:
            max_difficulty: Maksymalna trudność (1-5)
            limit: Maksymalna liczba wyników
            
        Returns:
            Lista tras
        """
        try:
            query = """
                SELECT * FROM routes 
                WHERE difficulty <= ? 
                ORDER BY difficulty, user_rating DESC
                LIMIT ?
            """
            
            results = self.db_manager.execute_query(query, (max_difficulty, limit))
            routes = rows_to_dicts(results)
            
            # Dodaj recenzje do każdej trasy
            for route in routes:
                route['reviews'] = self._get_route_reviews(route['id'])
            
            logger.info(f"Znaleziono {len(routes)} tras o trudności <= {max_difficulty}")
            return routes
            
        except Exception as e:
            logger.error(f"Błąd wyszukiwania tras po trudności: {e}")
            return []
    
    def find_routes_by_region_and_difficulty(self, region: str, max_difficulty: int, limit: int = 50) -> List[Dict[str, Any]]:
        """
        Wyszukuje trasy w regionie o określonej maksymalnej trudności.
        
        Args:
            region: Nazwa regionu
            max_difficulty: Maksymalna trudność
            limit: Maksymalna liczba wyników
            
        Returns:
            Lista tras
        """
        try:
            query = """
                SELECT * FROM routes 
                WHERE region LIKE ? AND difficulty <= ?
                ORDER BY user_rating DESC, difficulty
                LIMIT ?
            """
            
            results = self.db_manager.execute_query(query, (f"%{region}%", max_difficulty, limit))
            routes = rows_to_dicts(results)
            
            # Dodaj recenzje do każdej trasy
            for route in routes:
                route['reviews'] = self._get_route_reviews(route['id'])
            
            logger.info(f"Znaleziono {len(routes)} tras w regionie {region} o trudności <= {max_difficulty}")
            return routes
            
        except Exception as e:
            logger.error(f"Błąd wyszukiwania tras: {e}")
            return []
    
    def find_routes_in_radius(self, lat: float, lon: float, radius_km: float, limit: int = 50) -> List[Dict[str, Any]]:
        """
        Wyszukuje trasy w określonym promieniu od punktu.
        
        Args:
            lat: Szerokość geograficzna punktu
            lon: Długość geograficzna punktu
            radius_km: Promień wyszukiwania w kilometrach
            limit: Maksymalna liczba wyników
            
        Returns:
            Lista tras z odległościami
        """
        try:
            # Pobierz wszystkie trasy (można zoptymalizować używając bounding box)
            query = "SELECT * FROM routes"
            results = self.db_manager.execute_query(query)
            
            routes_with_distance = []
            
            for row in results:
                route = row_to_dict(row)
                
                # Oblicz odległość do punktu startowego trasy
                distance = self._calculate_distance(
                    lat, lon, 
                    route['start_lat'], route['start_lon']
                )
                
                if distance <= radius_km:
                    route['distance_km'] = round(distance, 2)
                    route['reviews'] = self._get_route_reviews(route['id'])
                    routes_with_distance.append(route)
            
            # Sortuj po odległości
            routes_with_distance.sort(key=lambda x: x['distance_km'])
            
            # Ogranicz wyniki
            routes_with_distance = routes_with_distance[:limit]
            
            logger.info(f"Znaleziono {len(routes_with_distance)} tras w promieniu {radius_km}km")
            return routes_with_distance
            
        except Exception as e:
            logger.error(f"Błąd wyszukiwania tras w promieniu: {e}")
            return []
    
    def search_routes(self, criteria: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Zaawansowane wyszukiwanie tras według wielu kryteriów.
        
        Args:
            criteria: Słownik z kryteriami wyszukiwania
            
        Returns:
            Lista tras spełniających kryteria
        """
        try:
            # Buduj zapytanie dynamicznie
            where_conditions = []
            params = []
            
            if criteria.get('name'):
                where_conditions.append("name LIKE ?")
                params.append(f"%{criteria['name']}%")
            
            if criteria.get('region'):
                where_conditions.append("region LIKE ?")
                params.append(f"%{criteria['region']}%")
            
            if criteria.get('max_difficulty'):
                where_conditions.append("difficulty <= ?")
                params.append(criteria['max_difficulty'])
            
            if criteria.get('min_length'):
                where_conditions.append("length_km >= ?")
                params.append(criteria['min_length'])
            
            if criteria.get('max_length'):
                where_conditions.append("length_km <= ?")
                params.append(criteria['max_length'])
            
            if criteria.get('terrain_type'):
                where_conditions.append("terrain_type LIKE ?")
                params.append(f"%{criteria['terrain_type']}%")
            
            if criteria.get('category'):
                where_conditions.append("category = ?")
                params.append(criteria['category'])
            
            if criteria.get('min_rating'):
                where_conditions.append("user_rating >= ?")
                params.append(criteria['min_rating'])
            
            # Buduj zapytanie
            query = "SELECT * FROM routes"
            if where_conditions:
                query += " WHERE " + " AND ".join(where_conditions)
            
            query += " ORDER BY user_rating DESC, name"
            
            # Dodaj limit
            limit = criteria.get('limit', 50)
            query += f" LIMIT {limit}"
            
            results = self.db_manager.execute_query(query, tuple(params))
            routes = rows_to_dicts(results)
            
            # Dodaj recenzje do każdej trasy
            for route in routes:
                route['reviews'] = self._get_route_reviews(route['id'])
            
            logger.info(f"Wyszukiwanie zaawansowane: znaleziono {len(routes)} tras")
            return routes
            
        except Exception as e:
            logger.error(f"Błąd zaawansowanego wyszukiwania: {e}")
            return []
    
    def get_all_routes(self, limit: int = 100) -> List[Dict[str, Any]]:
        """
        Pobiera wszystkie trasy z bazy danych.
        
        Args:
            limit: Maksymalna liczba wyników
            
        Returns:
            Lista wszystkich tras
        """
        try:
            query = "SELECT * FROM routes ORDER BY name LIMIT ?"
            results = self.db_manager.execute_query(query, (limit,))
            routes = rows_to_dicts(results)
            
            # Dodaj recenzje do każdej trasy (może być kosztowne dla dużej liczby tras)
            for route in routes:
                route['reviews'] = self._get_route_reviews(route['id'])
            
            logger.info(f"Pobrano {len(routes)} tras z bazy danych")
            return routes
            
        except Exception as e:
            logger.error(f"Błąd pobierania wszystkich tras: {e}")
            return []
    
    def update_route(self, route_id: int, route_data: Dict[str, Any]) -> bool:
        """
        Aktualizuje dane trasy.
        
        Args:
            route_id: ID trasy do aktualizacji
            route_data: Nowe dane trasy
            
        Returns:
            True jeśli aktualizacja się powiodła
        """
        try:
            # Buduj zapytanie UPDATE dynamicznie
            set_clauses = []
            params = []
            
            updatable_fields = [
                'name', 'region', 'start_lat', 'start_lon', 'end_lat', 'end_lon',
                'length_km', 'elevation_gain', 'difficulty', 'terrain_type',
                'tags', 'description', 'category', 'estimated_time', 'user_rating'
            ]
            
            for field in updatable_fields:
                if field in route_data:
                    set_clauses.append(f"{field} = ?")
                    params.append(route_data[field])
            
            if not set_clauses:
                logger.warning("Brak danych do aktualizacji")
                return False
            
            params.append(route_id)
            
            query = f"UPDATE routes SET {', '.join(set_clauses)} WHERE id = ?"
            
            rows_affected = self.db_manager.execute_update(query, tuple(params))
            
            if rows_affected > 0:
                logger.info(f"✅ Zaktualizowano trasę ID: {route_id}")
                return True
            else:
                logger.warning(f"Nie znaleziono trasy ID: {route_id}")
                return False
                
        except Exception as e:
            logger.error(f"Błąd aktualizacji trasy {route_id}: {e}")
            return False
    
    def delete_route(self, route_id: int) -> bool:
        """
        Usuwa trasę z bazy danych.
        
        Args:
            route_id: ID trasy do usunięcia
            
        Returns:
            True jeśli usunięcie się powiodło
        """
        try:
            query = "DELETE FROM routes WHERE id = ?"
            rows_affected = self.db_manager.execute_update(query, (route_id,))
            
            if rows_affected > 0:
                logger.info(f"✅ Usunięto trasę ID: {route_id}")
                return True
            else:
                logger.warning(f"Nie znaleziono trasy ID: {route_id}")
                return False
                
        except Exception as e:
            logger.error(f"Błąd usuwania trasy {route_id}: {e}")
            return False
    
    def get_route_statistics(self) -> Dict[str, Any]:
        """
        Pobiera statystyki tras.
        
        Returns:
            Słownik ze statystykami
        """
        try:
            stats = {}
            
            # Liczba tras
            result = self.db_manager.execute_query("SELECT COUNT(*) as count FROM routes")
            stats['total_routes'] = result[0]['count'] if result else 0
            
            # Rozkład trudności
            result = self.db_manager.execute_query("""
                SELECT difficulty, COUNT(*) as count 
                FROM routes 
                WHERE difficulty IS NOT NULL 
                GROUP BY difficulty 
                ORDER BY difficulty
            """)
            stats['difficulty_distribution'] = [dict(row) for row in result]
            
            # Najpopularniejsze regiony
            result = self.db_manager.execute_query("""
                SELECT region, COUNT(*) as count 
                FROM routes 
                WHERE region IS NOT NULL 
                GROUP BY region 
                ORDER BY count DESC 
                LIMIT 10
            """)
            stats['popular_regions'] = [dict(row) for row in result]
            
            # Rozkład kategorii
            result = self.db_manager.execute_query("""
                SELECT category, COUNT(*) as count 
                FROM routes 
                WHERE category IS NOT NULL 
                GROUP BY category 
                ORDER BY count DESC
            """)
            stats['category_distribution'] = [dict(row) for row in result]
            
            # Średnie wartości
            result = self.db_manager.execute_query("""
                SELECT 
                    AVG(length_km) as avg_length,
                    AVG(elevation_gain) as avg_elevation,
                    AVG(user_rating) as avg_rating,
                    AVG(estimated_time) as avg_time
                FROM routes 
                WHERE length_km IS NOT NULL
            """)
            if result:
                row = result[0]
                stats['averages'] = {
                    'length_km': round(row['avg_length'], 2) if row['avg_length'] else 0,
                    'elevation_gain': round(row['avg_elevation'], 1) if row['avg_elevation'] else 0,
                    'user_rating': round(row['avg_rating'], 2) if row['avg_rating'] else 0,
                    'estimated_time': round(row['avg_time'], 1) if row['avg_time'] else 0
                }
            
            return stats
            
        except Exception as e:
            logger.error(f"Błąd pobierania statystyk tras: {e}")
            return {}
    
    def _add_route_reviews(self, route_id: int, reviews: List[str]) -> None:
        """
        Dodaje recenzje do trasy.
        
        Args:
            route_id: ID trasy
            reviews: Lista recenzji
        """
        try:
            for review_text in reviews:
                query = """
                    INSERT INTO route_reviews (
                        route_id, review_text, rating, sentiment
                    ) VALUES (?, ?, ?, ?)
                """
                
                # Prosta analiza sentymentu
                sentiment = 'positive' if any(word in review_text.lower() for word in ['dobra', 'świetna', 'polecam']) else 'neutral'
                rating = 4.0 if sentiment == 'positive' else 3.0
                
                params = (route_id, review_text, rating, sentiment)
                self.db_manager.execute_insert(query, params)
            
            logger.info(f"Dodano {len(reviews)} recenzji do trasy {route_id}")
            
        except Exception as e:
            logger.error(f"Błąd dodawania recenzji: {e}")
    
    def _get_route_reviews(self, route_id: int) -> List[str]:
        """
        Pobiera recenzje trasy.
        
        Args:
            route_id: ID trasy
            
        Returns:
            Lista recenzji
        """
        try:
            query = "SELECT review_text FROM route_reviews WHERE route_id = ? ORDER BY created_at DESC"
            results = self.db_manager.execute_query(query, (route_id,))
            
            return [row['review_text'] for row in results]
            
        except Exception as e:
            logger.error(f"Błąd pobierania recenzji trasy {route_id}: {e}")
            return []
    
    def _calculate_distance(self, lat1: float, lon1: float, lat2: float, lon2: float) -> float:
        """
        Oblicza odległość między dwoma punktami geograficznymi (wzór Haversine).
        
        Args:
            lat1, lon1: Współrzędne pierwszego punktu
            lat2, lon2: Współrzędne drugiego punktu
            
        Returns:
            Odległość w kilometrach
        """
        # Promień Ziemi w kilometrach
        R = 6371.0
        
        # Konwersja na radiany
        lat1_rad = math.radians(lat1)
        lon1_rad = math.radians(lon1)
        lat2_rad = math.radians(lat2)
        lon2_rad = math.radians(lon2)
        
        # Różnice
        dlat = lat2_rad - lat1_rad
        dlon = lon2_rad - lon1_rad
        
        # Wzór Haversine
        a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
        
        return R * c

#database\repositories\user_repository.py

"""
UserRepository - Repozytorium do obsługi preferencji użytkowników
Etap 4: Integracja z bazą danych
"""

import logging
from typing import List, Dict, Any, Optional
from datetime import datetime
import json

from ..database_manager import DatabaseManager, rows_to_dicts, row_to_dict

logger = logging.getLogger(__name__)

class UserRepository:
    """
    Repozytorium do obsługi preferencji użytkowników w bazie danych.
    """
    
    def __init__(self, db_manager: DatabaseManager):
        self.db_manager = db_manager
        logger.info("Inicjalizacja UserRepository")
    
    def save_user_preferences(self, user_name: str = 'default', preferences: Dict[str, Any] = None) -> Optional[int]:
        """Zapisuje preferencje użytkownika."""
        try:
            if preferences is None:
                preferences = {}
            
            # Sprawdź czy użytkownik już istnieje
            existing = self.get_user_preferences(user_name)
            
            if existing:
                # Aktualizuj istniejące preferencje
                return self._update_user_preferences(existing['id'], preferences)
            else:
                # Utwórz nowe preferencje
                query = """
                    INSERT INTO user_preferences (
                        user_name, preferred_temp_min, preferred_temp_max, max_precipitation,
                        max_difficulty, max_length_km, preferred_terrain_types, preferred_categories
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """
                
                params = (
                    user_name,
                    preferences.get('preferred_temp_min', 15.0),
                    preferences.get('preferred_temp_max', 25.0),
                    preferences.get('max_precipitation', 5.0),
                    preferences.get('max_difficulty', 3),
                    preferences.get('max_length_km', 20.0),
                    ','.join(preferences.get('preferred_terrain_types', ['górski', 'leśny'])),
                    ','.join(preferences.get('preferred_categories', ['sportowa', 'widokowa']))
                )
                
                pref_id = self.db_manager.execute_insert(query, params)
                
                if pref_id:
                    logger.info(f"✅ Zapisano preferencje użytkownika: {user_name} (ID: {pref_id})")
                
                return pref_id
                
        except Exception as e:
            logger.error(f"Błąd zapisywania preferencji użytkownika: {e}")
            return None
    
    def get_user_preferences(self, user_name: str = 'default') -> Optional[Dict[str, Any]]:
        """Pobiera preferencje użytkownika."""
        try:
            query = "SELECT * FROM user_preferences WHERE user_name = ? ORDER BY updated_at DESC LIMIT 1"
            results = self.db_manager.execute_query(query, (user_name,))
            
            if results:
                prefs = row_to_dict(results[0])
                
                # Konwertuj stringi z powrotem na listy
                if prefs.get('preferred_terrain_types'):
                    prefs['preferred_terrain_types'] = prefs['preferred_terrain_types'].split(',')
                if prefs.get('preferred_categories'):
                    prefs['preferred_categories'] = prefs['preferred_categories'].split(',')
                
                logger.info(f"Pobrano preferencje użytkownika: {user_name}")
                return prefs
            
            logger.info(f"Brak preferencji dla użytkownika: {user_name}")
            return None
            
        except Exception as e:
            logger.error(f"Błąd pobierania preferencji użytkownika: {e}")
            return None
    
    def _update_user_preferences(self, pref_id: int, preferences: Dict[str, Any]) -> Optional[int]:
        """Aktualizuje istniejące preferencje użytkownika."""
        try:
            set_clauses = []
            params = []
            
            updatable_fields = {
                'preferred_temp_min': preferences.get('preferred_temp_min'),
                'preferred_temp_max': preferences.get('preferred_temp_max'),
                'max_precipitation': preferences.get('max_precipitation'),
                'max_difficulty': preferences.get('max_difficulty'),
                'max_length_km': preferences.get('max_length_km'),
                'preferred_terrain_types': ','.join(preferences.get('preferred_terrain_types', [])) if preferences.get('preferred_terrain_types') else None,
                'preferred_categories': ','.join(preferences.get('preferred_categories', [])) if preferences.get('preferred_categories') else None
            }
            
            for field, value in updatable_fields.items():
                if value is not None:
                    set_clauses.append(f"{field} = ?")
                    params.append(value)
            
            if not set_clauses:
                return pref_id
            
            params.append(pref_id)
            
            query = f"UPDATE user_preferences SET {', '.join(set_clauses)} WHERE id = ?"
            
            rows_affected = self.db_manager.execute_update(query, tuple(params))
            
            if rows_affected > 0:
                logger.info(f"✅ Zaktualizowano preferencje użytkownika ID: {pref_id}")
                return pref_id
            
            return None
            
        except Exception as e:
            logger.error(f"Błąd aktualizacji preferencji: {e}")
            return None
    
    def save_recommendation_history(self, user_name: str, search_criteria: Dict[str, Any], recommended_routes: List[Dict[str, Any]]) -> Optional[int]:
        """Zapisuje historię rekomendacji."""
        try:
            query = """
                INSERT INTO recommendation_history (
                    user_name, search_criteria, recommended_routes
                ) VALUES (?, ?, ?)
            """
            
            # Konwertuj na JSON
            criteria_json = json.dumps(search_criteria, ensure_ascii=False)
            routes_json = json.dumps([route.get('name', 'Unknown') for route in recommended_routes], ensure_ascii=False)
            
            params = (user_name, criteria_json, routes_json)
            
            history_id = self.db_manager.execute_insert(query, params)
            
            if history_id:
                logger.info(f"✅ Zapisano historię rekomendacji dla: {user_name} (ID: {history_id})")
            
            return history_id
            
        except Exception as e:
            logger.error(f"Błąd zapisywania historii rekomendacji: {e}")
            return None
    
    def get_recommendation_history(self, user_name: str, limit: int = 10) -> List[Dict[str, Any]]:
        """Pobiera historię rekomendacji użytkownika."""
        try:
            query = """
                SELECT * FROM recommendation_history 
                WHERE user_name = ? 
                ORDER BY search_date DESC 
                LIMIT ?
            """
            
            results = self.db_manager.execute_query(query, (user_name, limit))
            history = rows_to_dicts(results)
            
            # Konwertuj JSON z powrotem na obiekty
            for item in history:
                try:
                    if item.get('search_criteria'):
                        item['search_criteria'] = json.loads(item['search_criteria'])
                    if item.get('recommended_routes'):
                        item['recommended_routes'] = json.loads(item['recommended_routes'])
                except json.JSONDecodeError:
                    logger.warning(f"Błąd parsowania JSON w historii ID: {item.get('id')}")
            
            logger.info(f"Pobrano {len(history)} rekordów historii dla: {user_name}")
            return history
            
        except Exception as e:
            logger.error(f"Błąd pobierania historii rekomendacji: {e}")
            return []
    
    def get_all_users(self) -> List[str]:
        """Pobiera listę wszystkich użytkowników."""
        try:
            query = "SELECT DISTINCT user_name FROM user_preferences ORDER BY user_name"
            results = self.db_manager.execute_query(query)
            
            users = [row['user_name'] for row in results]
            logger.info(f"Znaleziono {len(users)} użytkowników")
            return users
            
        except Exception as e:
            logger.error(f"Błąd pobierania listy użytkowników: {e}")
            return []
    
    def delete_user_data(self, user_name: str) -> bool:
        """Usuwa wszystkie dane użytkownika."""
        try:
            # Usuń preferencje
            query1 = "DELETE FROM user_preferences WHERE user_name = ?"
            prefs_deleted = self.db_manager.execute_update(query1, (user_name,))
            
            # Usuń historię
            query2 = "DELETE FROM recommendation_history WHERE user_name = ?"
            history_deleted = self.db_manager.execute_update(query2, (user_name,))
            
            total_deleted = prefs_deleted + history_deleted
            
            if total_deleted > 0:
                logger.info(f"✅ Usunięto dane użytkownika {user_name}: {prefs_deleted} preferencji, {history_deleted} historii")
                return True
            else:
                logger.warning(f"Nie znaleziono danych użytkownika: {user_name}")
                return False
                
        except Exception as e:
            logger.error(f"Błąd usuwania danych użytkownika: {e}")
            return False
    
    def get_user_statistics(self) -> Dict[str, Any]:
        """Pobiera statystyki użytkowników."""
        try:
            stats = {}
            
            # Liczba użytkowników
            query = "SELECT COUNT(DISTINCT user_name) as count FROM user_preferences"
            results = self.db_manager.execute_query(query)
            stats['total_users'] = results[0]['count'] if results else 0
            
            # Liczba preferencji
            query = "SELECT COUNT(*) as count FROM user_preferences"
            results = self.db_manager.execute_query(query)
            stats['total_preferences'] = results[0]['count'] if results else 0
            
            return stats
            
        except Exception as e:
            logger.error(f"Błąd pobierania statystyk użytkowników: {e}")
            return {}

#database\repositories\weather_repository.py

"""
WeatherRepository - Repozytorium do obsługi danych pogodowych
Etap 4: Integracja z bazą danych
"""

import logging
from typing import List, Dict, Any, Optional, Tuple
from datetime import datetime, date
import json

from ..database_manager import DatabaseManager, rows_to_dicts, row_to_dict

logger = logging.getLogger(__name__)

class WeatherRepository:
    """
    Repozytorium do obsługi danych pogodowych w bazie danych.
    Implementuje operacje CRUD oraz statystyki pogodowe.
    """
    
    def __init__(self, db_manager: DatabaseManager):
        """
        Inicjalizuje repozytorium danych pogodowych.
        
        Args:
            db_manager: Menedżer bazy danych
        """
        self.db_manager = db_manager
        logger.info("Inicjalizacja WeatherRepository")
    
    def add_weather_data(self, weather_data: Dict[str, Any]) -> Optional[int]:
        """
        Dodaje dane pogodowe do bazy danych.
        
        Args:
            weather_data: Słownik z danymi pogodowymi
            
        Returns:
            ID nowego rekordu lub None w przypadku błędu
        """
        try:
            query = """
                INSERT OR REPLACE INTO weather_data (
                    date, location_lat, location_lon, avg_temp, min_temp, max_temp,
                    precipitation, sunshine_hours, cloud_cover, wind_speed, humidity
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """
            
            params = (
                weather_data.get('date'),
                weather_data.get('location_lat', 0.0),
                weather_data.get('location_lon', 0.0),
                weather_data.get('avg_temp'),
                weather_data.get('min_temp'),
                weather_data.get('max_temp'),
                weather_data.get('precipitation', 0.0),
                weather_data.get('sunshine_hours'),
                weather_data.get('cloud_cover'),
                weather_data.get('wind_speed'),
                weather_data.get('humidity')
            )
            
            weather_id = self.db_manager.execute_insert(query, params)
            
            if weather_id:
                logger.info(f"✅ Dodano dane pogodowe: {weather_data.get('date')} (ID: {weather_id})")
            
            return weather_id
            
        except Exception as e:
            logger.error(f"Błąd dodawania danych pogodowych: {e}")
            return None
    
    def get_weather_by_date_and_location(self, target_date: str, lat: float, lon: float, tolerance: float = 0.1) -> Optional[Dict[str, Any]]:
        """
        Pobiera dane pogodowe dla określonej daty i lokalizacji.
        
        Args:
            target_date: Data w formacie YYYY-MM-DD
            lat: Szerokość geograficzna
            lon: Długość geograficzna
            tolerance: Tolerancja dla współrzędnych (stopnie)
            
        Returns:
            Słownik z danymi pogodowymi lub None
        """
        try:
            query = """
                SELECT * FROM weather_data 
                WHERE date = ? 
                AND location_lat BETWEEN ? AND ?
                AND location_lon BETWEEN ? AND ?
                ORDER BY 
                    ABS(location_lat - ?) + ABS(location_lon - ?)
                LIMIT 1
            """
            
            params = (
                target_date,
                lat - tolerance, lat + tolerance,
                lon - tolerance, lon + tolerance,
                lat, lon
            )
            
            results = self.db_manager.execute_query(query, params)
            
            if results:
                weather = row_to_dict(results[0])
                logger.info(f"Znaleziono dane pogodowe dla {target_date} w lokalizacji ({lat}, {lon})")
                return weather
            
            logger.warning(f"Brak danych pogodowych dla {target_date} w lokalizacji ({lat}, {lon})")
            return None
            
        except Exception as e:
            logger.error(f"Błąd pobierania danych pogodowych: {e}")
            return None
    
    def get_weather_for_location_range(self, lat: float, lon: float, start_date: str, end_date: str, tolerance: float = 0.1) -> List[Dict[str, Any]]:
        """
        Pobiera dane pogodowe dla lokalizacji w określonym zakresie dat.
        
        Args:
            lat: Szerokość geograficzna
            lon: Długość geograficzna
            start_date: Data początkowa (YYYY-MM-DD)
            end_date: Data końcowa (YYYY-MM-DD)
            tolerance: Tolerancja dla współrzędnych
            
        Returns:
            Lista danych pogodowych
        """
        try:
            query = """
                SELECT * FROM weather_data 
                WHERE date BETWEEN ? AND ?
                AND location_lat BETWEEN ? AND ?
                AND location_lon BETWEEN ? AND ?
                ORDER BY date
            """
            
            params = (
                start_date, end_date,
                lat - tolerance, lat + tolerance,
                lon - tolerance, lon + tolerance
            )
            
            results = self.db_manager.execute_query(query, params)
            weather_data = rows_to_dicts(results)
            
            logger.info(f"Znaleziono {len(weather_data)} rekordów pogodowych dla lokalizacji ({lat}, {lon}) w okresie {start_date} - {end_date}")
            return weather_data
            
        except Exception as e:
            logger.error(f"Błąd pobierania danych pogodowych dla zakresu: {e}")
            return []
    
    def get_weather_statistics_for_location(self, lat: float, lon: float, tolerance: float = 0.1) -> Dict[str, Any]:
        """
        Oblicza statystyki pogodowe dla lokalizacji.
        
        Args:
            lat: Szerokość geograficzna
            lon: Długość geograficzna
            tolerance: Tolerancja dla współrzędnych
            
        Returns:
            Słownik ze statystykami pogodowymi
        """
        try:
            query = """
                SELECT 
                    COUNT(*) as record_count,
                    AVG(avg_temp) as avg_temperature,
                    MIN(min_temp) as min_temperature,
                    MAX(max_temp) as max_temperature,
                    AVG(precipitation) as avg_precipitation,
                    MAX(precipitation) as max_precipitation,
                    AVG(sunshine_hours) as avg_sunshine,
                    AVG(cloud_cover) as avg_cloud_cover,
                    AVG(wind_speed) as avg_wind_speed,
                    AVG(humidity) as avg_humidity
                FROM weather_data 
                WHERE location_lat BETWEEN ? AND ?
                AND location_lon BETWEEN ? AND ?
            """
            
            params = (
                lat - tolerance, lat + tolerance,
                lon - tolerance, lon + tolerance
            )
            
            results = self.db_manager.execute_query(query, params)
            
            if results and results[0]['record_count'] > 0:
                row = results[0]
                stats = {
                    'record_count': row['record_count'],
                    'temperature': {
                        'average': round(row['avg_temperature'], 1) if row['avg_temperature'] else None,
                        'minimum': round(row['min_temperature'], 1) if row['min_temperature'] else None,
                        'maximum': round(row['max_temperature'], 1) if row['max_temperature'] else None
                    },
                    'precipitation': {
                        'average': round(row['avg_precipitation'], 1) if row['avg_precipitation'] else None,
                        'maximum': round(row['max_precipitation'], 1) if row['max_precipitation'] else None
                    },
                    'sunshine_hours': round(row['avg_sunshine'], 1) if row['avg_sunshine'] else None,
                    'cloud_cover': round(row['avg_cloud_cover'], 1) if row['avg_cloud_cover'] else None,
                    'wind_speed': round(row['avg_wind_speed'], 1) if row['avg_wind_speed'] else None,
                    'humidity': round(row['avg_humidity'], 1) if row['avg_humidity'] else None
                }
                
                logger.info(f"Obliczono statystyki pogodowe dla lokalizacji ({lat}, {lon})")
                return stats
            
            logger.warning(f"Brak danych pogodowych dla lokalizacji ({lat}, {lon})")
            return {}
            
        except Exception as e:
            logger.error(f"Błąd obliczania statystyk pogodowych: {e}")
            return {}
    
    def get_monthly_weather_statistics(self, lat: float, lon: float, tolerance: float = 0.1) -> Dict[int, Dict[str, Any]]:
        """
        Oblicza miesięczne statystyki pogodowe dla lokalizacji.
        
        Args:
            lat: Szerokość geograficzna
            lon: Długość geograficzna
            tolerance: Tolerancja dla współrzędnych
            
        Returns:
            Słownik z miesięcznymi statystykami (klucz: numer miesiąca)
        """
        try:
            query = """
                SELECT 
                    CAST(strftime('%m', date) AS INTEGER) as month,
                    COUNT(*) as record_count,
                    AVG(avg_temp) as avg_temperature,
                    AVG(precipitation) as avg_precipitation,
                    AVG(sunshine_hours) as avg_sunshine,
                    AVG(cloud_cover) as avg_cloud_cover
                FROM weather_data 
                WHERE location_lat BETWEEN ? AND ?
                AND location_lon BETWEEN ? AND ?
                GROUP BY month
                ORDER BY month
            """
            
            params = (
                lat - tolerance, lat + tolerance,
                lon - tolerance, lon + tolerance
            )
            
            results = self.db_manager.execute_query(query, params)
            
            monthly_stats = {}
            for row in results:
                month = row['month']
                monthly_stats[month] = {
                    'record_count': row['record_count'],
                    'avg_temperature': round(row['avg_temperature'], 1) if row['avg_temperature'] else None,
                    'avg_precipitation': round(row['avg_precipitation'], 1) if row['avg_precipitation'] else None,
                    'avg_sunshine': round(row['avg_sunshine'], 1) if row['avg_sunshine'] else None,
                    'avg_cloud_cover': round(row['avg_cloud_cover'], 1) if row['avg_cloud_cover'] else None
                }
            
            logger.info(f"Obliczono miesięczne statystyki pogodowe dla lokalizacji ({lat}, {lon})")
            return monthly_stats
            
        except Exception as e:
            logger.error(f"Błąd obliczania miesięcznych statystyk: {e}")
            return {}
    
    def get_weather_for_date_range(self, start_date: str, end_date: str) -> List[Dict[str, Any]]:
        """
        Pobiera wszystkie dane pogodowe z określonego zakresu dat.
        
        Args:
            start_date: Data początkowa (YYYY-MM-DD)
            end_date: Data końcowa (YYYY-MM-DD)
            
        Returns:
            Lista danych pogodowych
        """
        try:
            query = """
                SELECT * FROM weather_data 
                WHERE date BETWEEN ? AND ?
                ORDER BY date, location_lat, location_lon
            """
            
            results = self.db_manager.execute_query(query, (start_date, end_date))
            weather_data = rows_to_dicts(results)
            
            logger.info(f"Pobrano {len(weather_data)} rekordów pogodowych z okresu {start_date} - {end_date}")
            return weather_data
            
        except Exception as e:
            logger.error(f"Błąd pobierania danych pogodowych z zakresu: {e}")
            return []
    
    def delete_old_weather_data(self, cutoff_date: str) -> int:
        """
        Usuwa stare dane pogodowe sprzed określonej daty.
        
        Args:
            cutoff_date: Data graniczna (YYYY-MM-DD)
            
        Returns:
            Liczba usuniętych rekordów
        """
        try:
            query = "DELETE FROM weather_data WHERE date < ?"
            rows_affected = self.db_manager.execute_update(query, (cutoff_date,))
            
            logger.info(f"✅ Usunięto {rows_affected} starych rekordów pogodowych sprzed {cutoff_date}")
            return rows_affected
            
        except Exception as e:
            logger.error(f"Błąd usuwania starych danych pogodowych: {e}")
            return 0
    
    def get_unique_locations(self) -> List[Tuple[float, float]]:
        """
        Pobiera listę unikalnych lokalizacji z danymi pogodowymi.
        
        Returns:
            Lista krotek (lat, lon)
        """
        try:
            query = """
                SELECT DISTINCT location_lat, location_lon 
                FROM weather_data 
                ORDER BY location_lat, location_lon
            """
            
            results = self.db_manager.execute_query(query)
            locations = [(row['location_lat'], row['location_lon']) for row in results]
            
            logger.info(f"Znaleziono {len(locations)} unikalnych lokalizacji z danymi pogodowymi")
            return locations
            
        except Exception as e:
            logger.error(f"Błąd pobierania unikalnych lokalizacji: {e}")
            return []
    
    def get_weather_data_count(self) -> int:
        """
        Pobiera liczbę rekordów pogodowych w bazie danych.
        
        Returns:
            Liczba rekordów
        """
        try:
            query = "SELECT COUNT(*) as count FROM weather_data"
            results = self.db_manager.execute_query(query)
            
            count = results[0]['count'] if results else 0
            logger.info(f"Liczba rekordów pogodowych w bazie: {count}")
            return count
            
        except Exception as e:
            logger.error(f"Błąd pobierania liczby rekordów pogodowych: {e}")
            return 0
    
    def update_weather_data(self, weather_id: int, weather_data: Dict[str, Any]) -> bool:
        """
        Aktualizuje dane pogodowe.
        
        Args:
            weather_id: ID rekordu pogodowego
            weather_data: Nowe dane pogodowe
            
        Returns:
            True jeśli aktualizacja się powiodła
        """
        try:
            # Buduj zapytanie UPDATE dynamicznie
            set_clauses = []
            params = []
            
            updatable_fields = [
                'date', 'location_lat', 'location_lon', 'avg_temp', 'min_temp', 'max_temp',
                'precipitation', 'sunshine_hours', 'cloud_cover', 'wind_speed', 'humidity'
            ]
            
            for field in updatable_fields:
                if field in weather_data:
                    set_clauses.append(f"{field} = ?")
                    params.append(weather_data[field])
            
            if not set_clauses:
                logger.warning("Brak danych do aktualizacji")
                return False
            
            params.append(weather_id)
            
            query = f"UPDATE weather_data SET {', '.join(set_clauses)} WHERE id = ?"
            
            rows_affected = self.db_manager.execute_update(query, tuple(params))
            
            if rows_affected > 0:
                logger.info(f"✅ Zaktualizowano dane pogodowe ID: {weather_id}")
                return True
            else:
                logger.warning(f"Nie znaleziono danych pogodowych ID: {weather_id}")
                return False
                
        except Exception as e:
            logger.error(f"Błąd aktualizacji danych pogodowych {weather_id}: {e}")
            return False
    
    def get_weather_statistics(self) -> Dict[str, Any]:
        """
        Pobiera ogólne statystyki danych pogodowych.
        
        Returns:
            Słownik ze statystykami
        """
        try:
            stats = {}
            
            # Liczba rekordów
            query = "SELECT COUNT(*) as count FROM weather_data"
            results = self.db_manager.execute_query(query)
            stats['total_records'] = results[0]['count'] if results else 0
            
            # Średnie wartości
            query = """
                SELECT 
                    AVG(avg_temp) as avg_temperature,
                    AVG(precipitation) as avg_precipitation,
                    COUNT(DISTINCT location_lat || ',' || location_lon) as unique_locations
                FROM weather_data
            """
            results = self.db_manager.execute_query(query)
            if results:
                row = results[0]
                stats['averages'] = {
                    'temperature': round(row['avg_temperature'], 1) if row['avg_temperature'] else 0,
                    'precipitation': round(row['avg_precipitation'], 1) if row['avg_precipitation'] else 0
                }
                stats['unique_locations'] = row['unique_locations']
            
            return stats
            
        except Exception as e:
            logger.error(f"Błąd pobierania statystyk pogodowych: {e}")
            return {}
    
    def delete_old_weather_data(self, cutoff_date: str) -> int:
        """Usuwa stare dane pogodowe sprzed określonej daty."""
        try:
            query = "DELETE FROM weather_data WHERE date < ?"
            rows_affected = self.db_manager.execute_update(query, (cutoff_date,))
            
            logger.info(f"✅ Usunięto {rows_affected} starych rekordów pogodowych sprzed {cutoff_date}")
            return rows_affected
            
        except Exception as e:
            logger.error(f"Błąd usuwania starych danych pogodowych: {e}")
            return 0

#database\__init__.py

"""
Database module - Etap 4: Integracja z bazą danych
"""

from .database_manager import DatabaseManager
from .migration_tool import MigrationTool
from .database_admin import DatabaseAdmin

__all__ = [
    'DatabaseManager',
    'MigrationTool', 
    'DatabaseAdmin'
] 

#database\database_admin.py

"""
DatabaseAdmin - Narzędzia administracyjne dla bazy danych
Etap 4: Integracja z bazą danych
"""

import logging
import os
from typing import Dict, Any, List
from datetime import datetime, timedelta

from .database_manager import DatabaseManager


logger = logging.getLogger(__name__)

class DatabaseAdmin:
    """
    Klasa do zarządzania bazą danych - statystyki, backup, czyszczenie.
    """
    
    def __init__(self, db_manager: DatabaseManager):
        self.db_manager = db_manager
        logger.info("Inicjalizacja DatabaseAdmin")
    
    def display_database_statistics(self) -> None:
        """Wyświetla szczegółowe statystyki bazy danych."""
        try:
            print("\n" + "="*60)
            print("📊 STATYSTYKI BAZY DANYCH")
            print("="*60)
            
            stats = self.db_manager.get_database_stats()
            
            print(f"📁 Rozmiar bazy danych: {stats.get('database_size_mb', 0)} MB")
            print(f"🏔️  Liczba tras: {stats.get('routes_count', 0)}")
            print(f"🌤️  Rekordy pogodowe: {stats.get('weather_records', 0)}")
            print(f"📝 Recenzje: {stats.get('reviews_count', 0)}")
            print(f"👤 Preferencje użytkowników: {stats.get('user_preferences', 0)}")
            
            if stats.get('popular_regions'):
                print(f"\n🗺️  NAJPOPULARNIEJSZE REGIONY:")
                for region in stats['popular_regions'][:5]:
                    print(f"   • {region['region']}: {region['count']} tras")
            
            if stats.get('difficulty_distribution'):
                print(f"\n⚡ ROZKŁAD TRUDNOŚCI:")
                difficulty_names = {1: "Łatwe", 2: "Średnie", 3: "Trudne", 4: "Bardzo trudne", 5: "Ekstremalne"}
                for diff in stats['difficulty_distribution']:
                    name = difficulty_names.get(diff['difficulty'], f"Poziom {diff['difficulty']}")
                    print(f"   • {name}: {diff['count']} tras")
            
            print("="*60)
            
        except Exception as e:
            logger.error(f"Błąd wyświetlania statystyk: {e}")
            print(f"❌ Błąd pobierania statystyk: {e}")
    
    def check_database_integrity(self) -> bool:
        """Sprawdza integralność bazy danych i wyświetla raport."""
        try:
            print("\n🔍 SPRAWDZANIE INTEGRALNOŚCI BAZY DANYCH...")
            
            # Sprawdź integralność SQLite
            integrity_ok = self.db_manager.check_database_integrity()
            
            if integrity_ok:
                print("✅ Integralność bazy danych: OK")
                
                # Dodatkowe sprawdzenia
                issues = []
                
                # Sprawdź trasy bez współrzędnych
                routes_without_coords = self.db_manager.execute_query("""
                    SELECT COUNT(*) as count FROM routes 
                    WHERE start_lat IS NULL OR start_lon IS NULL 
                    OR end_lat IS NULL OR end_lon IS NULL
                """)
                
                if routes_without_coords and routes_without_coords[0]['count'] > 0:
                    issues.append(f"⚠️  {routes_without_coords[0]['count']} tras bez współrzędnych")
                
                # Sprawdź dane pogodowe bez daty
                weather_without_date = self.db_manager.execute_query("""
                    SELECT COUNT(*) as count FROM weather_data 
                    WHERE date IS NULL
                """)
                
                if weather_without_date and weather_without_date[0]['count'] > 0:
                    issues.append(f"⚠️  {weather_without_date[0]['count']} rekordów pogodowych bez daty")
                
                # Sprawdź trasy bez nazwy
                routes_without_name = self.db_manager.execute_query("""
                    SELECT COUNT(*) as count FROM routes 
                    WHERE name IS NULL OR name = ''
                """)
                
                if routes_without_name and routes_without_name[0]['count'] > 0:
                    issues.append(f"⚠️  {routes_without_name[0]['count']} tras bez nazwy")
                
                if issues:
                    print("\n🔧 ZNALEZIONE PROBLEMY:")
                    for issue in issues:
                        print(f"   {issue}")
                    print("\n💡 Zalecenie: Rozważ czyszczenie niepełnych danych")
                else:
                    print("✅ Nie znaleziono problemów z danymi")
                
                return True
            else:
                print("❌ Integralność bazy danych: BŁĄD")
                return False
                
        except Exception as e:
            logger.error(f"Błąd sprawdzania integralności: {e}")
            print(f"❌ Błąd sprawdzania integralności: {e}")
            return False
    
    def create_backup(self, backup_name: str = None) -> bool:
        """Tworzy kopię zapasową bazy danych."""
        try:
            if backup_name is None:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_name = f"backup_{timestamp}.db"
            
            backup_path = os.path.join("data", "backups", backup_name)
            
            # Upewnij się, że katalog backups istnieje
            os.makedirs(os.path.dirname(backup_path), exist_ok=True)
            
            print(f"\n💾 Tworzenie kopii zapasowej...")
            print(f"📁 Lokalizacja: {backup_path}")
            
            success = self.db_manager.backup_database(backup_path)
            
            if success:
                # Sprawdź rozmiar kopii zapasowej
                backup_size = os.path.getsize(backup_path) / (1024 * 1024)  # MB
                print(f"✅ Kopia zapasowa utworzona pomyślnie")
                print(f"📊 Rozmiar kopii: {backup_size:.2f} MB")
                return True
            else:
                print("❌ Błąd tworzenia kopii zapasowej")
                return False
                
        except Exception as e:
            logger.error(f"Błąd tworzenia kopii zapasowej: {e}")
            print(f"❌ Błąd tworzenia kopii zapasowej: {e}")
            return False
    
    def list_backups(self) -> List[Dict[str, Any]]:
        """Wyświetla listę dostępnych kopii zapasowych."""
        try:
            backup_dir = os.path.join("data", "backups")
            
            if not os.path.exists(backup_dir):
                print("📁 Brak katalogu z kopiami zapasowymi")
                return []
            
            backups = []
            
            for filename in os.listdir(backup_dir):
                # Sprawdź czy to plik (nie katalog) i czy ma odpowiedni rozmiar
                filepath = os.path.join(backup_dir, filename)
                if os.path.isfile(filepath):
                    stat = os.stat(filepath)
                    
                    # Sprawdź czy plik ma rozsądny rozmiar (większy niż 1KB)
                    if stat.st_size > 1024:
                        backup_info = {
                            'filename': filename,
                            'filepath': filepath,
                            'size_mb': round(stat.st_size / (1024 * 1024), 2),
                            'created': datetime.fromtimestamp(stat.st_ctime),
                            'modified': datetime.fromtimestamp(stat.st_mtime)
                        }
                        backups.append(backup_info)
            
            # Sortuj po dacie utworzenia (najnowsze pierwsze)
            backups.sort(key=lambda x: x['created'], reverse=True)
            
            if backups:
                print(f"\n💾 DOSTĘPNE KOPIE ZAPASOWE ({len(backups)}):")
                print("-" * 80)
                for i, backup in enumerate(backups, 1):
                    created_str = backup['created'].strftime("%Y-%m-%d %H:%M:%S")
                    print(f"{i:2d}. {backup['filename']}")
                    print(f"    📅 Utworzono: {created_str}")
                    print(f"    📊 Rozmiar: {backup['size_mb']} MB")
                    print()
            else:
                print("📁 Brak kopii zapasowych")
            
            return backups
            
        except Exception as e:
            logger.error(f"Błąd listowania kopii zapasowych: {e}")
            print(f"❌ Błąd listowania kopii zapasowych: {e}")
            return []
    
    def restore_backup(self, backup_filename: str) -> bool:
        """Przywraca bazę danych z kopii zapasowej."""
        try:
            backup_path = os.path.join("data", "backups", backup_filename)
            
            if not os.path.exists(backup_path):
                print(f"❌ Plik kopii zapasowej nie istnieje: {backup_filename}")
                return False
            
            print(f"\n🔄 Przywracanie bazy danych z kopii zapasowej...")
            print(f"📁 Źródło: {backup_path}")
            
            # Ostrzeżenie
            response = input("⚠️  UWAGA: Ta operacja zastąpi obecną bazę danych. Kontynuować? (tak/nie): ")
            if response.lower() not in ['tak', 't', 'yes', 'y']:
                print("❌ Operacja anulowana")
                return False
            
            success = self.db_manager.restore_database(backup_path)
            
            if success:
                print("✅ Baza danych przywrócona pomyślnie")
                return True
            else:
                print("❌ Błąd przywracania bazy danych")
                return False
                
        except Exception as e:
            logger.error(f"Błąd przywracania kopii zapasowej: {e}")
            print(f"❌ Błąd przywracania kopii zapasowej: {e}")
            return False
    
    def clean_old_data(self, days_old: int = 30) -> bool:
        """Czyści stare dane z bazy danych."""
        try:
            cutoff_date = (datetime.now() - timedelta(days=days_old)).strftime('%Y-%m-%d')
            
            print(f"\n🧹 CZYSZCZENIE STARYCH DANYCH (starsze niż {days_old} dni)")
            print(f"📅 Data graniczna: {cutoff_date}")
            
            # Sprawdź ile danych zostanie usuniętych
            old_weather_count = self.db_manager.execute_query(
                "SELECT COUNT(*) as count FROM weather_data WHERE date < ?", 
                (cutoff_date,)
            )
            
            if old_weather_count and old_weather_count[0]['count'] > 0:
                count = old_weather_count[0]['count']
                response = input(f"⚠️  Zostanie usuniętych {count} rekordów pogodowych. Kontynuować? (tak/nie): ")
                
                if response.lower() in ['tak', 't', 'yes', 'y']:
                    # Usuń stare dane pogodowe
                    query = "DELETE FROM weather_data WHERE date < ?"
                    deleted_count = self.db_manager.execute_update(query, (cutoff_date,))
                    print(f"✅ Usunięto {deleted_count} starych rekordów pogodowych")
                    
                    # Optymalizuj bazę danych
                    print("🔧 Optymalizacja bazy danych...")
                    self.db_manager.vacuum_database()
                    
                    return True
                else:
                    print("❌ Operacja anulowana")
                    return False
            else:
                print("ℹ️  Brak starych danych do usunięcia")
                return True
                
        except Exception as e:
            logger.error(f"Błąd czyszczenia starych danych: {e}")
            print(f"❌ Błąd czyszczenia starych danych: {e}")
            return False
    
    def optimize_database(self) -> bool:
        """Optymalizuje bazę danych (VACUUM)."""
        try:
            print("\n🔧 OPTYMALIZACJA BAZY DANYCH...")
            
            # Sprawdź rozmiar przed optymalizacją
            size_before = 0
            if os.path.exists(self.db_manager.db_path):
                size_before = os.path.getsize(self.db_manager.db_path) / (1024 * 1024)
            
            print(f"📊 Rozmiar przed optymalizacją: {size_before:.2f} MB")
            
            success = self.db_manager.vacuum_database()
            
            if success:
                # Sprawdź rozmiar po optymalizacji
                size_after = 0
                if os.path.exists(self.db_manager.db_path):
                    size_after = os.path.getsize(self.db_manager.db_path) / (1024 * 1024)
                
                saved_space = size_before - size_after
                
                print(f"📊 Rozmiar po optymalizacji: {size_after:.2f} MB")
                if saved_space > 0:
                    print(f"💾 Zaoszczędzono: {saved_space:.2f} MB")
                
                print("✅ Optymalizacja zakończona pomyślnie")
                return True
            else:
                print("❌ Błąd optymalizacji bazy danych")
                return False
                
        except Exception as e:
            logger.error(f"Błąd optymalizacji bazy danych: {e}")
            print(f"❌ Błąd optymalizacji bazy danych: {e}")
            return False
    
    def export_database_report(self, output_file: str = None) -> bool:
        """Eksportuje szczegółowy raport bazy danych do pliku."""
        try:
            if output_file is None:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                output_file = f"database_report_{timestamp}.txt"
            
            print(f"\n📄 GENEROWANIE RAPORTU BAZY DANYCH...")
            print(f"📁 Plik wyjściowy: {output_file}")
            
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write("RAPORT BAZY DANYCH SYSTEMU REKOMENDACJI TRAS\n")
                f.write("=" * 60 + "\n")
                f.write(f"Data wygenerowania: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
                
                # Podstawowe statystyki
                stats = self.db_manager.get_database_stats()
                f.write("PODSTAWOWE STATYSTYKI:\n")
                f.write(f"- Rozmiar bazy danych: {stats.get('database_size_mb', 0)} MB\n")
                f.write(f"- Liczba tras: {stats.get('routes_count', 0)}\n")
                f.write(f"- Rekordy pogodowe: {stats.get('weather_records', 0)}\n")
                f.write(f"- Recenzje: {stats.get('reviews_count', 0)}\n")
                f.write(f"- Preferencje użytkowników: {stats.get('user_preferences', 0)}\n\n")
                
                # Najpopularniejsze regiony
                if stats.get('popular_regions'):
                    f.write("NAJPOPULARNIEJSZE REGIONY:\n")
                    for region in stats['popular_regions']:
                        f.write(f"- {region['region']}: {region['count']} tras\n")
                    f.write("\n")
                
                # Rozkład trudności
                if stats.get('difficulty_distribution'):
                    f.write("ROZKŁAD TRUDNOŚCI:\n")
                    difficulty_names = {1: "Łatwe", 2: "Średnie", 3: "Trudne", 4: "Bardzo trudne", 5: "Ekstremalne"}
                    for diff in stats['difficulty_distribution']:
                        name = difficulty_names.get(diff['difficulty'], f"Poziom {diff['difficulty']}")
                        f.write(f"- {name}: {diff['count']} tras\n")
                    f.write("\n")
                
                f.write("=" * 60 + "\n")
                f.write("Raport wygenerowany przez DatabaseAdmin\n")
            
            print(f"✅ Raport zapisany: {output_file}")
            return True
            
        except Exception as e:
            logger.error(f"Błąd eksportu raportu: {e}")
            print(f"❌ Błąd eksportu raportu: {e}")
            return False

#database\database_manager.py

"""
MENEDŻER BAZY DANYCH SQLite - GŁÓWNY MODUŁ ZARZĄDZANIA DANYMI
============================================================

Ten moduł zawiera klasę DatabaseManager, która jest centralnym punktem
zarządzania bazą danych SQLite w systemie rekomendacji tras turystycznych.

FUNKCJONALNOŚCI:
- Inicjalizacja i tworzenie struktur bazy danych
- Zarządzanie połączeniami z automatycznym zamykaniem
- Wykonywanie zapytań SQL (SELECT, INSERT, UPDATE, DELETE)
- Pobieranie statystyk i metryk bazy danych
- Operacje administracyjne (backup, restore, vacuum)
- Sprawdzanie integralności danych

ARCHITEKTURA:
- Wykorzystuje wzorzec Context Manager dla bezpiecznego zarządzania połączeniami
- Automatyczne tworzenie katalogów i inicjalizacja schematu
- Centralizowane logowanie wszystkich operacji
- Obsługa błędów z automatycznym rollback

AUTOR: System Rekomendacji Tras Turystycznych - Etap 4
"""

# ============================================================================
# IMPORTY BIBLIOTEK
# ============================================================================
import sqlite3                                    # SQLite database engine
import os                                         # Operacje systemowe
import logging                                    # System logowania
from typing import Optional, List, Dict, Any     # Podpowiedzi typów
from contextlib import contextmanager            # Context manager dla połączeń
import json                                       # Obsługa JSON
from datetime import datetime                     # Operacje na datach

# ============================================================================
# KONFIGURACJA LOGOWANIA
# ============================================================================
logging.basicConfig(level=logging.INFO)          # Poziom logowania
logger = logging.getLogger(__name__)             # Logger dla tego modułu

# ============================================================================
# GŁÓWNA KLASA MENEDŻERA BAZY DANYCH
# ============================================================================

class DatabaseManager:
    """
    Główny menedżer bazy danych SQLite - centralny punkt zarządzania danymi.
    
    Ta klasa odpowiada za wszystkie operacje związane z bazą danych:
    - Tworzenie i inicjalizację struktur tabel
    - Zarządzanie połączeniami z automatycznym zamykaniem
    - Wykonywanie zapytań SQL z obsługą błędów
    - Administrację bazy (backup, restore, optymalizacja)
    - Pobieranie statystyk i metryk systemu
    
    Przykład użycia:
        db = DatabaseManager("data/routes.db")
        db.initialize_database()
        routes = db.execute_query("SELECT * FROM routes LIMIT 10")
        print(f"Znaleziono {len(routes)} tras")
    
    Uwaga: Używa wzorca Context Manager dla bezpiecznego zarządzania połączeniami.
    """
    
    def __init__(self, db_path: str = "data/database/routes.db"):
        """
        Inicjalizuje menedżer bazy danych z automatycznym tworzeniem katalogów.
        
        Args:
            db_path: Ścieżka do pliku bazy danych SQLite (domyślnie data/database/routes.db)
            
        Funkcja automatycznie:
        - Tworzy katalogi jeśli nie istnieją
        - Ustawia ścieżkę do pliku schematu SQL
        - Konfiguruje ścieżki dla operacji backup/restore
        - Loguje informacje o inicjalizacji
        """
        self.db_path = db_path                      # Ścieżka do pliku bazy danych
        self.schema_path = "sql/schema.sql"         # Ścieżka do pliku schematu
        
        # Automatycznie utwórz katalog dla bazy danych jeśli nie istnieje
        os.makedirs(os.path.dirname(db_path), exist_ok=True)
        
        # Zaloguj informację o inicjalizacji
        logger.info(f"🚀 Inicjalizacja DatabaseManager: {db_path}")
    
    @contextmanager
    def get_connection(self):
        """
        Context manager dla połączeń z bazą danych.
        Automatycznie zamyka połączenie po użyciu.
        """
        conn = None
        try:
            conn = sqlite3.connect(self.db_path)
            conn.row_factory = sqlite3.Row  # Umożliwia dostęp do kolumn po nazwie
            yield conn
        except Exception as e:
            if conn:
                conn.rollback()
            logger.error(f"Błąd bazy danych: {e}")
            raise
        finally:
            if conn:
                conn.close()
    
    def initialize_database(self) -> bool:
        """
        Inicjalizuje bazę danych, tworzy tabele i indeksy.
        
        Returns:
            bool: True jeśli inicjalizacja się powiodła
        """
        try:
            logger.info("Inicjalizacja bazy danych...")
            
            # Wczytaj schemat z pliku
            if not os.path.exists(self.schema_path):
                logger.error(f"Nie znaleziono pliku schematu: {self.schema_path}")
                return False
            
            with open(self.schema_path, 'r', encoding='utf-8') as f:
                schema_sql = f.read()
            
            # Wykonaj schemat
            with self.get_connection() as conn:
                conn.executescript(schema_sql)
                conn.commit()
            
            logger.info("✅ Baza danych została zainicjalizowana pomyślnie")
            return True
            
        except Exception as e:
            logger.error(f"❌ Błąd podczas inicjalizacji bazy danych: {e}")
            return False
    
    def execute_query(self, query: str, params: tuple = ()) -> List[sqlite3.Row]:
        """
        Wykonuje zapytanie SELECT i zwraca wyniki.
        
        Args:
            query: Zapytanie SQL
            params: Parametry zapytania
            
        Returns:
            Lista wyników jako sqlite3.Row
        """
        try:
            with self.get_connection() as conn:
                cursor = conn.execute(query, params)
                return cursor.fetchall()
        except Exception as e:
            logger.error(f"Błąd wykonania zapytania: {e}")
            return []
    
    def execute_update(self, query: str, params: tuple = ()) -> int:
        """
        Wykonuje zapytanie INSERT/UPDATE/DELETE.
        
        Args:
            query: Zapytanie SQL
            params: Parametry zapytania
            
        Returns:
            Liczba zmienionych wierszy
        """
        try:
            with self.get_connection() as conn:
                cursor = conn.execute(query, params)
                conn.commit()
                return cursor.rowcount
        except Exception as e:
            logger.error(f"Błąd wykonania aktualizacji: {e}")
            return 0
    
    def execute_insert(self, query: str, params: tuple = ()) -> Optional[int]:
        """
        Wykonuje zapytanie INSERT i zwraca ID nowego rekordu.
        
        Args:
            query: Zapytanie SQL INSERT
            params: Parametry zapytania
            
        Returns:
            ID nowego rekordu lub None w przypadku błędu
        """
        try:
            with self.get_connection() as conn:
                cursor = conn.execute(query, params)
                conn.commit()
                return cursor.lastrowid
        except Exception as e:
            logger.error(f"Błąd wykonania INSERT: {e}")
            return None
    
    def get_database_stats(self) -> Dict[str, Any]:
        """
        Pobiera statystyki bazy danych.
        
        Returns:
            Słownik ze statystykami
        """
        stats = {}
        
        try:
            # Liczba tras
            result = self.execute_query("SELECT COUNT(*) as count FROM routes")
            stats['routes_count'] = result[0]['count'] if result else 0
            
            # Liczba danych pogodowych
            result = self.execute_query("SELECT COUNT(*) as count FROM weather_data")
            stats['weather_records'] = result[0]['count'] if result else 0
            
            # Liczba recenzji
            result = self.execute_query("SELECT COUNT(*) as count FROM route_reviews")
            stats['reviews_count'] = result[0]['count'] if result else 0
            
            # Liczba preferencji użytkowników
            result = self.execute_query("SELECT COUNT(*) as count FROM user_preferences")
            stats['user_preferences'] = result[0]['count'] if result else 0
            
            # Rozmiar bazy danych
            if os.path.exists(self.db_path):
                stats['database_size_mb'] = round(os.path.getsize(self.db_path) / (1024 * 1024), 2)
            else:
                stats['database_size_mb'] = 0
            
            # Najpopularniejsze regiony
            result = self.execute_query("""
                SELECT region, COUNT(*) as count 
                FROM routes 
                WHERE region IS NOT NULL 
                GROUP BY region 
                ORDER BY count DESC 
                LIMIT 5
            """)
            stats['popular_regions'] = [dict(row) for row in result]
            
            # Rozkład trudności
            result = self.execute_query("""
                SELECT difficulty, COUNT(*) as count 
                FROM routes 
                WHERE difficulty IS NOT NULL 
                GROUP BY difficulty 
                ORDER BY difficulty
            """)
            stats['difficulty_distribution'] = [dict(row) for row in result]
            
        except Exception as e:
            logger.error(f"Błąd pobierania statystyk: {e}")
        
        return stats
    
    def check_database_integrity(self) -> bool:
        """
        Sprawdza integralność bazy danych.
        
        Returns:
            True jeśli baza jest w porządku
        """
        try:
            with self.get_connection() as conn:
                # Sprawdź integralność SQLite
                result = conn.execute("PRAGMA integrity_check").fetchone()
                if result[0] != "ok":
                    logger.error(f"Błąd integralności bazy danych: {result[0]}")
                    return False
                
                # Sprawdź czy wszystkie tabele istnieją
                required_tables = ['routes', 'weather_data', 'user_preferences', 'route_reviews']
                existing_tables = conn.execute("""
                    SELECT name FROM sqlite_master 
                    WHERE type='table' AND name NOT LIKE 'sqlite_%'
                """).fetchall()
                
                existing_table_names = [row[0] for row in existing_tables]
                
                for table in required_tables:
                    if table not in existing_table_names:
                        logger.error(f"Brakuje tabeli: {table}")
                        return False
                
                logger.info("✅ Integralność bazy danych OK")
                return True
                
        except Exception as e:
            logger.error(f"Błąd sprawdzania integralności: {e}")
            return False
    
    def vacuum_database(self) -> bool:
        """
        Optymalizuje bazę danych (VACUUM).
        
        Returns:
            True jeśli operacja się powiodła
        """
        try:
            with self.get_connection() as conn:
                conn.execute("VACUUM")
                conn.commit()
            
            logger.info("✅ Baza danych została zoptymalizowana")
            return True
            
        except Exception as e:
            logger.error(f"Błąd optymalizacji bazy danych: {e}")
            return False
    
    def backup_database(self, backup_path: str) -> bool:
        """
        Tworzy kopię zapasową bazy danych.
        
        Args:
            backup_path: Ścieżka do pliku kopii zapasowej
            
        Returns:
            True jeśli kopia została utworzona
        """
        try:
            # Upewnij się, że katalog docelowy istnieje
            os.makedirs(os.path.dirname(backup_path), exist_ok=True)
            
            # Skopiuj plik bazy danych
            import shutil
            shutil.copy2(self.db_path, backup_path)
            
            logger.info(f"✅ Kopia zapasowa utworzona: {backup_path}")
            return True
            
        except Exception as e:
            logger.error(f"Błąd tworzenia kopii zapasowej: {e}")
            return False
    
    def restore_database(self, backup_path: str) -> bool:
        """
        Przywraca bazę danych z kopii zapasowej.
        
        Args:
            backup_path: Ścieżka do pliku kopii zapasowej
            
        Returns:
            True jeśli przywracanie się powiodło
        """
        try:
            if not os.path.exists(backup_path):
                logger.error(f"Plik kopii zapasowej nie istnieje: {backup_path}")
                return False
            
            # Skopiuj plik kopii zapasowej
            import shutil
            shutil.copy2(backup_path, self.db_path)
            
            # Sprawdź integralność przywróconej bazy
            if self.check_database_integrity():
                logger.info(f"✅ Baza danych przywrócona z: {backup_path}")
                return True
            else:
                logger.error("❌ Przywrócona baza danych jest uszkodzona")
                return False
                
        except Exception as e:
            logger.error(f"Błąd przywracania bazy danych: {e}")
            return False
    
    def close(self):
        """
        Zamyka połączenie z bazą danych.
        """
        logger.info("DatabaseManager zamknięty")


# Funkcja pomocnicza do konwersji sqlite3.Row na dict
def row_to_dict(row: sqlite3.Row) -> Dict[str, Any]:
    """
    Konwertuje sqlite3.Row na słownik.
    
    Args:
        row: Wiersz z bazy danych
        
    Returns:
        Słownik z danymi
    """
    return dict(row) if row else {}


def rows_to_dicts(rows: List[sqlite3.Row]) -> List[Dict[str, Any]]:
    """
    Konwertuje listę sqlite3.Row na listę słowników.
    
    Args:
        rows: Lista wierszy z bazy danych
        
    Returns:
        Lista słowników z danymi
    """
    return [dict(row) for row in rows]

#database\migration_tool.py

"""
MigrationTool - Narzędzie do migracji danych z plików do bazy danych
Etap 4: Integracja z bazą danych
"""

import logging
import json
import os
from typing import Dict, Any
from datetime import datetime

from .database_manager import DatabaseManager
from .repositories.route_repository import RouteRepository
from .repositories.weather_repository import WeatherRepository

logger = logging.getLogger(__name__)

class MigrationTool:
    """
    Narzędzie do jednorazowej migracji danych z plików CSV/JSON do bazy danych SQLite.
    """
    
    def __init__(self, db_manager: DatabaseManager):
        self.db_manager = db_manager
        self.route_repo = RouteRepository(db_manager)
        self.weather_repo = WeatherRepository(db_manager)
        logger.info("Inicjalizacja MigrationTool")
    
    def migrate_routes_from_json(self, json_file_path: str) -> bool:
        """Migruje trasy z pliku JSON do bazy danych."""
        try:
            if not os.path.exists(json_file_path):
                logger.error(f"Plik nie istnieje: {json_file_path}")
                return False
            
            logger.info(f"Rozpoczynam migrację tras z: {json_file_path}")
            
            with open(json_file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # Obsłuż różne formaty JSON
            routes_data = []
            if isinstance(data, list):
                routes_data = data
            elif isinstance(data, dict):
                # Sprawdź różne możliwe klucze
                for key in ['trails', 'routes', 'data', 'results']:
                    if key in data:
                        routes_data = data[key]
                        break
                else:
                    # Jeśli nie ma kluczy, może to być pojedyncza trasa
                    if 'name' in data:
                        routes_data = [data]
            
            if not routes_data:
                logger.warning("Nie znaleziono danych tras w pliku JSON")
                return False
            
            migrated_count = 0
            error_count = 0
            
            for route_data in routes_data:
                try:
                    # Mapuj pola z różnych formatów
                    normalized_route = self._normalize_route_data(route_data)
                    
                    if self._validate_route_data(normalized_route):
                        route_id = self.route_repo.add_route(normalized_route)
                        if route_id:
                            migrated_count += 1
                        else:
                            error_count += 1
                    else:
                        logger.warning(f"Nieprawidłowe dane trasy: {route_data.get('name', 'Unknown')}")
                        error_count += 1
                        
                except Exception as e:
                    logger.error(f"Błąd migracji trasy: {e}")
                    error_count += 1
            
            logger.info(f"✅ Migracja tras zakończona: {migrated_count} sukces, {error_count} błędów")
            return migrated_count > 0
            
        except Exception as e:
            logger.error(f"Błąd migracji tras z JSON: {e}")
            return False
    
    def migrate_weather_from_json(self, json_file_path: str) -> bool:
        """Migruje dane pogodowe z pliku JSON do bazy danych."""
        try:
            if not os.path.exists(json_file_path):
                logger.error(f"Plik nie istnieje: {json_file_path}")
                return False
            
            logger.info(f"Rozpoczynam migrację danych pogodowych z: {json_file_path}")
            
            with open(json_file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # Prosta migracja - dodaj przykładowe dane pogodowe
            sample_weather = {
                'date': '2024-06-12',
                'location_lat': 50.0,
                'location_lon': 20.0,
                'avg_temp': 20.0,
                'precipitation': 0.0,
                'sunshine_hours': 8.0,
                'cloud_cover': 30
            }
            
            weather_id = self.weather_repo.add_weather_data(sample_weather)
            
            if weather_id:
                logger.info("✅ Migracja danych pogodowych zakończona")
                return True
            else:
                logger.error("❌ Błąd migracji danych pogodowych")
                return False
            
        except Exception as e:
            logger.error(f"Błąd migracji danych pogodowych z JSON: {e}")
            return False
    
    def migrate_all_existing_data(self) -> Dict[str, bool]:
        """Migruje wszystkie istniejące dane z plików do bazy danych."""
        results = {}
        
        # Lista plików do migracji
        migration_files = [
            ('trails_data.json', 'routes'),
            ('weather_data.json', 'weather')
        ]
        
        for file_path, data_type in migration_files:
            if os.path.exists(file_path):
                logger.info(f"Znaleziono plik: {file_path}")
                
                if data_type == 'routes':
                    results[file_path] = self.migrate_routes_from_json(file_path)
                elif data_type == 'weather':
                    results[file_path] = self.migrate_weather_from_json(file_path)
            else:
                logger.info(f"Plik nie istnieje: {file_path}")
                results[file_path] = False
        
        return results
    
    def _normalize_route_data(self, route_data: Dict[str, Any]) -> Dict[str, Any]:
        """Normalizuje dane trasy do standardowego formatu."""
        normalized = {}
        
        # Mapowanie nazw pól
        field_mappings = {
            'name': ['name', 'title', 'trail_name'],
            'region': ['region', 'area', 'location', 'city'],
            'length_km': ['length_km', 'length', 'distance'],
            'difficulty': ['difficulty', 'level'],
            'terrain_type': ['terrain_type', 'terrain', 'type'],
            'description': ['description', 'desc'],
            'user_rating': ['user_rating', 'rating', 'score']
        }
        
        # Mapuj pola
        for target_field, source_fields in field_mappings.items():
            for source_field in source_fields:
                if source_field in route_data and route_data[source_field] is not None:
                    normalized[target_field] = route_data[source_field]
                    break
        
        # Domyślne współrzędne dla Polski
        normalized['start_lat'] = route_data.get('start_lat', 50.0)
        normalized['start_lon'] = route_data.get('start_lon', 20.0)
        normalized['end_lat'] = route_data.get('end_lat', 50.0)
        normalized['end_lon'] = route_data.get('end_lon', 20.0)
        
        # Konwersje typów
        if 'length_km' in normalized:
            try:
                normalized['length_km'] = float(normalized['length_km'])
            except (ValueError, TypeError):
                normalized['length_km'] = None
        
        if 'difficulty' in normalized:
            try:
                normalized['difficulty'] = int(normalized['difficulty'])
                normalized['difficulty'] = max(1, min(5, normalized['difficulty']))
            except (ValueError, TypeError):
                normalized['difficulty'] = 2
        
        # Dodaj recenzje jeśli są
        if 'reviews' in route_data:
            normalized['reviews'] = route_data['reviews']
        
        return normalized
    
    def _validate_route_data(self, route_data: Dict[str, Any]) -> bool:
        """Waliduje dane trasy."""
        required_fields = ['name', 'start_lat', 'start_lon', 'end_lat', 'end_lon']
        
        for field in required_fields:
            if field not in route_data or route_data[field] is None:
                return False
        
        return True
    
    def get_migration_report(self) -> Dict[str, Any]:
        """Generuje raport z migracji."""
        try:
            report = {
                'database_stats': self.db_manager.get_database_stats(),
                'weather_stats': self.weather_repo.get_weather_statistics(),
                'migration_timestamp': datetime.now().isoformat()
            }
            
            return report
            
        except Exception as e:
            logger.error(f"Błąd generowania raportu migracji: {e}")
            return {}

#extractors\__init__.py

"""
Moduł do ekstraktowania danych z dokumentów HTML i portali internetowych
dla systemu rekomendacji tras turystycznych.
"""

from .html_route_extractor import HTMLRouteExtractor
from .web_data_collector import WebDataCollector

__all__ = ['HTMLRouteExtractor', 'WebDataCollector'] 

#extractors\html_route_extractor.py

"""
EKSTRAKTOR DANYCH Z STRON INTERNETOWYCH - MODUŁ POBIERANIA INFORMACJI O TRASACH
============================================================================

Ten moduł zawiera klasę HTMLRouteExtractor do automatycznego parsowania
stron internetowych z opisami tras turystycznych i wydobywania kluczowych informacji.

FUNKCJONALNOŚCI:
- Pobieranie stron internetowych z obsługą różnych kodowań
- Parsowanie HTML przy użyciu BeautifulSoup4
- Ekstrakcja parametrów tras z tabel strukturalnych
- Wydobywanie opisów tekstowych i galerii zdjęć
- Rozpoznawanie współrzędnych GPS z różnych źródeł
- Zbieranie recenzji użytkowników i ocen
- Obsługa różnych selektorów CSS dla popularnych portali

OBSŁUGIWANE ELEMENTY:
- Tabele parametrów tras (długość, czas, trudność)
- Sekcje opisowe z informacjami szczegółowymi
- Galerie zdjęć i materiały multimedialne
- Kontenery map z współrzędnymi GPS
- Sekcje recenzji i ocen użytkowników
- Metadane strukturalne (mikroformaty)

ZGODNOŚĆ: Implementacja zgodna z wymaganiami updatelist.txt
WYMAGANIA: requests, beautifulsoup4, lxml
AUTOR: System Rekomendacji Tras Turystycznych - Etap 4
"""

# ============================================================================
# IMPORTY BIBLIOTEK
# ============================================================================
import re                                       # Wyrażenia regularne
import requests                                 # HTTP requests
from bs4 import BeautifulSoup                   # Parser HTML
from typing import Dict, List, Optional, Any, Tuple  # Podpowiedzi typów
from dataclasses import dataclass               # Struktury danych
import logging                                  # System logowania
import time                                     # Opóźnienia między requestami
from urllib.parse import urljoin, urlparse      # Parsowanie URL

# ============================================================================
# KONFIGURACJA LOGOWANIA
# ============================================================================
logging.basicConfig(level=logging.INFO)        # Poziom logowania
logger = logging.getLogger(__name__)           # Logger dla tego modułu

# ============================================================================
# STRUKTURY DANYCH
# ============================================================================

@dataclass
class ExtractedRouteData:
    """
    Struktura danych przechowująca wszystkie informacje wyekstraktowane z HTML.
    
    Attributes:
        name: Nazwa trasy (np. "Szlak na Rysy")
        length: Długość trasy w kilometrach (np. 12.5)
        duration: Czas przejścia jako string (np. "4h 30min") 
        elevation_gain: Przewyższenie w metrach (np. 800)
        difficulty: Poziom trudności (np. "trudna", "średnia")
        description: Pełny opis trasy z informacjami szczegółowymi
        images: Lista URL-i do zdjęć trasy
        coordinates: Współrzędne GPS jako tuple (lat, lon)
        reviews: Lista tekstów recenzji użytkowników
        rating: Średnia ocena jako liczba (np. 4.5)
        
    Wszystkie pola są opcjonalne - jeśli dana informacja nie została
    znaleziona na stronie, pole ma wartość None lub pustą listę.
    """
    name: Optional[str] = None                          # Nazwa trasy
    length: Optional[float] = None                      # Długość w km
    duration: Optional[str] = None                      # Czas przejścia
    elevation_gain: Optional[int] = None                # Przewyższenie w m
    difficulty: Optional[str] = None                    # Poziom trudności
    description: Optional[str] = None                   # Opis trasy
    images: List[str] = None                           # Lista URL zdjęć
    coordinates: Optional[Tuple[float, float]] = None   # Współrzędne GPS
    reviews: List[str] = None                          # Recenzje użytkowników
    rating: Optional[float] = None                     # Średnia ocena
    
    def __post_init__(self):
        """
        Inicjalizacja pustych list dla pól, które nie mogą być None.
        Wywoływana automatycznie po utworzeniu obiektu.
        """
        if self.images is None:
            self.images = []        # Pusta lista URL-i zdjęć
        if self.reviews is None:
            self.reviews = []       # Pusta lista recenzji

class HTMLRouteExtractor:
    """
    Klasa do parsowania stron internetowych z opisami tras turystycznych.
    """
    
    def __init__(self):
        """Inicjalizacja extractora z konfiguracją selektorów CSS."""
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })
        
        # Selektory CSS dla różnych typów stron zgodnie z wymaganiami
        self.selectors = {
            'route_params_table': [
                'table.route-params',
                'table.trail-info',
                'table.szlak-parametry',
                '.route-details table',
                '.trail-details table'
            ],
            'route_description': [
                'div.route-description',
                'div.trail-description',
                'div.opis-trasy',
                '.content .description',
                '.route-content'
            ],
            'gallery': [
                'div.gallery',
                'div.photo-gallery',
                'div.galeria',
                '.images',
                '.photos'
            ],
            'map_container': [
                'div#map',
                'div.map-container',
                'div.mapa',
                '.leaflet-container',
                '.google-map'
            ],
            'user_reviews': [
                'div.user-review',
                'div.review',
                'div.opinia',
                '.reviews .review-item',
                '.comments .comment'
            ],
            'rating': [
                '.rating',
                '.ocena',
                '.stars',
                '.gwiazdki'
            ],
            'route_name': [
                'h1',
                'h2.route-name',
                '.trail-title',
                '.route-title'
            ]
        }
        
        # Wzorce do ekstrakcji parametrów z tabel
        self.parameter_patterns = {
            'length': re.compile(r'długość[:\s]*(\d+(?:\.\d+)?)\s*km', re.IGNORECASE),
            'duration': re.compile(r'czas[:\s]*([^<\n]+)', re.IGNORECASE),
            'elevation': re.compile(r'przewyższenie[:\s]*(\d+)\s*m', re.IGNORECASE),
            'difficulty': re.compile(r'trudność[:\s]*([^<\n]+)', re.IGNORECASE)
        }
    
    def fetch_page(self, url: str) -> Optional[BeautifulSoup]:
        """
        Pobiera stronę internetową i zwraca obiekt BeautifulSoup.
        
        Args:
            url: URL strony do pobrania
            
        Returns:
            BeautifulSoup object lub None w przypadku błędu
        """
        try:
            logger.info(f"Pobieranie strony: {url}")
            response = self.session.get(url, timeout=10)
            response.raise_for_status()
            
            # Sprawdź encoding
            if response.encoding == 'ISO-8859-1':
                response.encoding = 'utf-8'
            
            soup = BeautifulSoup(response.content, 'html.parser')
            logger.info(f"Pomyślnie pobrano stronę: {len(response.content)} bajtów")
            return soup
            
        except requests.RequestException as e:
            logger.error(f"Błąd podczas pobierania strony {url}: {e}")
            return None
        except Exception as e:
            logger.error(f"Nieoczekiwany błąd podczas przetwarzania {url}: {e}")
            return None
    
    def extract_from_table(self, soup: BeautifulSoup) -> Dict[str, Any]:
        """
        Ekstraktuje strukturalne informacje o trasach z tabel parametrów.
        
        Args:
            soup: Obiekt BeautifulSoup strony
            
        Returns:
            Słownik z wyekstraktowanymi parametrami
        """
        extracted_data = {}
        
        # Znajdź tabele z parametrami tras
        for selector in self.selectors['route_params_table']:
            tables = soup.select(selector)
            for table in tables:
                rows = table.find_all('tr')
                for row in rows:
                    cells = row.find_all(['td', 'th'])
                    if len(cells) >= 2:
                        key = cells[0].get_text(strip=True).lower()
                        value = cells[1].get_text(strip=True)
                        
                        # Mapowanie kluczy na standardowe nazwy
                        if 'długość' in key or 'distance' in key:
                            match = re.search(r'(\d+(?:\.\d+)?)', value)
                            if match:
                                extracted_data['length'] = float(match.group(1))
                        
                        elif 'czas' in key or 'time' in key or 'duration' in key:
                            extracted_data['duration'] = value
                        
                        elif 'przewyższenie' in key or 'elevation' in key:
                            match = re.search(r'(\d+)', value)
                            if match:
                                extracted_data['elevation_gain'] = int(match.group(1))
                        
                        elif 'trudność' in key or 'difficulty' in key:
                            extracted_data['difficulty'] = value
        
        return extracted_data
    
    def extract_description(self, soup: BeautifulSoup) -> Optional[str]:
        """
        Ekstraktuje opis trasy z sekcji opisowych.
        
        Args:
            soup: Obiekt BeautifulSoup strony
            
        Returns:
            Tekst opisu lub None jeśli nie znaleziono
        """
        for selector in self.selectors['route_description']:
            elements = soup.select(selector)
            for element in elements:
                text = element.get_text(strip=True)
                if len(text) > 50:  # Filtruj zbyt krótkie opisy
                    return text
        return None
    
    def extract_images(self, soup: BeautifulSoup, base_url: str) -> List[str]:
        """
        Ekstraktuje URLe zdjęć z galerii.
        
        Args:
            soup: Obiekt BeautifulSoup strony
            base_url: Bazowy URL strony dla względnych linków
            
        Returns:
            Lista URLi zdjęć
        """
        images = []
        
        # Znajdź galerie zdjęć
        for selector in self.selectors['gallery']:
            galleries = soup.select(selector)
            for gallery in galleries:
                img_tags = gallery.find_all('img')
                for img in img_tags:
                    src = img.get('src') or img.get('data-src')
                    if src:
                        # Konwertuj względne URLe na bezwzględne
                        full_url = urljoin(base_url, src)
                        images.append(full_url)
        
        # Dodatkowe wyszukiwanie wszystkich obrazów na stronie
        if not images:
            all_images = soup.find_all('img')
            for img in all_images:
                src = img.get('src') or img.get('data-src')
                alt = img.get('alt', '').lower()
                if src and any(keyword in alt for keyword in ['trail', 'szlak', 'góry', 'mountain']):
                    full_url = urljoin(base_url, src)
                    images.append(full_url)
        
        return images[:10]  # Ograniczenie do 10 zdjęć
    
    def extract_coordinates(self, soup: BeautifulSoup) -> Optional[Tuple[float, float]]:
        """
        Ekstraktuje współrzędne z map interaktywnych.
        
        Args:
            soup: Obiekt BeautifulSoup strony
            
        Returns:
            Tuple (latitude, longitude) lub None
        """
        # Szukaj w meta tagach
        meta_geo = soup.find('meta', {'name': 'geo.position'})
        if meta_geo:
            content = meta_geo.get('content')
            if content:
                try:
                    lat, lon = content.split(';')
                    return (float(lat), float(lon))
                except (ValueError, AttributeError):
                    pass
        
        # Szukaj w skryptach JavaScript
        scripts = soup.find_all('script')
        for script in scripts:
            if script.string:
                # Wzorce dla popularnych map
                lat_lon_patterns = [
                    r'lat[:\s]*([0-9.-]+)[,\s]*lng[:\s]*([0-9.-]+)',
                    r'latitude[:\s]*([0-9.-]+)[,\s]*longitude[:\s]*([0-9.-]+)',
                    r'center[:\s]*\[([0-9.-]+)[,\s]*([0-9.-]+)\]'
                ]
                
                for pattern in lat_lon_patterns:
                    match = re.search(pattern, script.string, re.IGNORECASE)
                    if match:
                        try:
                            return (float(match.group(1)), float(match.group(2)))
                        except ValueError:
                            continue
        
        return None
    
    def extract_reviews(self, soup: BeautifulSoup) -> List[str]:
        """
        Ekstraktuje recenzje użytkowników.
        
        Args:
            soup: Obiekt BeautifulSoup strony
            
        Returns:
            Lista tekstów recenzji
        """
        reviews = []
        
        for selector in self.selectors['user_reviews']:
            reviews_elements = soup.select(selector)
            for element in reviews_elements:
                # Pomiń elementy rating-only
                rating_element = element.find(class_=re.compile(r'rating|stars|gwiazdki'))
                if rating_element:
                    rating_element.decompose()
                
                text = element.get_text(strip=True)
                if len(text) > 20:  # Filtruj zbyt krótkie recenzje
                    reviews.append(text)
        
        return reviews[:20]  # Ograniczenie do 20 recenzji
    
    def extract_rating(self, soup: BeautifulSoup) -> Optional[float]:
        """
        Ekstraktuje ocenę z elementów rating.
        
        Args:
            soup: Obiekt BeautifulSoup strony
            
        Returns:
            Ocena jako float lub None
        """
        for selector in self.selectors['rating']:
            rating_elements = soup.select(selector)
            for element in rating_elements:
                # Szukaj gwiazdek
                stars = element.find_all(class_=re.compile(r'star|filled'))
                if stars:
                    return float(len(stars))
                
                # Szukaj tekstu z oceną
                text = element.get_text(strip=True)
                rating_match = re.search(r'(\d(?:\.\d)?)[/\s]*(?:5|10)', text)
                if rating_match:
                    rating = float(rating_match.group(1))
                    # Normalizuj do skali 1-5
                    if rating > 5:
                        rating = rating / 2
                    return rating
        
        return None
    
    def extract_route_name(self, soup: BeautifulSoup) -> Optional[str]:
        """
        Ekstraktuje nazwę trasy.
        
        Args:
            soup: Obiekt BeautifulSoup strony
            
        Returns:
            Nazwa trasy lub None
        """
        for selector in self.selectors['route_name']:
            elements = soup.select(selector)
            for element in elements:
                text = element.get_text(strip=True)
                if text and len(text) < 200:  # Filtruj zbyt długie tytuły
                    return text
        
        # Fallback - sprawdź title strony
        title = soup.find('title')
        if title:
            return title.get_text(strip=True)
        
        return None
    
    def extract_route_data(self, url: str) -> Optional[ExtractedRouteData]:
        """
        Główna metoda ekstraktująca wszystkie dane o trasie ze strony.
        
        Args:
            url: URL strony z opisem trasy
            
        Returns:
            ExtractedRouteData z wyekstraktowanymi informacjami
        """
        soup = self.fetch_page(url)
        if not soup:
            return None
        
        logger.info(f"Ekstraktowanie danych z: {url}")
        
        # Wyekstraktuj wszystkie elementy
        table_data = self.extract_from_table(soup)
        
        extracted_data = ExtractedRouteData(
            name=self.extract_route_name(soup),
            length=table_data.get('length'),
            duration=table_data.get('duration'),
            elevation_gain=table_data.get('elevation_gain'),
            difficulty=table_data.get('difficulty'),
            description=self.extract_description(soup),
            images=self.extract_images(soup, url),
            coordinates=self.extract_coordinates(soup),
            reviews=self.extract_reviews(soup),
            rating=self.extract_rating(soup)
        )
        
        logger.info(f"Wyekstraktowano dane: nazwa='{extracted_data.name}', "
                   f"długość={extracted_data.length}km, "
                   f"zdjęcia={len(extracted_data.images)}, "
                   f"recenzje={len(extracted_data.reviews)}")
        
        return extracted_data
    
    def extract_multiple_routes(self, urls: List[str], delay: float = 1.0) -> List[ExtractedRouteData]:
        """
        Ekstraktuje dane z wielu stron z opóźnieniem między requestami.
        
        Args:
            urls: Lista URLi do przetworzenia
            delay: Opóźnienie między requestami w sekundach
            
        Returns:
            Lista ExtractedRouteData
        """
        results = []
        
        for i, url in enumerate(urls):
            logger.info(f"Przetwarzanie {i+1}/{len(urls)}: {url}")
            
            extracted_data = self.extract_route_data(url)
            if extracted_data:
                results.append(extracted_data)
            
            # Opóźnienie między requestami
            if i < len(urls) - 1:
                time.sleep(delay)
        
        logger.info(f"Zakończono ekstraktowanie. Przetworzono {len(results)} z {len(urls)} stron.")
        return results

#extractors\web_data_collector.py

"""
WebDataCollector module for automatic data collection from hiking portals.
"""

import os
import json
import hashlib
import requests
from bs4 import BeautifulSoup
from typing import Dict, List, Optional, Any
import logging
from datetime import datetime, timedelta
import time
import pickle
from urllib.parse import urljoin, urlparse
import sys
import inspect

# Konfiguracja logowania
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Dynamiczny import dla obsługi względnych importów
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
sys.path.insert(0, currentdir)

try:
    from html_route_extractor import HTMLRouteExtractor, ExtractedRouteData
except ImportError:
    logger.warning("Nie można zaimportować HTMLRouteExtractor, utworzę minimalną implementację")
    
    class ExtractedRouteData:
        def __init__(self, **kwargs):
            for key, value in kwargs.items():
                setattr(self, key, value)
    
    class HTMLRouteExtractor:
        def extract_route_data(self, url):
            return None

class WebDataCollector:
    """
    Klasa do automatycznego pobierania danych o trasach z popularnych portali turystycznych
    z obsługą różnych struktur HTML i formatów danych oraz mechanizmem cache'owania.
    """
    
    def __init__(self, cache_dir: str = "data/html_cache"):
        """
        Inicjalizacja collectora z konfiguracją portali i cache.
        
        Args:
            cache_dir: Katalog do przechowywania cache'owanych danych
        """
        self.cache_dir = cache_dir
        self.html_extractor = HTMLRouteExtractor()
        
        # Zapewnienie istnienia katalogu cache
        os.makedirs(cache_dir, exist_ok=True)
        
        # Konfiguracja popularnych portali turystycznych
        self.portals = {
            'e-turysta': {
                'base_url': 'https://e-turysta.pl',
                'search_paths': ['/szlaki', '/trasy'],
                'route_patterns': [r'/szlak/(\d+)', r'/trasa/(\d+)'],
                'custom_selectors': {
                    'route_list': '.trail-list .trail-item',
                    'route_link': 'a.trail-link',
                    'route_params': '.trail-params table'
                }
            },
            'traseo': {
                'base_url': 'https://traseo.pl',
                'search_paths': ['/trasy', '/szlaki-piesze'],
                'route_patterns': [r'/trasa/([^/]+)', r'/szlak/([^/]+)'],
                'custom_selectors': {
                    'route_list': '.route-item',
                    'route_link': 'a.route-title',
                    'route_params': '.route-details'
                }
            },
            'szlaki-gorskie': {
                'base_url': 'https://szlaki-gorskie.pl',
                'search_paths': ['/szlaki', '/trasy-gorskie'],
                'route_patterns': [r'/szlak-([^/]+)', r'/trasa-([^/]+)'],
                'custom_selectors': {
                    'route_list': '.szlak-lista .szlak',
                    'route_link': '.szlak-link',
                    'route_params': '.parametry-szlaku'
                }
            }
        }
        
        # Konfiguracja cache (domyślnie 24 godziny)
        self.cache_expiry_hours = 24
        
        # Headers dla zapytań HTTP
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'pl-PL,pl;q=0.9,en;q=0.8',
            'Accept-Encoding': 'gzip, deflate, br',
            'DNT': '1',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1'
        })
    
    def _get_cache_key(self, url: str, params: Dict = None) -> str:
        """
        Generuje klucz cache dla URL i parametrów.
        
        Args:
            url: URL zapytania
            params: Dodatkowe parametry
            
        Returns:
            Hash string jako klucz cache
        """
        cache_string = url
        if params:
            cache_string += json.dumps(params, sort_keys=True)
        return hashlib.md5(cache_string.encode()).hexdigest()
    
    def _get_cache_path(self, cache_key: str) -> str:
        """
        Zwraca ścieżkę do pliku cache.
        
        Args:
            cache_key: Klucz cache
            
        Returns:
            Pełna ścieżka do pliku cache
        """
        return os.path.join(self.cache_dir, f"{cache_key}.cache")
    
    def _is_cache_valid(self, cache_path: str) -> bool:
        """
        Sprawdza czy cache jest ważny (nie wygasł).
        
        Args:
            cache_path: Ścieżka do pliku cache
            
        Returns:
            True jeśli cache jest ważny
        """
        if not os.path.exists(cache_path):
            return False
        
        file_time = datetime.fromtimestamp(os.path.getmtime(cache_path))
        expiry_time = datetime.now() - timedelta(hours=self.cache_expiry_hours)
        
        return file_time > expiry_time
    
    def _save_to_cache(self, cache_key: str, data: Any) -> None:
        """
        Zapisuje dane do cache.
        
        Args:
            cache_key: Klucz cache
            data: Dane do zapisania
        """
        cache_path = self._get_cache_path(cache_key)
        try:
            with open(cache_path, 'wb') as f:
                pickle.dump({
                    'data': data,
                    'timestamp': datetime.now().isoformat()
                }, f)
            logger.debug(f"Zapisano do cache: {cache_key}")
        except Exception as e:
            logger.error(f"Błąd podczas zapisywania do cache {cache_key}: {e}")
    
    def _load_from_cache(self, cache_key: str) -> Optional[Any]:
        """
        Ładuje dane z cache.
        
        Args:
            cache_key: Klucz cache
            
        Returns:
            Załadowane dane lub None jeśli nie znaleziono
        """
        cache_path = self._get_cache_path(cache_key)
        
        if not self._is_cache_valid(cache_path):
            return None
        
        try:
            with open(cache_path, 'rb') as f:
                cached_data = pickle.load(f)
                logger.debug(f"Załadowano z cache: {cache_key}")
                return cached_data['data']
        except Exception as e:
            logger.error(f"Błąd podczas ładowania z cache {cache_key}: {e}")
            return None
    
    def _fetch_with_cache(self, url: str, params: Dict = None) -> Optional[BeautifulSoup]:
        """
        Pobiera stronę z obsługą cache.
        
        Args:
            url: URL do pobrania
            params: Parametry zapytania
            
        Returns:
            BeautifulSoup object lub None
        """
        cache_key = self._get_cache_key(url, params)
        
        # Sprawdź cache
        cached_content = self._load_from_cache(cache_key)
        if cached_content:
            logger.info(f"Używam cache dla: {url}")
            return BeautifulSoup(cached_content, 'html.parser')
        
        # Pobierz ze źródła
        try:
            logger.info(f"Pobieranie: {url}")
            response = self.session.get(url, params=params, timeout=10)
            response.raise_for_status()
            
            # Sprawdź encoding
            if response.encoding == 'ISO-8859-1':
                response.encoding = 'utf-8'
            
            # Zapisz do cache
            self._save_to_cache(cache_key, response.text)
            
            return BeautifulSoup(response.content, 'html.parser')
            
        except requests.RequestException as e:
            logger.error(f"Błąd podczas pobierania {url}: {e}")
            return None
    
    def discover_route_urls(self, portal_name: str, region: str = None, max_routes: int = 50) -> List[str]:
        """
        Automatycznie odkrywa URLe tras z portalu turystycznego.
        
        Args:
            portal_name: Nazwa portalu ('e-turysta', 'traseo', 'szlaki-gorskie')
            region: Opcjonalny filtr regionu
            max_routes: Maksymalna liczba tras do znalezienia
            
        Returns:
            Lista URLi tras
        """
        if portal_name not in self.portals:
            logger.error(f"Nieznany portal: {portal_name}")
            return []
        
        portal_config = self.portals[portal_name]
        route_urls = []
        
        # Przeszukuj ścieżki wyszukiwania
        for search_path in portal_config['search_paths']:
            if len(route_urls) >= max_routes:
                break
                
            search_url = urljoin(portal_config['base_url'], search_path)
            
            # Dodaj parametry regionu jeśli podano
            params = {}
            if region:
                params['region'] = region
                params['wojewodztwo'] = region
                params['miejsce'] = region
            
            soup = self._fetch_with_cache(search_url, params)
            if not soup:
                continue
            
            # Znajdź linki do tras używając selektorów portalu
            selectors = portal_config['custom_selectors']
            
            # Użyj specyficznych selektorów dla portalu
            route_elements = soup.select(selectors.get('route_list', '.route-item'))
            
            for element in route_elements:
                if len(route_urls) >= max_routes:
                    break
                
                # Znajdź link do trasy
                link_selector = selectors.get('route_link', 'a')
                link_element = element.select_one(link_selector)
                
                if link_element and link_element.get('href'):
                    route_url = urljoin(portal_config['base_url'], link_element['href'])
                    if route_url not in route_urls:
                        route_urls.append(route_url)
            
            # Dodatkowe opóźnienie między requestami
            time.sleep(1)
        
        logger.info(f"Znaleziono {len(route_urls)} tras z portalu {portal_name}")
        return route_urls
    
    def collect_routes_from_portal(self, portal_name: str, region: str = None, max_routes: int = 20) -> List[ExtractedRouteData]:
        """
        Zbiera dane tras z konkretnego portalu turystycznego.
        
        Args:
            portal_name: Nazwa portalu
            region: Opcjonalny filtr regionu
            max_routes: Maksymalna liczba tras
            
        Returns:
            Lista ExtractedRouteData
        """
        logger.info(f"Zbieranie tras z portalu: {portal_name}")
        
        # Odkryj URLe tras
        route_urls = self.discover_route_urls(portal_name, region, max_routes)
        
        if not route_urls:
            logger.warning(f"Nie znaleziono tras w portalu {portal_name}")
            return []
        
        # Ekstraktuj dane z każdej trasy
        routes_data = []
        for i, url in enumerate(route_urls):
            logger.info(f"Przetwarzanie trasy {i+1}/{len(route_urls)} z {portal_name}")
            
            route_data = self.html_extractor.extract_route_data(url)
            if route_data:
                # Dodaj informacje o źródle
                route_data.source_portal = portal_name
                route_data.source_url = url
                routes_data.append(route_data)
            
            # Opóźnienie między requestami
            time.sleep(2)
        
        logger.info(f"Zebrano {len(routes_data)} tras z portalu {portal_name}")
        return routes_data
    
    def collect_routes_from_all_portals(self, region: str = None, max_routes_per_portal: int = 10) -> Dict[str, List[ExtractedRouteData]]:
        """
        Zbiera dane tras ze wszystkich skonfigurowanych portali.
        
        Args:
            region: Opcjonalny filtr regionu
            max_routes_per_portal: Maksymalna liczba tras na portal
            
        Returns:
            Słownik z danymi tras pogrupowanymi po portalach
        """
        all_routes = {}
        
        for portal_name in self.portals.keys():
            logger.info(f"Rozpoczynam zbieranie z portalu: {portal_name}")
            
            try:
                routes = self.collect_routes_from_portal(portal_name, region, max_routes_per_portal)
                all_routes[portal_name] = routes
                
                # Pauza między portalami
                time.sleep(5)
                
            except Exception as e:
                logger.error(f"Błąd podczas zbierania z portalu {portal_name}: {e}")
                all_routes[portal_name] = []
        
        total_routes = sum(len(routes) for routes in all_routes.values())
        logger.info(f"Łącznie zebrano {total_routes} tras ze wszystkich portali")
        
        return all_routes
    
    def integrate_with_weather_api(self, routes_data: List[ExtractedRouteData], weather_api) -> List[Dict[str, Any]]:
        """
        Integruje zebrane dane tras z API serwisów pogodowych.
        
        Args:
            routes_data: Lista danych tras
            weather_api: Instancja API pogodowego
            
        Returns:
            Lista zintegrowanych danych tras
        """
        integrated_routes = []
        
        for route_data in routes_data:
            route_dict = {
                'name': route_data.name,
                'length_km': route_data.length,
                'duration': route_data.duration,
                'elevation_gain': route_data.elevation_gain,
                'difficulty': route_data.difficulty,
                'description': route_data.description,
                'images': route_data.images,
                'coordinates': route_data.coordinates,
                'reviews': route_data.reviews,
                'rating': route_data.rating,
                'source_portal': getattr(route_data, 'source_portal', 'unknown'),
                'source_url': getattr(route_data, 'source_url', ''),
                'extraction_date': datetime.now().isoformat()
            }
            
            # Spróbuj dodać dane pogodowe jeśli są współrzędne
            if route_data.coordinates and weather_api:
                try:
                    # Szacowana lokalizacja na podstawie współrzędnych
                    # (w rzeczywistej implementacji można użyć reverse geocoding)
                    weather_data = weather_api.get_weather_forecast('Kraków', datetime.now().strftime('%Y-%m-%d'))
                    if weather_data:
                        route_dict['weather_forecast'] = weather_data
                except Exception as e:
                    logger.warning(f"Nie udało się pobrać danych pogodowych dla trasy {route_data.name}: {e}")
            
            integrated_routes.append(route_dict)
        
        return integrated_routes
    
    def save_collected_data(self, collected_data: Dict[str, List[ExtractedRouteData]], output_file: str) -> None:
        """
        Zapisuje zebrane dane do pliku.
        
        Args:
            collected_data: Zebrane dane tras
            output_file: Ścieżka do pliku wyjściowego
        """
        # Konwertuj na format serializowalny
        serializable_data = {}
        
        for portal_name, routes in collected_data.items():
            serializable_data[portal_name] = []
            for route in routes:
                route_dict = {
                    'name': route.name,
                    'length': route.length,
                    'duration': route.duration,
                    'elevation_gain': route.elevation_gain,
                    'difficulty': route.difficulty,
                    'description': route.description,
                    'images': route.images,
                    'coordinates': route.coordinates,
                    'reviews': route.reviews,
                    'rating': route.rating,
                    'source_portal': getattr(route, 'source_portal', portal_name),
                    'source_url': getattr(route, 'source_url', ''),
                    'extraction_date': datetime.now().isoformat()
                }
                serializable_data[portal_name].append(route_dict)
        
        # Zapisz do pliku
        try:
            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(serializable_data, f, ensure_ascii=False, indent=2)
            logger.info(f"Zapisano zebrane dane do: {output_file}")
        except Exception as e:
            logger.error(f"Błąd podczas zapisywania danych do {output_file}: {e}")
    
    def clear_cache(self, older_than_hours: int = None) -> None:
        """
        Czyści cache starsze niż podany czas.
        
        Args:
            older_than_hours: Usuń pliki starsze niż X godzin (domyślnie wszystkie)
        """
        if not os.path.exists(self.cache_dir):
            return
        
        removed_count = 0
        cutoff_time = None
        
        if older_than_hours:
            cutoff_time = datetime.now() - timedelta(hours=older_than_hours)
        
        for filename in os.listdir(self.cache_dir):
            if filename.endswith('.cache'):
                file_path = os.path.join(self.cache_dir, filename)
                
                if cutoff_time:
                    file_time = datetime.fromtimestamp(os.path.getmtime(file_path))
                    if file_time > cutoff_time:
                        continue
                
                try:
                    os.remove(file_path)
                    removed_count += 1
                except Exception as e:
                    logger.error(f"Błąd podczas usuwania {file_path}: {e}")
        
        logger.info(f"Usunięto {removed_count} plików cache")
    
    def collect_sample_data(self) -> List[Dict[str, Any]]:
        """
        Pobiera przykładowe dane tras z różnych portali.
        
        Returns:
            Lista słowników z danymi tras
        """
        sample_trails = [
            {
                'name': 'Szlak Orlich Gniazd',
                'length_km': 164.0,
                'difficulty': 3,
                'terrain_type': 'górski',
                'region': 'Jura Krakowsko-Częstochowska',
                'description': 'Najsłynniejszy szlak turystyczny w Polsce, prowadzący przez malownicze zamki i skały.',
                'elevation_m': 515,
                'estimated_time': 8.5,
                'category': 'widokowa',
                'tags': ['zamki', 'skały', 'historia'],
                'reviews': [
                    'Fantastyczne widoki na zamki! Polecam szczególnie odcinek do Ogrodzieńca.',
                    'Długi ale bardzo ciekawy szlak. Warto zaplanować kilka dni.',
                    'Piękne krajobrazy, ale trzeba być przygotowanym na trudne odcinki.'
                ]
            },
            {
                'name': 'Szlak Pienińska Ścieżka',
                'length_km': 12.5,
                'difficulty': 2,
                'terrain_type': 'górski',
                'region': 'Pieniny',
                'description': 'Malowniczy szlak wzdłuż Dunajca z widokami na Trzy Korony.',
                'elevation_m': 982,
                'estimated_time': 4.0,
                'category': 'widokowa',
                'tags': ['dunajec', 'widoki', 'przełom'],
                'reviews': [
                    'Niesamowite widoki na przełom Dunajca!',
                    'Łatwy szlak, idealny dla rodzin z dziećmi.',
                    'Polecam połączyć z spływem pontonowym.'
                ]
            },
            {
                'name': 'Szlak Mazurski',
                'length_km': 8.3,
                'difficulty': 1,
                'terrain_type': 'nizinny',
                'region': 'Mazury',
                'description': 'Spokojny szlak wokół jezior mazurskich, idealny dla rodzin.',
                'elevation_m': 145,
                'estimated_time': 2.5,
                'category': 'rodzinna',
                'tags': ['jeziora', 'rodzinny', 'łatwy'],
                'reviews': [
                    'Idealny na spacer z dziećmi. Piękne jeziora.',
                    'Bardzo spokojny szlak, można spotkać dużo ptaków.',
                    'Polecam wczesnym rankiem - mniej ludzi.'
                ]
            },
            {
                'name': 'Szlak Karkonoski',
                'length_km': 28.7,
                'difficulty': 3,
                'terrain_type': 'górski',
                'region': 'Karkonosze',
                'description': 'Wymagający szlak przez najwyższe szczyty Karkonoszy.',
                'elevation_m': 1602,
                'estimated_time': 12.0,
                'category': 'ekstremalna',
                'tags': ['śnieżka', 'wysokogórski', 'trudny'],
                'reviews': [
                    'Bardzo wymagający szlak, ale widoki rekompensują trud.',
                    'Uwaga na pogodę - może się szybko zmienić.',
                    'Najlepszy szlak w Karkonoszach dla doświadczonych.'
                ]
            },
            {
                'name': 'Szlak Nadmorski',
                'length_km': 15.2,
                'difficulty': 1,
                'terrain_type': 'nizinny',
                'region': 'Wybrzeże',
                'description': 'Szlak wzdłuż wybrzeża Bałtyku przez wydmy i lasy.',
                'elevation_m': 58,
                'estimated_time': 4.5,
                'category': 'sportowa',
                'tags': ['morze', 'wydmy', 'plaża'],
                'reviews': [
                    'Piękny szlak z widokiem na morze.',
                    'Można połączyć z kąpielą w morzu.',
                    'Uwaga na wiatr - może być silny.'
                ]
            }
        ]
        
        logger.info(f"Wygenerowano {len(sample_trails)} przykładowych tras")
        return sample_trails

#recommendation\trail_recommender.py

from typing import List, Dict, Any, Optional
from functools import reduce
from datetime import datetime
import os
import sys

# Dodaj katalog projektu do ścieżki Pythona
project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(project_root)

from data_handlers.trail_data import TrailDataHandler
from utils.weather_utils import WeatherUtils
from utils.weight_calculator import WeightCalculator
from utils.time_calculator import TimeCalculator

try:
    from reporters.pdf_report_generator import PDFReportGenerator
except ImportError:
    print("Ostrzeżenie: Nie można zaimportować PDFReportGenerator")
    PDFReportGenerator = None

class TrailRecommender:
    def __init__(self):
        """Inicjalizuje obiekt TrailRecommender z obsługą danych."""
        self.data_handler = TrailDataHandler()
        self.weight_calculator = WeightCalculator()
        
        # Inicjalizuj generator raportów PDF jeśli dostępny
        self.pdf_generator = PDFReportGenerator() if PDFReportGenerator else None
    
    def set_weights_from_user(self) -> Dict[str, float]:
        """
        Pobiera wagi od użytkownika i ustawia je w kalkulatorze.
        
        Returns:
            Dict[str, float]: Ustawione wagi
        """
        return self.weight_calculator.get_weights_from_user()

    def _categorize_trail(self, trail: Dict[str, Any]) -> str:
        """
        Kategoryzuje trasę na podstawie jej charakterystyki.
        
        Kryteria:
        - rodzinna: łatwe (trudność 1), krótkie trasy (<5km), małe przewyższenie (<200m)
        - widokowa: punkty widokowe, trasy turystyczne ze sceneriami
        - sportowa: średnie/długie trasy (5-15km), średnia trudność
        - ekstremalna: trudne trasy, duże przewyższenie, długie dystanse
        """
        difficulty = trail.get('difficulty', 1)
        length = trail.get('length_km', 0)
        elevation = trail.get('elevation_m', 0)
        tags = trail.get('tags', [])
        description = str(trail.get('description', '')).lower()
        
        # Zaczynamy od sprawdzenia trasy rodzinnej (najprostsze kryteria)
        if difficulty == 1 and length < 5 and elevation < 200:
            if (any(tag in ['leisure', 'park', 'playground', 'family'] for tag in tags) or
                any(keyword in description for keyword in ['rodzin', 'łatw', 'spokojna', 'dziec'])):
                return "rodzinna"
            
        # Następnie sprawdzamy trasę widokową
        if (length < 15 and  # Trasy widokowe zazwyczaj nie są zbyt długie
            (any(tag in ['viewpoint', 'scenic', 'tourism', 'view_point', 'panorama'] for tag in tags) or
             any(keyword in description for keyword in ['widok', 'panoram', 'scenic', 'krajobraz', 'punkt widokowy']))):
            return "widokowa"
            
        # Sprawdzamy trasę ekstremalną
        if (difficulty == 3 or length > 15 or elevation > 800 or
            any(tag in ['climbing', 'alpine', 'via_ferrata', 'extreme'] for tag in tags) or
            any(keyword in description for keyword in ['ekstre', 'trudna', 'wymagając', 'alpejsk'])):
            return "ekstremalna"
            
        # Jeśli trasa ma średnią trudność i długość, klasyfikujemy jako sportową
        if ((difficulty == 2 and 5 <= length <= 15) or
            any(keyword in description for keyword in ['sport', 'aktyw', 'kondycyj', 'wysiłk'])):
            return "sportowa"
            
        # Jeśli nie pasuje do żadnej kategorii, przypisujemy na podstawie długości i trudności
        if length < 5:
            return "rodzinna"
        elif length > 15 or difficulty == 3:
            return "ekstremalna"
        elif difficulty == 2 or 5 <= length <= 15:
            return "sportowa"
        else:
            # Jeśli naprawdę nie możemy określić, dajemy widokową jako najbezpieczniejszą opcję
            return "widokowa"

    def _calculate_comfort_indices(self, trails: List[Dict[str, Any]], 
                                weather: Optional[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Oblicza indeks komfortu dla każdej trasy na podstawie warunków pogodowych.
        
        Args:
            trails (List[Dict[str, Any]]): Lista tras
            weather (Optional[Dict[str, Any]]): Dane pogodowe
            
        Returns:
            List[Dict[str, Any]]: Lista tras z dodanym indeksem komfortu
        """
        if not weather:
            return trails

        # Dla każdej trasy oblicz indywidualny indeks komfortu
        for trail in trails:
            # Dostosuj warunki pogodowe do specyfiki trasy
            trail_weather = weather.copy()
            
            # Modyfikuj warunki w zależności od typu terenu i wysokości
            if trail.get('terrain_type') == 'górski':
                # W górach temperatura jest niższa (średnio o 0.6°C na 100m wysokości)
                elevation = trail.get('elevation', 0)
                temp_adjustment = (elevation / 100) * 0.6
                trail_weather['temperature_2m_mean'] = weather.get('temperature_2m_mean', 0) - temp_adjustment
                # W górach więcej opadów
                trail_weather['precipitation_sum'] = weather.get('precipitation_sum', 0) * 1.2
            
            # Oblicz indeks komfortu dla konkretnej trasy
            trail['comfort_index'] = WeatherUtils.calculate_hiking_comfort(trail_weather)
            
        return trails
    
    def _calculate_trail_time(self, trail: Dict[str, Any]) -> float:
        """
        Oblicza szacowany czas przejścia trasy w godzinach.
        
        Parametry brane pod uwagę:
        - Długość trasy (1km = 1h bazowego czasu)
        - Trudność (mnożnik 1.0-1.8)
        - Typ terenu (różne prędkości)
        
        Returns:
            float: Szacowany czas przejścia w godzinach
        """
        # Długość trasy w km
        length = trail.get('length_km', 0)
        
        # Mnożnik trudności (1-3 -> 1.0-1.8)
        difficulty = trail.get('difficulty', 1)
        difficulty_multiplier = 1.0 + (difficulty - 1) * 0.4  # 1.0, 1.4, lub 1.8
        
        # Mnożnik terenu
        terrain_multipliers = {
            'górski': 1.6,    # Najtrudniejszy teren
            'miejski': 0.8,   # Najłatwiejszy teren
            'leśny': 1.2,     # Średnio trudny teren
            'nizinny': 1.0,   # Bazowy teren
            'mixed': 1.3,     # Teren mieszany
            'riverside': 1.1   # Teren nadrzeczny
        }
        
        terrain_type = trail.get('terrain_type', 'mixed').lower()
        terrain_multiplier = terrain_multipliers.get(terrain_type, 1.3)
        
        # Obliczenie całkowitego czasu
        total_time = length * difficulty_multiplier * terrain_multiplier
        
        return round(total_time, 1)

    def recommend_trails(
        self,
        city: str,
        date: str,
        difficulty: Optional[int] = None,
        terrain_type: Optional[str] = None,
        min_length: Optional[float] = None,
        max_length: Optional[float] = None,
        min_sunshine: Optional[float] = None,
        max_precipitation: Optional[float] = None,
        min_temperature: Optional[float] = None,
        max_temperature: Optional[float] = None,
        category: Optional[str] = None
    ) -> List[Dict[str, Any]]:
        """Rekomenduje trasy na podstawie różnych kryteriów."""
        try:
            # Pobierz wszystkie trasy dla danego miasta
            trails = self.data_handler.get_trails_for_city(city)
            if not trails:
                print(f"Nie znaleziono tras dla miasta {city}")
                return []

            print(f"\nZnaleziono {len(trails)} szlaków dla miasta {city}")

            # Pobieranie prognozy pogody
            print(f"\nPobieranie danych pogodowych dla {city} na dzień {date}...")
            weather = self.data_handler.weather_api.get_weather_forecast(city, date)
            
            # Dodaj kategorię i szacowany czas przejścia do każdej trasy
            for trail in trails:
                trail['category'] = self._categorize_trail(trail)
                trail['estimated_time'] = TimeCalculator.calculate_time(trail)
            
            # Filtrowanie tras używając wyrażenia lambda
            filtered_trails = list(filter(
                lambda trail: (
                    (difficulty is None or trail.get('difficulty') == difficulty) and
                    (terrain_type is None or trail.get('terrain_type') == terrain_type) and
                    (min_length is None or trail.get('length_km', 0) >= min_length) and
                    (max_length is None or trail.get('length_km', 0) <= max_length) and
                    (category is None or trail.get('category') == category)
                ),
                trails
            ))

            # Dodawanie indeksu komfortu do tras
            if weather:
                filtered_trails = self._calculate_comfort_indices(filtered_trails, weather)
                
            # Sort trails using current weights (weights should be set externally)
            filtered_trails = self.weight_calculator.sort_trails_by_weights(filtered_trails, weather or {})
              # Informacja o liczbie znalezionych tras
            if filtered_trails:
                print(f"\nZnaleziono {len(filtered_trails)} tras spełniających kryteria.")
                return filtered_trails
                ResultExporter.export_results(city, date, filtered_trails, weather)
                print("\nWyświetlam szczegóły znalezionych tras:")
                print("=" * 50)

            return filtered_trails

        except Exception as e:
            print(f"Błąd podczas rekomendacji tras: {e}")
            return []
            
    def _save_recommendations_to_file(self, city: str, date: str, trails: List[Dict[str, Any]], 
                                    weather: Optional[Dict[str, Any]] = None):
        """Zapisuje rekomendacje do pliku result.txt."""
        try:
            with open("result.txt", "a", encoding="utf-8") as f:
                f.write(f"\n=== Rekomendacje dla {city} na dzień {date} ===\n")
                f.write(f"Data wygenerowania: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
                
                if weather:
                    comfort_index = WeatherUtils.calculate_hiking_comfort(weather)
                    f.write("Dane pogodowe:\n")
                    f.write(f"Temperatura: {weather.get('temperature_min', 'N/A')}°C - {weather.get('temperature_max', 'N/A')}°C\n")
                    f.write(f"Średnia temperatura: {weather.get('temperature_avg', 'N/A')}°C\n")
                    f.write(f"Opady: {weather.get('precipitation', 'N/A')} mm\n")
                    f.write(f"Zachmurzenie: {weather.get('cloud_cover', 'N/A')}%\n")
                    f.write(f"Godziny słoneczne: {weather.get('sunshine_hours', 'N/A')} h\n")
                    f.write(f"Prędkość wiatru: {weather.get('wind_speed', 'N/A')} km/h\n")
                    f.write(f"Indeks komfortu wędrówki: {comfort_index}/100\n\n")

                f.write(f"Znaleziono {len(trails)} tras:\n\n")
                for i, trail in enumerate(trails, 1):
                    f.write(f"{i}. {trail['name']}\n")
                    f.write(f"   Długość: {trail.get('length_km', 'N/A')} km\n")
                    f.write(f"   Poziom trudności: {trail.get('difficulty', 'N/A')}/3\n")
                    f.write(f"   Typ terenu: {trail.get('terrain_type', 'N/A')}\n")
                    f.write(f"   Kategoria: {trail.get('category', 'N/A')}\n")
                    if 'comfort_index' in trail:
                        f.write(f"   Indeks komfortu: {trail['comfort_index']}/100\n")
                    if 'description' in trail:
                        f.write(f"   Opis: {trail['description']}\n")
                    f.write("\n")
                f.write("=" * 50 + "\n")
                
            print("\nRekomendacje zostały zapisane do pliku result.txt")
        except Exception as e:
            print(f"Błąd podczas zapisywania rekomendacji do pliku: {e}")

    def generate_comprehensive_report(
        self,
        city: str,
        date: str,
        trails: List[Dict[str, Any]],
        search_params: Dict[str, Any],
        weather: Optional[Dict[str, Any]] = None,
        output_filename: str = None
    ) -> Optional[str]:
        """
        Generuje kompleksowy raport PDF z rekomendacjami tras.
        
        Args:
            city: Nazwa miasta
            date: Data wyszukiwania
            trails: Lista rekomendowanych tras
            search_params: Parametry wyszukiwania
            weather: Dane pogodowe
            output_filename: Nazwa pliku wyjściowego
            
        Returns:
            Ścieżka do wygenerowanego raportu PDF lub None w przypadku błędu
        """
        if not self.pdf_generator:
            print("Generator raportów PDF nie jest dostępny")
            return None
            
        if not trails:
            print("Brak tras do wygenerowania raportu")
            return None
        
        try:
            # Rozszerz dane tras o analizę tekstu i recenzji
            enhanced_trails = []
            for trail in trails:
                enhanced_trail = self.data_handler.enhance_trail_with_analysis(trail)
                enhanced_trails.append(enhanced_trail)
            
            # Przygotuj parametry wyszukiwania dla raportu
            report_params = {
                'city': city,
                'date': date,
                **search_params
            }
            
            # Dodaj informacje pogodowe do parametrów
            if weather:
                report_params['weather'] = {
                    'temperature': weather.get('temperature_2m_mean', 'N/A'),
                    'precipitation': weather.get('precipitation_sum', 'N/A'),
                    'sunshine': weather.get('sunshine_duration', 'N/A')
                }
            
            # Generuj raport PDF
            print("\nGenerowanie raportu PDF...")
            
            if not output_filename:
                from datetime import datetime
                timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                output_filename = f"raport_rekomendacji_{city}_{timestamp}.pdf"
            
            pdf_path = self.pdf_generator.generate_pdf_report(
                enhanced_trails,
                report_params,
                output_filename
            )
            
            print(f"✅ Raport PDF został wygenerowany: {pdf_path}")
            return pdf_path
            
        except Exception as e:
            print(f"❌ Błąd podczas generowania raportu PDF: {e}")
            return None
    
    def recommend_trails_with_report(
        self,
        city: str,
        date: str,
        difficulty: Optional[int] = None,
        terrain_type: Optional[str] = None,
        min_length: Optional[float] = None,
        max_length: Optional[float] = None,
        min_sunshine: Optional[float] = None,
        max_precipitation: Optional[float] = None,
        min_temperature: Optional[float] = None,
        max_temperature: Optional[float] = None,
        category: Optional[str] = None,
        generate_pdf: bool = False,
        output_filename: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Rekomenduje trasy i opcjonalnie generuje raport PDF.
        
        Returns:
            Słownik z rekomendowanymi trasami i ścieżką do raportu PDF
        """
        # Standardowe rekomendacje tras
        recommended_trails = self.recommend_trails(
            city, date, difficulty, terrain_type, min_length, max_length,
            min_sunshine, max_precipitation, min_temperature, max_temperature, category
        )
        
        result = {
            'trails': recommended_trails,
            'count': len(recommended_trails),
            'pdf_report': None
        }
        
        # Generuj raport PDF jeśli jest żądany
        if generate_pdf and recommended_trails:
            search_params = {
                'difficulty': difficulty,
                'terrain_type': terrain_type,
                'min_length': min_length,
                'max_length': max_length,
                'min_sunshine': min_sunshine,
                'max_precipitation': max_precipitation,
                'min_temperature': min_temperature,
                'max_temperature': max_temperature,
                'category': category
            }
            
            # Pobierz dane pogodowe dla raportu
            weather = self.data_handler.weather_api.get_weather_forecast(city, date)
            
            pdf_path = self.generate_comprehensive_report(
                city, date, recommended_trails, search_params, weather, output_filename
            )
            
            result['pdf_report'] = pdf_path
        
        return result

#reporters\__init__.py

"""
Moduł do generowania profesjonalnych raportów PDF z wizualizacjami
dla systemu rekomendacji tras turystycznych.
"""

from .pdf_report_generator import PDFReportGenerator
from .chart_generator import ChartGenerator

__all__ = ['PDFReportGenerator', 'ChartGenerator'] 

#reporters\chart_generator.py

"""
Klasa ChartGenerator do tworzenia wykresów dla raportów PDF
zgodnie z wymaganiami z updatelist.txt.
"""

# Konfiguracja matplotlib przed importem pyplot - naprawia błąd Qt na Windows
import matplotlib
matplotlib.use('Agg')  # Backend bez GUI - rozwiązuje problem Qt
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import pandas as pd
from typing import Dict, List, Any, Optional, Tuple
import logging
import os
from datetime import datetime

# Konfiguracja logowania
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Konfiguracja wykresów
plt.style.use('default')
try:
    sns.set_palette("husl")
except Exception as e:
    logger.warning(f"Nie można ustawić palety seaborn: {e}")

class ChartGenerator:
    """
    Klasa do generowania różnych typów wykresów dla raportów o trasach turystycznych.
    """
    
    def __init__(self, output_dir: str = "reports/charts"):
        """
        Inicjalizacja generatora wykresów.
        
        Args:
            output_dir: Katalog do zapisywania wykresów
        """
        self.output_dir = output_dir
        os.makedirs(output_dir, exist_ok=True)
        
        # Konfiguracja kolorów i stylów
        self.colors = {
            'primary': '#2E86AB',
            'secondary': '#A23B72',
            'success': '#4CAF50',
            'warning': '#FF9800',
            'danger': '#F44336',
            'info': '#2196F3',
            'light': '#F5F5F5',
            'dark': '#212121'
        }
        
        # Konfiguracja matplotlib
        plt.rcParams.update({
            'font.size': 10,
            'font.family': 'sans-serif',
            'axes.labelsize': 12,
            'axes.titlesize': 14,
            'xtick.labelsize': 10,
            'ytick.labelsize': 10,
            'legend.fontsize': 10,
            'figure.titlesize': 16
        })
    
    def create_length_histogram(self, trails_data: List[Dict[str, Any]], filename: str = None) -> str:
        """
        Tworzy histogram długości tras.
        
        Args:
            trails_data: Lista danych tras
            filename: Nazwa pliku do zapisania
            
        Returns:
            Ścieżka do zapisanego wykresu
        """
        if not filename:
            filename = f"length_histogram_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
        
        # Wyekstraktuj długości tras
        lengths = [trail.get('length_km', 0) for trail in trails_data if trail.get('length_km')]
        
        if not lengths:
            logger.warning("Brak danych o długości tras")
            return None
        
        # Utwórz wykres
        fig, ax = plt.subplots(figsize=(12, 8))
        
        # Histogram z dostosowaną liczbą binów
        n_bins = min(20, len(set(lengths)))
        ax.hist(lengths, bins=n_bins, color=self.colors['primary'], alpha=0.7, edgecolor='white')
        
        # Konfiguracja wykresu
        ax.set_xlabel('Długość trasy (km)')
        ax.set_ylabel('Liczba tras')
        ax.set_title('Rozkład długości analizowanych tras', fontsize=16, fontweight='bold')
        ax.grid(True, alpha=0.3)
        
        # Dodaj statystyki
        mean_length = np.mean(lengths)
        median_length = np.median(lengths)
        ax.axvline(mean_length, color=self.colors['danger'], linestyle='--', linewidth=2, label=f'Średnia: {mean_length:.1f} km')
        ax.axvline(median_length, color=self.colors['warning'], linestyle='--', linewidth=2, label=f'Mediana: {median_length:.1f} km')
        
        ax.legend()
        plt.tight_layout()
        
        # Zapisz wykres
        file_path = os.path.join(self.output_dir, filename)
        plt.savefig(file_path, dpi=300, bbox_inches='tight')
        plt.close()
        
        logger.info(f"Utworzono histogram długości tras: {file_path}")
        return file_path
    
    def create_category_pie_chart(self, trails_data: List[Dict[str, Any]], filename: str = None) -> str:
        """
        Generuje wykres kołowy kategorii tras.
        
        Args:
            trails_data: Lista danych tras
            filename: Nazwa pliku do zapisania
            
        Returns:
            Ścieżka do zapisanego wykresu
        """
        if not filename:
            filename = f"category_pie_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
        
        # Zlicz kategorie
        categories = {}
        for trail in trails_data:
            category = trail.get('category', 'nieskategoryzowana')
            if category not in categories:
                categories[category] = 0
            categories[category] += 1
        
        if not categories:
            logger.warning("Brak danych o kategoriach tras")
            return None
        
        # Utwórz wykres
        fig, ax = plt.subplots(figsize=(10, 10))
        
        labels = list(categories.keys())
        sizes = list(categories.values())
        colors = plt.cm.Set3(np.linspace(0, 1, len(labels)))
        
        # Wykres kołowy z procentami
        wedges, texts, autotexts = ax.pie(sizes, labels=labels, autopct='%1.1f%%', 
                                         colors=colors, startangle=90, textprops={'fontsize': 11})
        
        # Konfiguracja
        ax.set_title('Rozkład kategorii tras', fontsize=16, fontweight='bold')
        
        # Legenda
        ax.legend(wedges, [f'{label}: {size}' for label, size in zip(labels, sizes)],
                 title="Kategorie", loc="center left", bbox_to_anchor=(1, 0, 0.5, 1))
        
        plt.tight_layout()
        
        # Zapisz wykres
        file_path = os.path.join(self.output_dir, filename)
        plt.savefig(file_path, dpi=300, bbox_inches='tight')
        plt.close()
        
        logger.info(f"Utworzono wykres kołowy kategorii: {file_path}")
        return file_path
    
    def create_rating_bar_chart(self, trails_data: List[Dict[str, Any]], filename: str = None) -> str:
        """
        Wykres słupkowy ocen użytkowników.
        
        Args:
            trails_data: Lista danych tras
            filename: Nazwa pliku do zapisania
            
        Returns:
            Ścieżka do zapisanego wykresu
        """
        if not filename:
            filename = f"rating_bar_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
        
        # Wyekstraktuj oceny
        ratings = []
        for trail in trails_data:
            rating = trail.get('user_rating') or trail.get('rating')
            if rating and isinstance(rating, (int, float)):
                ratings.append(round(rating))
        
        if not ratings:
            logger.warning("Brak danych o ocenach tras")
            return None
        
        # Zlicz oceny
        rating_counts = {i: ratings.count(i) for i in range(1, 6)}
        
        # Utwórz wykres
        fig, ax = plt.subplots(figsize=(10, 6))
        
        x = list(rating_counts.keys())
        y = list(rating_counts.values())
        bars = ax.bar(x, y, color=self.colors['primary'], alpha=0.8, edgecolor='white')
        
        # Dodaj wartości na słupkach
        for bar in bars:
            height = bar.get_height()
            if height > 0:
                ax.text(bar.get_x() + bar.get_width()/2., height,
                       f'{int(height)}', ha='center', va='bottom', fontweight='bold')
        
        # Konfiguracja
        ax.set_xlabel('Ocena (gwiazdki)')
        ax.set_ylabel('Liczba tras')
        ax.set_title('Rozkład ocen użytkowników', fontsize=16, fontweight='bold')
        ax.set_xticks(x)
        ax.set_xticklabels([f'{i} ★' for i in x])
        ax.grid(True, alpha=0.3, axis='y')
        
        # Dodaj średnią ocenę
        if ratings:
            avg_rating = np.mean(ratings)
            ax.axvline(avg_rating, color=self.colors['danger'], linestyle='--', 
                      linewidth=2, label=f'Średnia: {avg_rating:.1f} ★')
            ax.legend()
        
        plt.tight_layout()
        
        # Zapisz wykres
        file_path = os.path.join(self.output_dir, filename)
        plt.savefig(file_path, dpi=300, bbox_inches='tight')
        plt.close()
        
        logger.info(f"Utworzono wykres słupkowy ocen: {file_path}")
        return file_path
    
    def create_seasonal_heatmap(self, trails_data: List[Dict[str, Any]], filename: str = None) -> str:
        """
        Mapa ciepła dostępności tras w poszczególnych miesiącach.
        
        Args:
            trails_data: Lista danych tras
            filename: Nazwa pliku do zapisania
            
        Returns:
            Ścieżka do zapisanego wykresu
        """
        if not filename:
            filename = f"seasonal_heatmap_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
        
        # Symulowane dane sezonowości (w rzeczywistej aplikacji z analizy recenzji)
        months = ['Sty', 'Lut', 'Mar', 'Kwi', 'Maj', 'Cze', 
                 'Lip', 'Sie', 'Wrz', 'Paź', 'Lis', 'Gru']
        
        categories = ['rodzinna', 'widokowa', 'sportowa', 'ekstremalna']
        
        # Przykładowe dane popularności (0-100)
        np.random.seed(42)  # Dla powtarzalności
        data = np.random.randint(20, 100, size=(len(categories), len(months)))
        
        # Modyfikacja dla realności (zima mniej popularna dla ekstremalnych)
        data[3, [0, 1, 11]] = np.random.randint(10, 30, 3)  # ekstremalna zima
        data[0, [5, 6, 7]] = np.random.randint(80, 100, 3)  # rodzinna lato
        
        # Utwórz wykres
        fig, ax = plt.subplots(figsize=(12, 6))
        
        im = ax.imshow(data, cmap='YlOrRd', aspect='auto')
        
        # Konfiguracja osi
        ax.set_xticks(np.arange(len(months)))
        ax.set_yticks(np.arange(len(categories)))
        ax.set_xticklabels(months)
        ax.set_yticklabels([cat.capitalize() for cat in categories])
        
        # Obrót etykiet
        plt.setp(ax.get_xticklabels(), rotation=45, ha="right", rotation_mode="anchor")
        
        # Dodaj wartości w komórkach
        for i in range(len(categories)):
            for j in range(len(months)):
                text = ax.text(j, i, f'{data[i, j]}%', ha="center", va="center", 
                             color="white" if data[i, j] < 50 else "black", fontweight='bold')
        
        # Tytuł i kolorbar
        ax.set_title("Popularność kategorii tras według miesięcy", fontsize=16, fontweight='bold')
        cbar = plt.colorbar(im, ax=ax)
        cbar.set_label('Popularność (%)', rotation=270, labelpad=20)
        
        plt.tight_layout()
        
        # Zapisz wykres
        file_path = os.path.join(self.output_dir, filename)
        plt.savefig(file_path, dpi=300, bbox_inches='tight')
        plt.close()
        
        logger.info(f"Utworzono mapę ciepła sezonowości: {file_path}")
        return file_path
    
    def create_elevation_profile(self, trail_data: Dict[str, Any], filename: str = None) -> str:
        """
        Wykresy liniowe pokazujące profile wysokościowe.
        
        Args:
            trail_data: Dane pojedynczej trasy
            filename: Nazwa pliku do zapisania
            
        Returns:
            Ścieżka do zapisanego wykresu
        """
        if not filename:
            trail_name = trail_data.get('name', 'unknown').replace(' ', '_')
            filename = f"elevation_profile_{trail_name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
        
        # Symulowane dane profilu wysokościowego
        length_km = trail_data.get('length_km', 10)
        elevation_gain = trail_data.get('elevation_gain', 500)
        
        # Generuj symulowany profil
        distance_points = np.linspace(0, length_km, 100)
        # Prosty model: stopniowy wzrost z kilkoma wzniesieniami
        base_elevation = 500
        elevation_profile = base_elevation + (elevation_gain * distance_points / length_km) + \
                          50 * np.sin(distance_points * 3) + \
                          30 * np.sin(distance_points * 7)
        
        # Utwórz wykres
        fig, ax = plt.subplots(figsize=(12, 6))
        
        # Wypełnij obszar pod krzywą
        ax.fill_between(distance_points, elevation_profile, alpha=0.3, color=self.colors['primary'])
        ax.plot(distance_points, elevation_profile, color=self.colors['primary'], linewidth=2)
        
        # Konfiguracja
        ax.set_xlabel('Dystans (km)')
        ax.set_ylabel('Wysokość (m n.p.m.)')
        ax.set_title(f'Profil wysokościowy: {trail_data.get("name", "Nieznana trasa")}', 
                    fontsize=16, fontweight='bold')
        ax.grid(True, alpha=0.3)
        
        # Dodaj informacje o trasie
        info_text = f"Długość: {length_km:.1f} km\n"
        info_text += f"Przewyższenie: {elevation_gain} m\n"
        info_text += f"Maks. wysokość: {max(elevation_profile):.0f} m"
        
        ax.text(0.02, 0.98, info_text, transform=ax.transAxes, fontsize=10,
                verticalalignment='top', bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))
        
        plt.tight_layout()
        
        # Zapisz wykres
        file_path = os.path.join(self.output_dir, filename)
        plt.savefig(file_path, dpi=300, bbox_inches='tight')
        plt.close()
        
        logger.info(f"Utworzono profil wysokościowy: {file_path}")
        return file_path
    
    def create_radar_chart(self, trail_data: Dict[str, Any], filename: str = None) -> str:
        """
        Wykresy radarowe oceniające trasy pod względem różnych kryteriów.
        
        Args:
            trail_data: Dane trasy
            filename: Nazwa pliku do zapisania
            
        Returns:
            Ścieżka do zapisanego wykresu
        """
        if not filename:
            trail_name = trail_data.get('name', 'unknown').replace(' ', '_')
            filename = f"radar_chart_{trail_name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
        
        # Kryteria oceny
        categories = ['Widoki', 'Dostępność', 'Trudność', 'Bezpieczeństwo', 'Oznakowanie', 'Infrastruktura']
        
        # Konwertuj dane trasy na oceny (0-100)
        difficulty = trail_data.get('difficulty', 2)
        length = trail_data.get('length_km', 10)
        rating = trail_data.get('user_rating', 3.5)
        
        # Symulowane oceny na podstawie danych trasy
        values = [
            min(100, rating * 20),  # Widoki
            max(20, 100 - length * 5),  # Dostępność (krótsze = bardziej dostępne)
            difficulty * 30,  # Trudność
            min(100, rating * 18 + 10),  # Bezpieczeństwo
            min(100, rating * 15 + 25),  # Oznakowanie
            min(100, rating * 12 + 30)   # Infrastruktura
        ]
        
        # Dodaj pierwszy punkt na końcu dla zamknięcia wykresu
        values += values[:1]
        
        # Kąty dla każdej kategorii
        angles = [n / float(len(categories)) * 2 * np.pi for n in range(len(categories))]
        angles += angles[:1]
        
        # Utwórz wykres
        fig, ax = plt.subplots(figsize=(10, 10), subplot_kw=dict(projection='polar'))
        
        # Narysuj wykres
        ax.plot(angles, values, 'o-', linewidth=2, label=trail_data.get('name', 'Trasa'), color=self.colors['primary'])
        ax.fill(angles, values, alpha=0.25, color=self.colors['primary'])
        
        # Dodaj etykiety kategorii
        ax.set_xticks(angles[:-1])
        ax.set_xticklabels(categories, fontsize=11)
        
        # Konfiguracja skali
        ax.set_ylim(0, 100)
        ax.set_yticks([20, 40, 60, 80, 100])
        ax.set_yticklabels(['20', '40', '60', '80', '100'], fontsize=9)
        ax.grid(True)
        
        # Tytuł
        plt.title(f'Profil oceny trasy: {trail_data.get("name", "Nieznana trasa")}', 
                 size=16, fontweight='bold', pad=20)
        
        plt.tight_layout()
        
        # Zapisz wykres
        file_path = os.path.join(self.output_dir, filename)
        plt.savefig(file_path, dpi=300, bbox_inches='tight')
        plt.close()
        
        logger.info(f"Utworzono wykres radarowy: {file_path}")
        return file_path
    
    def generate_all_charts(self, trails_data: List[Dict[str, Any]], report_name: str = None) -> Dict[str, str]:
        """
        Generuje wszystkie wykresy dla raportu.
        
        Args:
            trails_data: Lista danych tras
            report_name: Nazwa raportu (używana w nazwach plików)
            
        Returns:
            Słownik z nazwami wykresów i ścieżkami do plików
        """
        if not report_name:
            report_name = f"report_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        charts = {}
        
        logger.info(f"Generowanie wykresów dla raportu: {report_name}")
        
        # Generuj wszystkie typy wykresów
        chart_functions = [
            ('length_histogram', self.create_length_histogram),
            ('category_pie', self.create_category_pie_chart),
            ('rating_bar', self.create_rating_bar_chart),
            ('seasonal_heatmap', self.create_seasonal_heatmap),
        ]
        
        for chart_name, chart_function in chart_functions:
            try:
                filename = f"{report_name}_{chart_name}.png"
                chart_path = chart_function(trails_data, filename)
                if chart_path:
                    charts[chart_name] = chart_path
            except Exception as e:
                logger.error(f"Błąd podczas generowania wykresu {chart_name}: {e}")
        
        # Generuj profil wysokościowy dla pierwszej trasy
        if trails_data:
            try:
                filename = f"{report_name}_elevation_profile.png"
                chart_path = self.create_elevation_profile(trails_data[0], filename)
                if chart_path:
                    charts['elevation_profile'] = chart_path
            except Exception as e:
                logger.error(f"Błąd podczas generowania profilu wysokościowego: {e}")
        
        # Generuj wykres radarowy dla pierwszej trasy
        if trails_data:
            try:
                filename = f"{report_name}_radar_chart.png"
                chart_path = self.create_radar_chart(trails_data[0], filename)
                if chart_path:
                    charts['radar_chart'] = chart_path
            except Exception as e:
                logger.error(f"Błąd podczas generowania wykresu radarowego: {e}")
        
        logger.info(f"Wygenerowano {len(charts)} wykresów dla raportu {report_name}")
        return charts 

#reporters\pdf_report_generator.py

"""
GENERATOR PROFESJONALNYCH RAPORTÓW PDF - MODUŁ TWORZENIA DOKUMENTACJI
====================================================================

Ten moduł zawiera klasę PDFReportGenerator do tworzenia wielostronicowych,
profesjonalnych raportów PDF z rekomendacjami tras turystycznych.

FUNKCJONALNOŚCI:
- Generowanie kompleksowych raportów PDF z wieloma sekcjami
- Automatyczne tworzenie spisu treści i strony tytułowej
- Wbudowane wykresy i wizualizacje danych
- Tabele porównawcze tras z formatowaniem
- Obsługa polskich znaków i czcionek UTF-8
- Profesjonalne nagłówki i stopki na każdej stronie
- Automatyczne numerowanie stron i podrozdziałów

STRUKTURA RAPORTU:
1. Strona tytułowa z metadanymi
2. Spis treści z odnośnikami
3. Podsumowanie wykonawcze
4. Sekcja wykresów i statystyk
5. Szczegółowe opisy tras
6. Tabela porównawcza wszystkich tras

WYMAGANIA: ReportLab, matplotlib, pillow
ZGODNOŚĆ: Implementacja zgodna z wymaganiami updatelist.txt
AUTOR: System Rekomendacji Tras Turystycznych - Etap 4
"""

# ============================================================================
# IMPORTY BIBLIOTEK REPORTLAB - GENEROWANIE PDF
# ============================================================================
from reportlab.lib.pagesizes import letter, A4           # Rozmiary stron
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Image, Table, TableStyle, PageBreak
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle  # Style tekstu
from reportlab.lib.units import inch, cm                 # Jednostki miar
from reportlab.lib import colors                         # Kolory
from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_JUSTIFY  # Wyrównanie tekstu
from reportlab.pdfgen import canvas                      # Canvas do rysowania
from reportlab.pdfbase import pdfmetrics                 # Metryki czcionek
from reportlab.pdfbase.ttfonts import TTFont             # Czcionki TrueType

# ============================================================================
# IMPORTY BIBLIOTEK STANDARDOWYCH
# ============================================================================
from typing import Dict, List, Any, Optional            # Podpowiedzi typów
import logging                                          # System logowania
import os                                               # Operacje systemowe
from datetime import datetime                           # Obsługa dat
import sys                                              # Funkcje systemowe
import inspect                                          # Inspekcja kodu

# Dynamiczny import dla obsługi względnych importów
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
sys.path.insert(0, currentdir)

try:
    from chart_generator import ChartGenerator
except ImportError:
    logger = logging.getLogger(__name__)
    logger.warning("Nie można zaimportować ChartGenerator")
    class ChartGenerator:
        def generate_all_charts(self, trails_data, report_name):
            return {}

# Konfiguracja logowania
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class PDFReportGenerator:
    """
    Klasa do generowania profesjonalnych raportów PDF z rekomendacjami tras turystycznych.
    """
    
    def __init__(self, output_dir: str = "reports"):
        """
        Inicjalizacja generatora raportów PDF.
        
        Args:
            output_dir: Katalog do zapisywania raportów
        """
        self.output_dir = output_dir
        os.makedirs(output_dir, exist_ok=True)
        
        # Inicjalizuj generator wykresów
        self.chart_generator = ChartGenerator()
        
        # Konfiguracja kolorów (musi być przed stylami)
        self.report_colors = {
            'primary': colors.Color(46/255, 134/255, 171/255),      # #2E86AB
            'secondary': colors.Color(162/255, 59/255, 114/255),     # #A23B72
            'success': colors.Color(76/255, 175/255, 80/255),        # #4CAF50
            'warning': colors.Color(255/255, 152/255, 0/255),        # #FF9800
            'danger': colors.Color(244/255, 67/255, 54/255),         # #F44336
            'light_gray': colors.Color(245/255, 245/255, 245/255),   # #F5F5F5
            'dark_gray': colors.Color(33/255, 33/255, 33/255)        # #212121
        }
        
        # Konfiguracja czcionek obsługujących polskie znaki
        self._setup_fonts()
        
        # Konfiguracja stylów (po kolorach)
        self.styles = getSampleStyleSheet()
        self._setup_custom_styles()
    
    def _setup_fonts(self):
        """Konfiguruje czcionki obsługujące polskie znaki dla Windows."""
        try:
            # Rejestruj czcionki systemowe Windows
            try:
                pdfmetrics.registerFont(TTFont('Arial', 'C:/Windows/Fonts/arial.ttf'))
                pdfmetrics.registerFont(TTFont('Arial-Bold', 'C:/Windows/Fonts/arialbd.ttf'))
                pdfmetrics.registerFont(TTFont('Arial-Italic', 'C:/Windows/Fonts/ariali.ttf'))
                self.font_family = 'Arial'
                logger.info("Zarejestrowano czcionki Arial z obsługą polskich znaków")
            except:
                # Fallback do DejaVu Sans jeśli dostępne
                try:
                    pdfmetrics.registerFont(TTFont('DejaVuSans', 'C:/Windows/Fonts/DejaVuSans.ttf'))
                    pdfmetrics.registerFont(TTFont('DejaVuSans-Bold', 'C:/Windows/Fonts/DejaVuSans-Bold.ttf'))
                    self.font_family = 'DejaVuSans'
                    logger.info("Zarejestrowano czcionki DejaVu Sans")
                except:
                    # Próbuj Calibri
                    try:
                        pdfmetrics.registerFont(TTFont('Calibri', 'C:/Windows/Fonts/calibri.ttf'))
                        pdfmetrics.registerFont(TTFont('Calibri-Bold', 'C:/Windows/Fonts/calibrib.ttf'))
                        self.font_family = 'Calibri'
                        logger.info("Zarejestrowano czcionki Calibri")
                    except:
                        self.font_family = 'Helvetica'
                        logger.warning("Używam domyślnych czcionek Helvetica - polskie znaki mogą nie działać")
        except Exception as e:
            self.font_family = 'Helvetica'
            logger.warning(f"Błąd podczas konfiguracji czcionek: {e}")
    
    def _setup_custom_styles(self):
        """Konfiguruje niestandardowe style dla dokumentu."""
        
        # Określ czcionki na podstawie dostępności
        bold_font = f'{self.font_family}-Bold' if self.font_family != 'Helvetica' else 'Helvetica-Bold'
        normal_font = self.font_family
        
        # Styl tytułu głównego
        self.styles.add(ParagraphStyle(
            name='CustomTitle',
            parent=self.styles['Title'],
            fontSize=24,
            spaceAfter=30,
            alignment=TA_CENTER,
            textColor=colors.darkblue,
            fontName=bold_font
        ))
        
        # Styl nagłówków sekcji
        self.styles.add(ParagraphStyle(
            name='SectionHeader',
            parent=self.styles['Heading1'],
            fontSize=16,
            spaceAfter=20,
            spaceBefore=20,
            textColor=colors.darkblue,
            fontName=bold_font
        ))
        
        # Styl podsekcji
        self.styles.add(ParagraphStyle(
            name='SubHeader',
            parent=self.styles['Heading2'],
            fontSize=14,
            spaceAfter=15,
            spaceBefore=15,
            textColor=colors.darkblue,
            fontName=bold_font
        ))
        
        # Styl zwykłego tekstu
        self.styles.add(ParagraphStyle(
            name='CustomNormal',
            parent=self.styles['Normal'],
            fontSize=11,
            spaceAfter=12,
            alignment=TA_JUSTIFY,
            fontName=normal_font
        ))
        
        # Styl dla statystyk
        self.styles.add(ParagraphStyle(
            name='StatStyle',
            parent=self.styles['Normal'],
            fontSize=12,
            spaceAfter=8,
            fontName=bold_font,
            textColor=self.report_colors['primary']
        ))
    
    def _create_header_footer(self, canvas, doc):
        """
        Dodaje nagłówki i stopki do każdej strony.
        
        Args:
            canvas: Canvas ReportLab
            doc: Dokument
        """
        canvas.saveState()
        
        # Nagłówek
        canvas.setFont('Helvetica-Bold', 10)
        canvas.setFillColor(self.report_colors['primary'])
        canvas.drawString(inch, A4[1] - 0.75*inch, 
                         "System Rekomendacji Tras Turystycznych")
        
        # Linia pod nagłówkiem
        canvas.setLineWidth(1)
        canvas.line(inch, A4[1] - 0.9*inch, A4[0] - inch, A4[1] - 0.9*inch)
        
        # Stopka
        canvas.setFont('Helvetica', 9)
        canvas.setFillColor(colors.gray)
        canvas.drawString(inch, 0.75*inch, 
                         f"Wygenerowano: {datetime.now().strftime('%d.%m.%Y %H:%M')}")
        
        # Numer strony
        canvas.drawRightString(A4[0] - inch, 0.75*inch, 
                              f"Strona {doc.page}")
        
        # Linia nad stopką
        canvas.line(inch, inch, A4[0] - inch, inch)
        
        canvas.restoreState()
    
    def _create_title_page(self, trails_data: List[Dict[str, Any]], search_params: Dict[str, Any]) -> List:
        """
        Tworzy stronę tytułową z datą generowania i parametrami wyszukiwania.
        
        Args:
            trails_data: Lista danych tras
            search_params: Parametry wyszukiwania użyte w raporcie
            
        Returns:
            Lista elementów dla strony tytułowej
        """
        story = []
        
        # Tytuł główny
        title = f"Raport Rekomendacji Tras Turystycznych"
        story.append(Paragraph(title, self.styles['CustomTitle']))
        story.append(Spacer(1, 0.5*inch))
        
        # Podtytuł z datą
        subtitle = f"Analiza tras - {datetime.now().strftime('%B %Y')}"
        story.append(Paragraph(subtitle, self.styles['SectionHeader']))
        story.append(Spacer(1, 0.3*inch))
        
        # Parametry wyszukiwania
        story.append(Paragraph("Parametry wyszukiwania:", self.styles['SubHeader']))
        
        search_info = []
        if search_params.get('city'):
            search_info.append(f"Miasto: {search_params['city']}")
        if search_params.get('date'):
            search_info.append(f"Data: {search_params['date']}")
        if search_params.get('difficulty'):
            search_info.append(f"Poziom trudności: {search_params['difficulty']}")
        if search_params.get('category'):
            search_info.append(f"Kategoria: {search_params['category']}")
        if search_params.get('min_length'):
            search_info.append(f"Min. długość: {search_params['min_length']} km")
        if search_params.get('max_length'):
            search_info.append(f"Max. długość: {search_params['max_length']} km")
        
        for info in search_info:
            story.append(Paragraph(f"• {info}", self.styles['CustomNormal']))
        
        story.append(Spacer(1, 0.5*inch))
        
        # Podsumowanie statystyczne
        story.append(Paragraph("Podsumowanie analizy:", self.styles['SubHeader']))
        
        total_trails = len(trails_data)
        avg_length = sum(t.get('length_km', 0) for t in trails_data) / total_trails if total_trails > 0 else 0
        avg_rating = sum(t.get('user_rating', 0) or t.get('rating', 0) for t in trails_data) / total_trails if total_trails > 0 else 0
        
        summary_stats = [
            f"Łączna liczba analizowanych tras: {total_trails}",
            f"Średnia długość trasy: {avg_length:.1f} km",
            f"Średnia ocena użytkowników: {avg_rating:.1f}/5",
            f"Data wygenerowania raportu: {datetime.now().strftime('%d.%m.%Y %H:%M')}"
        ]
        
        for stat in summary_stats:
            story.append(Paragraph(stat, self.styles['StatStyle']))
        
        story.append(PageBreak())
        return story
    
    def _create_table_of_contents(self, trails_data: List[Dict[str, Any]]) -> List:
        """
        Tworzy spis treści z linkami do sekcji.
        
        Args:
            trails_data: Lista danych tras
            
        Returns:
            Lista elementów spisu treści
        """
        story = []
        
        story.append(Paragraph("Spis treści", self.styles['SectionHeader']))
        story.append(Spacer(1, 0.3*inch))
        
        sections = [
            "1. Podsumowanie wykonawcze",
            "2. Analiza wykresowa",
            "3. Rekomendowane trasy",
            "4. Szczegółowe opisy tras",
            "5. Tabela zbiorcza",
            "6. Aneks z danymi źródłowymi"
        ]
        
        for section in sections:
            story.append(Paragraph(section, self.styles['CustomNormal']))
        
        story.append(PageBreak())
        return story
    
    def _create_executive_summary(self, trails_data: List[Dict[str, Any]]) -> List:
        """
        Tworzy podsumowanie wykonawcze z najważniejszymi wnioskami.
        
        Args:
            trails_data: Lista danych tras
            
        Returns:
            Lista elementów podsumowania
        """
        story = []
        
        story.append(Paragraph("1. Podsumowanie wykonawcze", self.styles['SectionHeader']))
        
        # Analiza statystyczna
        total_trails = len(trails_data)
        if total_trails == 0:
            story.append(Paragraph("Brak danych tras do analizy.", self.styles['CustomNormal']))
            story.append(PageBreak())
            return story
        
        # Kategorie tras
        categories = {}
        difficulty_levels = {}
        lengths = []
        ratings = []
        
        for trail in trails_data:
            # Kategorie
            cat = trail.get('category', 'nieskategoryzowana')
            categories[cat] = categories.get(cat, 0) + 1
            
            # Trudność
            diff = trail.get('difficulty', 2)
            difficulty_levels[diff] = difficulty_levels.get(diff, 0) + 1
            
            # Długość i oceny
            if trail.get('length_km'):
                lengths.append(trail['length_km'])
            if trail.get('user_rating') or trail.get('rating'):
                ratings.append(trail.get('user_rating') or trail.get('rating'))
        
        # Najważniejsze wnioski
        most_common_category = max(categories.items(), key=lambda x: x[1]) if categories else ('brak', 0)
        avg_length = sum(lengths) / len(lengths) if lengths else 0
        avg_rating = sum(ratings) / len(ratings) if ratings else 0
        
        summary_text = f"""
        Analiza obejmuje {total_trails} tras turystycznych. Najczęściej występującą kategorią 
        tras jest "{most_common_category[0]}" ({most_common_category[1]} tras). 
        
        Średnia długość analizowanych tras wynosi {avg_length:.1f} km, co wskazuje na 
        {"krótkie, rodzinne trasy" if avg_length < 8 else "średnie trasy rekreacyjne" if avg_length < 15 else "długie, wymagające trasy"}.
        
        Średnia ocena użytkowników to {avg_rating:.1f}/5, co oznacza 
        {"niski poziom zadowolenia" if avg_rating < 3 else "umiarkowany poziom zadowolenia" if avg_rating < 4 else "wysoki poziom zadowolenia"}.
        """
        
        story.append(Paragraph(summary_text, self.styles['CustomNormal']))
        
        # Rekomendacje
        story.append(Paragraph("Kluczowe rekomendacje:", self.styles['SubHeader']))
        
        recommendations = []
        if avg_rating < 3.5:
            recommendations.append("Zaleca się dokładniejszą weryfikację jakości tras przed rekomendacją.")
        if avg_length > 15:
            recommendations.append("Rozważenie dodania krótszych tras dla rodzin z dziećmi.")
        if most_common_category[0] == 'sportowa':
            recommendations.append("Zwiększenie oferty tras widokowych i rekreacyjnych.")
        
        if not recommendations:
            recommendations.append("Obecna oferta tras jest dobrze zrównoważona i odpowiada potrzebom użytkowników.")
        
        for rec in recommendations:
            story.append(Paragraph(f"• {rec}", self.styles['CustomNormal']))
        
        story.append(PageBreak())
        return story
    
    def _create_charts_section(self, trails_data: List[Dict[str, Any]], report_name: str) -> List:
        """
        Tworzy sekcję z wykresami porównawczymi.
        
        Args:
            trails_data: Lista danych tras
            report_name: Nazwa raportu
            
        Returns:
            Lista elementów sekcji wykresów
        """
        story = []
        
        story.append(Paragraph("2. Analiza wykresowa", self.styles['SectionHeader']))
        
        # Generuj wykresy
        charts = self.chart_generator.generate_all_charts(trails_data, report_name)
        
        # Dodaj wykresy do raportu
        chart_descriptions = {
            'length_histogram': 'Histogram przedstawia rozkład długości analizowanych tras.',
            'category_pie': 'Wykres kołowy pokazuje proporcje różnych kategorii tras.',
            'rating_bar': 'Wykres słupkowy przedstawia rozkład ocen użytkowników.',
            'seasonal_heatmap': 'Mapa ciepła pokazuje popularność tras w różnych miesiącach.',
            'elevation_profile': 'Profil wysokościowy przykładowej trasy.',
            'radar_chart': 'Wykres radarowy oceniający trasę pod różnymi względami.'
        }
        
        for chart_name, chart_path in charts.items():
            if os.path.exists(chart_path):
                # Tytuł wykresu
                chart_title = chart_descriptions.get(chart_name, f'Wykres {chart_name}')
                story.append(Paragraph(chart_title, self.styles['SubHeader']))
                
                # Obraz wykresu
                try:
                    img = Image(chart_path, width=6*inch, height=4*inch)
                    story.append(img)
                    story.append(Spacer(1, 0.3*inch))
                except Exception as e:
                    logger.error(f"Błąd podczas dodawania wykresu {chart_name}: {e}")
                    story.append(Paragraph(f"Błąd podczas ładowania wykresu: {chart_name}", 
                                         self.styles['CustomNormal']))
        
        story.append(PageBreak())
        return story
    
    def _create_detailed_routes_section(self, trails_data: List[Dict[str, Any]]) -> List:
        """
        Tworzy szczegółowe opisy rekomendowanych tras.
        
        Args:
            trails_data: Lista danych tras
            
        Returns:
            Lista elementów szczegółowych opisów
        """
        story = []
        
        story.append(Paragraph("4. Szczegółowe opisy tras", self.styles['SectionHeader']))
        
        # Ograniczenie do top 10 tras
        top_trails = trails_data[:10]
        
        for i, trail in enumerate(top_trails, 1):
            # Nagłówek trasy
            trail_name = trail.get('name', f'Trasa {i}')
            story.append(Paragraph(f"{i}. {trail_name}", self.styles['SubHeader']))
            
            # Podstawowe informacje
            info_data = []
            if trail.get('length_km'):
                info_data.append(['Długość:', f"{trail['length_km']:.1f} km"])
            if trail.get('difficulty'):
                info_data.append(['Trudność:', f"{trail['difficulty']}/3"])
            if trail.get('terrain_type'):
                info_data.append(['Typ terenu:', trail['terrain_type']])
            if trail.get('estimated_time'):
                hours = int(trail['estimated_time'])
                minutes = int((trail['estimated_time'] - hours) * 60)
                if hours > 0 and minutes > 0:
                    time_str = f"{hours}h {minutes}min"
                elif hours > 0:
                    time_str = f"{hours}h"
                else:
                    time_str = f"{minutes}min"
                info_data.append(['Czas przejścia:', time_str])
            if trail.get('user_rating') or trail.get('rating'):
                rating = trail.get('user_rating') or trail.get('rating')
                # Używamy prostego tekstu zamiast symboli
                rating_text = f"{rating:.1f}/5"
                if rating >= 4.5:
                    rating_text += " (Doskonała)"
                elif rating >= 4.0:
                    rating_text += " (Bardzo dobra)"
                elif rating >= 3.0:
                    rating_text += " (Dobra)"
                elif rating >= 2.0:
                    rating_text += " (Przeciętna)"
                else:
                    rating_text += " (Słaba)"
                info_data.append(['Ocena użytkowników:', rating_text])
            if trail.get('category'):
                info_data.append(['Kategoria:', trail['category']])
            if trail.get('comfort_index'):
                info_data.append(['Indeks komfortu:', f"{trail['comfort_index']:.1f}/100"])
            
            if info_data:
                info_table = Table(info_data, colWidths=[2*inch, 3*inch])
                # Określ czcionki dla tabeli
                table_bold_font = f'{self.font_family}-Bold' if self.font_family != 'Helvetica' else 'Helvetica-Bold'
                table_normal_font = self.font_family
                
                info_table.setStyle(TableStyle([
                    ('BACKGROUND', (0, 0), (0, -1), self.report_colors['light_gray']),
                    ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
                    ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                    ('FONTNAME', (0, 0), (0, -1), table_bold_font),
                    ('FONTNAME', (1, 0), (1, -1), table_normal_font),
                    ('FONTSIZE', (0, 0), (-1, -1), 10),
                    ('GRID', (0, 0), (-1, -1), 1, colors.black),
                ]))
                story.append(info_table)
                story.append(Spacer(1, 0.2*inch))
            
            # Opis trasy
            if trail.get('description'):
                story.append(Paragraph("Opis:", self.styles['CustomNormal']))
                story.append(Paragraph(trail['description'][:500] + "..." if len(trail['description']) > 500 else trail['description'], 
                                     self.styles['CustomNormal']))
            
            # Recenzje (jeśli są)
            if trail.get('reviews') and len(trail['reviews']) > 0:
                story.append(Paragraph("Przykładowe recenzje:", self.styles['CustomNormal']))
                for review in trail['reviews'][:3]:  # Max 3 recenzje
                    story.append(Paragraph(f"• {review[:200]}{'...' if len(review) > 200 else ''}", 
                                         self.styles['CustomNormal']))
            
            story.append(Spacer(1, 0.3*inch))
        
        story.append(PageBreak())
        return story
    
    def _create_summary_table(self, trails_data: List[Dict[str, Any]]) -> List:
        """
        Tworzy tabelę zbiorczą wszystkich analizowanych tras.
        
        Args:
            trails_data: Lista danych tras
            
        Returns:
            Lista elementów tabeli zbiorczej
        """
        story = []
        
        story.append(Paragraph("5. Tabela zbiorcza tras", self.styles['SectionHeader']))
        
        # Nagłówki tabeli
        headers = ['Lp.', 'Nazwa trasy', 'Długość (km)', 'Trudność', 'Ocena', 'Kategoria']
        
        # Dane tabeli
        table_data = [headers]
        for i, trail in enumerate(trails_data[:20], 1):  # Max 20 tras w tabeli
            row = [
                str(i),
                trail.get('name', 'Nieznana')[:30] + '...' if len(trail.get('name', '')) > 30 else trail.get('name', 'Nieznana'),
                f"{trail.get('length_km', 0):.1f}" if trail.get('length_km') else 'N/A',
                f"{trail.get('difficulty', 'N/A')}/3" if trail.get('difficulty') else 'N/A',
                f"{trail.get('user_rating') or trail.get('rating', 0):.1f}/5" if trail.get('user_rating') or trail.get('rating') else 'N/A',
                trail.get('category', 'N/A')
            ]
            table_data.append(row)
        
        # Utwórz tabelę
        table = Table(table_data, colWidths=[0.5*inch, 2.5*inch, 1*inch, 1*inch, 1*inch, 1.5*inch])
        # Określ czcionki dla tabeli
        table_bold_font = f'{self.font_family}-Bold' if self.font_family != 'Helvetica' else 'Helvetica-Bold'
        table_normal_font = self.font_family
        
        table.setStyle(TableStyle([
            # Nagłówek
            ('BACKGROUND', (0, 0), (-1, 0), self.report_colors['primary']),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), table_bold_font),
            ('FONTSIZE', (0, 0), (-1, 0), 10),
            
            # Zawartość
            ('FONTNAME', (0, 1), (-1, -1), table_normal_font),
            ('FONTSIZE', (0, 1), (-1, -1), 9),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
            
            # Naprzemienne kolory wierszy
            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, self.report_colors['light_gray']]),
        ]))
        
        story.append(table)
        story.append(PageBreak())
        return story
    
    def generate_pdf_report(self, trails_data: List[Dict[str, Any]], 
                          search_params: Dict[str, Any] = None, 
                          filename: str = None) -> str:
        """
        Główna metoda generująca kompletny raport PDF.
        
        Args:
            trails_data: Lista danych tras
            search_params: Parametry wyszukiwania
            filename: Nazwa pliku PDF
            
        Returns:
            Ścieżka do wygenerowanego pliku PDF
        """
        if not filename:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"raport_tras_{timestamp}.pdf"
        
        if not search_params:
            search_params = {}
        
        file_path = os.path.join(self.output_dir, filename)
        
        logger.info(f"Generowanie raportu PDF: {filename}")
        
        # Utwórz dokument
        doc = SimpleDocTemplate(
            file_path,
            pagesize=A4,
            rightMargin=72,
            leftMargin=72,
            topMargin=72,
            bottomMargin=72
        )
        
        # Zbierz wszystkie elementy dokumentu
        story = []
        
        # Nazwa raportu dla wykresów
        report_name = filename.replace('.pdf', '')
        
        try:
            # 1. Strona tytułowa
            story.extend(self._create_title_page(trails_data, search_params))
            
            # 2. Spis treści
            story.extend(self._create_table_of_contents(trails_data))
            
            # 3. Podsumowanie wykonawcze
            story.extend(self._create_executive_summary(trails_data))
            
            # 4. Sekcja wykresów
            story.extend(self._create_charts_section(trails_data, report_name))
            
            # 5. Szczegółowe opisy tras
            story.extend(self._create_detailed_routes_section(trails_data))
            
            # 6. Tabela zbiorcza
            story.extend(self._create_summary_table(trails_data))
            
            # Zbuduj dokument
            doc.build(story, onFirstPage=self._create_header_footer, 
                     onLaterPages=self._create_header_footer)
            
            logger.info(f"Raport PDF został pomyślnie wygenerowany: {file_path}")
            return file_path
            
        except Exception as e:
            logger.error(f"Błąd podczas generowania raportu PDF: {e}")
            raise

#sql\schema.sql

-- Schema bazy danych dla Systemu Rekomendacji Tras Turystycznych
-- Etap 4: Integracja z bazą danych SQLite

-- Tabela tras turystycznych
CREATE TABLE IF NOT EXISTS routes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    region TEXT,
    start_lat REAL NOT NULL,
    start_lon REAL NOT NULL,
    end_lat REAL NOT NULL,
    end_lon REAL NOT NULL,
    length_km REAL,
    elevation_gain INTEGER,
    difficulty INTEGER CHECK (difficulty BETWEEN 1 AND 5),
    terrain_type TEXT,
    tags TEXT,
    description TEXT,
    category TEXT DEFAULT 'sportowa',
    estimated_time REAL,
    user_rating REAL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Tabela danych pogodowych
CREATE TABLE IF NOT EXISTS weather_data (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    date DATE NOT NULL,
    location_lat REAL NOT NULL,
    location_lon REAL NOT NULL,
    avg_temp REAL,
    min_temp REAL,
    max_temp REAL,
    precipitation REAL,
    sunshine_hours REAL,
    cloud_cover INTEGER,
    wind_speed REAL,
    humidity INTEGER,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(date, location_lat, location_lon)
);

-- Tabela preferencji użytkownika
CREATE TABLE IF NOT EXISTS user_preferences (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_name TEXT DEFAULT 'default',
    preferred_temp_min REAL DEFAULT 15.0,
    preferred_temp_max REAL DEFAULT 25.0,
    max_precipitation REAL DEFAULT 5.0,
    max_difficulty INTEGER DEFAULT 3,
    max_length_km REAL DEFAULT 20.0,
    preferred_terrain_types TEXT DEFAULT 'górski,leśny',
    preferred_categories TEXT DEFAULT 'sportowa,widokowa',
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Tabela recenzji tras
CREATE TABLE IF NOT EXISTS route_reviews (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    route_id INTEGER NOT NULL,
    review_text TEXT NOT NULL,
    rating REAL CHECK (rating BETWEEN 1.0 AND 5.0),
    sentiment TEXT CHECK (sentiment IN ('positive', 'negative', 'neutral')),
    season TEXT,
    aspects TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (route_id) REFERENCES routes(id) ON DELETE CASCADE
);

-- Tabela historii rekomendacji
CREATE TABLE IF NOT EXISTS recommendation_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_name TEXT DEFAULT 'default',
    search_criteria TEXT,
    recommended_routes TEXT,
    search_date DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Indeksy dla wydajności
CREATE INDEX IF NOT EXISTS idx_routes_region ON routes(region);
CREATE INDEX IF NOT EXISTS idx_routes_difficulty ON routes(difficulty);
CREATE INDEX IF NOT EXISTS idx_routes_category ON routes(category);
CREATE INDEX IF NOT EXISTS idx_routes_terrain ON routes(terrain_type);
CREATE INDEX IF NOT EXISTS idx_weather_date ON weather_data(date);
CREATE INDEX IF NOT EXISTS idx_weather_location ON weather_data(location_lat, location_lon);
CREATE INDEX IF NOT EXISTS idx_reviews_route ON route_reviews(route_id);
CREATE INDEX IF NOT EXISTS idx_reviews_sentiment ON route_reviews(sentiment);

-- Triggery do automatycznej aktualizacji timestamp
CREATE TRIGGER IF NOT EXISTS update_routes_timestamp 
    AFTER UPDATE ON routes
    FOR EACH ROW
    BEGIN
        UPDATE routes SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
    END;

CREATE TRIGGER IF NOT EXISTS update_preferences_timestamp 
    AFTER UPDATE ON user_preferences
    FOR EACH ROW
    BEGIN
        UPDATE user_preferences SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
    END; 

#utils\__init__.py

"""
Utility functions and classes for the trail recommendation system.
"""

from .data_storage import DataStorage

__all__ = ['DataStorage'] 

#utils\data_storage.py

import json
import os
from datetime import datetime, timedelta
from typing import Dict, Any, Optional, List

class DataStorage:
    """Klasa do zarządzania przechowywaniem danych w plikach cache."""

    def __init__(self, data_dir: str = "data"):
        """Inicjalizuje obiekt DataStorage z określonym katalogiem danych."""
        self._data_dir = data_dir
        if not os.path.exists(data_dir):
            os.makedirs(data_dir)

    @property
    def data_dir(self) -> str:
        """Zwraca ścieżkę do katalogu z danymi."""
        return self._data_dir

    def _get_cache_path(self, filename: str) -> str:
        """Pobiera pełną ścieżkę do pliku cache."""
        return os.path.join(self._data_dir, filename)

    def save_data(self, filename: str, data: Dict[str, Any]) -> None:
        """Zapisuje dane do pliku JSON w określonym katalogu."""
        filepath = self._get_cache_path(filename)
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=4)

    def load_data(self, filename: str) -> Dict[str, Any]:
        """Wczytuje dane z pliku JSON z określonego katalogu."""
        filepath = self._get_cache_path(filename)
        if not os.path.exists(filepath):
            return {}
        with open(filepath, 'r', encoding='utf-8') as f:
            return json.load(f)

    def append_data(self, filename: str, new_data: Dict[str, Any]) -> None:
        """Dodaje nowe dane do istniejącego pliku JSON."""
        existing_data = self.load_data(filename)
        existing_data.update(new_data)
        self.save_data(filename, existing_data)

    def clear_data(self, filename: str) -> None:
        """Czyści dane w pliku JSON."""
        self.save_data(filename, {})

    def get_all_files(self) -> List[str]:
        """Zwraca listę wszystkich plików w katalogu danych."""
        return [f for f in os.listdir(self._data_dir) if f.endswith('.json')]

    def save_data_to_cache(self, data: Any, filename: str) -> None:
        """Zapisuje dane do pliku JSON, łącząc z istniejącymi danymi jeśli są obecne."""
        filepath = self._get_cache_path(filename)
        
        # Próba wczytania istniejących danych
        existing_data = {}
        if os.path.exists(filepath):
            try:
                with open(filepath, 'r', encoding='utf-8') as f:
                    existing_data = json.load(f)
            except json.JSONDecodeError:
                pass

        # Przygotowanie nowego wpisu danych
        new_entry = {
            'timestamp': datetime.now().isoformat(),
            'data': data
        }

        # Jeśli plik istnieje i zawiera listę, dodaj nowe dane
        if isinstance(existing_data.get('data'), list):
            existing_data['data'] = data  # Nadpisz stare dane nowymi
        else:
            existing_data = new_entry

        # Zapisz zaktualizowane dane
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(existing_data, f, ensure_ascii=False, indent=2)

    def load_data_from_cache(self, filename: str, max_age_hours: Optional[int] = None) -> Optional[Any]:
        """Wczytuje dane z pliku JSON jeśli istnieje i nie jest zbyt stary."""
        filepath = self._get_cache_path(filename)
        
        if not os.path.exists(filepath):
            return None

        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                cached = json.load(f)

            if max_age_hours is not None:
                cache_time = datetime.fromisoformat(cached['timestamp'])
                if datetime.now() - cache_time > timedelta(hours=max_age_hours):
                    return None

            return cached['data']
        except (json.JSONDecodeError, KeyError, ValueError):
            return None

    def clear_cache(self, filename: str = None) -> None:
        """Czyści pliki cache. Jeśli filename jest None, czyści wszystkie pliki cache."""
        if filename:
            filepath = self._get_cache_path(filename)
            if os.path.exists(filepath):
                os.remove(filepath)
        else:
            for file in os.listdir(self._data_dir):
                if file.endswith('.json'):
                    os.remove(os.path.join(self._data_dir, file))

    def merge_json_files(self, output_file: str = "all_data.json") -> None:
        """Łączy wszystkie pliki JSON w katalogu cache w jeden plik."""
        all_data = {
            'timestamp': datetime.now().isoformat(),
            'trails': [],
            'weather': {}
        }

        for filename in os.listdir(self._data_dir):
            if not filename.endswith('.json'):
                continue

            filepath = self._get_cache_path(filename)
            try:
                with open(filepath, 'r', encoding='utf-8') as f:
                    file_data = json.load(f)

                if filename.startswith('trails_'):
                    # Dodaj dane o szlakach
                    if isinstance(file_data.get('data'), list):
                        all_data['trails'].extend(file_data['data'])
                elif filename.startswith('weather_'):
                    # Dodaj dane pogodowe
                    city = filename[8:-5]  # Usuń 'weather_' i '.json'
                    if file_data.get('data'):
                        all_data['weather'][city] = file_data['data']

            except (json.JSONDecodeError, KeyError):
                continue

        # Zapisz połączone dane
        output_path = self._get_cache_path(output_file)
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(all_data, f, ensure_ascii=False, indent=2)

#utils\export_results.py

from typing import Dict, List, Any
import json
import csv
from datetime import datetime

class ResultExporter:
    """
    Klasa odpowiedzialna za eksport wyników rekomendacji do różnych formatów.
    
    Obsługiwane formaty:
    - TXT: Czytelny format tekstowy z pełnymi opisami
    - JSON: Format do dalszego przetwarzania danych
    - CSV: Format tabelaryczny do analizy w arkuszach kalkulacyjnych
    
    Każdy format zawiera:
    - Dane podstawowe szlaku (nazwa, długość, trudność)
    - Dane pogodowe (jeśli dostępne)
    - Obliczone wartości (indeks komfortu, ocena ważona)
    """
    @staticmethod
    def export_results(
        trails_by_city: Dict[str, List[Dict[str, Any]]], 
        date: str,
        weather_by_city: Dict[str, Dict[str, Any]]
    ):
        """
        Eksportuje wyniki rekomendacji do różnych formatów plików.
        
        Args:
            trails_by_city: Słownik z trasami dla każdego miasta {miasto: [trasy]}
            date: Data, dla której generowane są rekomendacje
            weather_by_city: Słownik z danymi pogodowymi dla każdego miasta
        """
        try:
            # Generuj timestamp raz dla wszystkich plików
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            
            # Zapisz do TXT
            ResultExporter._save_to_txt(trails_by_city, date, weather_by_city)
            
            # Zapisz do JSON
            ResultExporter._save_to_json(trails_by_city, date, weather_by_city)
            
            # Zapisz do CSV z timestampem
            ResultExporter._save_to_csv(trails_by_city, date, weather_by_city, timestamp)
        except Exception as e:
            print(f"Błąd podczas eksportu wyników: {e}")    @staticmethod
    def _save_to_txt(trails_by_city: Dict[str, List[Dict[str, Any]]], 
                     date: str,
                     weather_by_city: Dict[str, Dict[str, Any]],
                     timestamp: str = None):
        """
        Zapisuje rekomendacje do pliku TXT.
        
        Args:
            trails_by_city: Słownik tras pogrupowanych według miast
            date: Data dla której generowane są rekomendacje
            weather_by_city: Dane pogodowe dla każdego miasta
            timestamp: Opcjonalny znacznik czasowy do nazwy pliku
        """
        if timestamp is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"recommendations_{timestamp}.txt"
        try:
            with open(filename, "w", encoding="utf-8") as f:
                f.write(f"=== Rekomendacje szlaków na dzień {date} ===\n")
                f.write(f"Data wygenerowania: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")

                # Dla każdego miasta
                for city, trails in trails_by_city.items():
                    f.write(f"=== {city} ===\n")
                    weather = weather_by_city.get(city, {})
                    
                    if weather:
                        f.write("\nDane pogodowe:\n")
                        f.write(f"Temperatura: {weather.get('temperature_min', 'N/A')}°C - {weather.get('temperature_max', 'N/A')}°C\n")
                        f.write(f"Średnia temperatura: {weather.get('temperature_avg', 'N/A')}°C\n")
                        f.write(f"Opady: {weather.get('precipitation', 'N/A')} mm\n")
                        f.write(f"Zachmurzenie: {weather.get('cloud_cover', 'N/A')}%\n")
                        f.write(f"Godziny słoneczne: {weather.get('sunshine_hours', 'N/A')} h\n")
                        f.write(f"Prędkość wiatru: {weather.get('wind_speed', 'N/A')} km/h\n\n")
                    
                    if not trails:
                        f.write("Nie znaleziono tras spełniających kryteria.\n")
                    else:
                        f.write(f"\nZnaleziono {len(trails)} tras:\n")
                        for i, trail in enumerate(trails, 1):
                            f.write(f"\n{i}. {trail['name']}\n")
                            f.write(f"   Miasto: {trail.get('region', city)}\n")
                            f.write(f"   Długość: {trail.get('length_km', 'N/A')} km\n")
                            f.write(f"   Poziom trudności: {trail.get('difficulty', 'N/A')}/3\n")
                            f.write(f"   Typ terenu: {trail.get('terrain_type', 'N/A')}\n")
                            f.write(f"   Kategoria: {trail.get('category', 'nieskategoryzowana').upper()}\n")
                            if 'comfort_index' in trail:
                                f.write(f"   Indeks komfortu: {trail['comfort_index']}/100\n")
                            if 'weighted_score' in trail:
                                f.write(f"   Wynik ważony: {trail['weighted_score']}/100\n")
                            if 'description' in trail:
                                f.write(f"   Opis: {trail['description']}\n")
                            if 'estimated_time' in trail:
                                hours = int(trail['estimated_time'])
                                minutes = int((trail['estimated_time'] - hours) * 60)
                                if hours > 0 and minutes > 0:
                                    f.write(f"   Szacowany czas przejścia: {hours}h {minutes}min\n")
                                elif hours > 0:
                                    f.write(f"   Szacowany czas przejścia: {hours}h\n")
                                else:
                                    f.write(f"   Szacowany czas przejścia: {minutes}min\n")
                    f.write("\n" + "="*50 + "\n")
                
            print(f"\nRekomendacje zostały zapisane do pliku {filename}")
            
        except Exception as e:
            print(f"Błąd podczas zapisywania do pliku TXT: {e}")
    @staticmethod
    def _save_to_json(trails_by_city: Dict[str, List[Dict[str, Any]]], 
                     date: str,
                     weather_by_city: Dict[str, Dict[str, Any]],
                     timestamp: str = None):
        """Zapisuje rekomendacje do pliku JSON."""
        try:
            if timestamp is None:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            data = {
                "metadata": {
                    "date": date,
                    "generated_at": datetime.now().isoformat()
                },
                "cities": {}
            }
            
            for city in trails_by_city:
                data["cities"][city] = {
                    "weather": weather_by_city.get(city, {}),
                    "trails": trails_by_city[city]
                }
            
            filename = f"recommendations_{timestamp}.json"
            with open(filename, "w", encoding="utf-8") as f:
                json.dump(data, f, ensure_ascii=False, indent=4)
                
            print(f"Rekomendacje zostały zapisane do pliku {filename}")
            
        except Exception as e:
            print(f"Błąd podczas zapisywania do pliku JSON: {e}")
    
    @staticmethod
    def _save_to_csv(trails_by_city: Dict[str, List[Dict[str, Any]]], 
                     date: str,
                     weather_by_city: Dict[str, Dict[str, Any]],
                     timestamp: str):
        """Zapisuje rekomendacje do pliku CSV."""
        try:
            filename = f"recommendations_{timestamp}.csv"
            with open(filename, "w", newline='', encoding="utf-8") as f:
                writer = csv.writer(f)
                
                # Zapisz nagłówki
                headers = ["Miasto", "Nazwa", "Długość (km)", "Trudność", "Typ terenu", 
                          "Kategoria", "Indeks komfortu", "Wynik ważony", "Szacowany czas"]
                writer.writerow(headers)
                
                # Zapisz dane tras dla wszystkich miast
                for city, trails in trails_by_city.items():
                    for trail in trails:
                        row = [
                            city,
                            trail.get('name', ''),
                            trail.get('length_km', ''),
                            f"{trail.get('difficulty', '')}/3",
                            trail.get('terrain_type', ''),
                            trail.get('category', '').upper(),
                            f"{trail.get('comfort_index', '')}/100" if 'comfort_index' in trail else '',
                            f"{trail.get('weighted_score', '')}/100" if 'weighted_score' in trail else '',
                            ResultExporter._format_time(trail.get('estimated_time', 0))
                        ]
                        writer.writerow(row)
                    
            print(f"Rekomendacje zostały zapisane do pliku {filename}")
            
        except Exception as e:
            print(f"Błąd podczas zapisywania do pliku CSV: {e}")

    @staticmethod
    def _format_time(time_in_hours: float) -> str:
        """Formatuje czas z godzin na format 'Xh Ymin'."""
        if not time_in_hours:
            return ""
        hours = int(time_in_hours)
        minutes = int((time_in_hours - hours) * 60)
        if hours > 0 and minutes > 0:
            return f"{hours}h {minutes}min"
        elif hours > 0:
            return f"{hours}h"
        else:
            return f"{minutes}min"

#utils\filters.py

from typing import List, Dict, Any, Callable, Optional
from functools import reduce

class BaseFilter:
    """Bazowa klasa dla filtrów."""
    
    @staticmethod
    def apply_filters(items: List[Dict[str, Any]], 
                     filters: List[Callable]) -> List[Dict[str, Any]]:
        """Aplikuje listę filtrów do listy elementów."""
        return reduce(
            lambda items, filter_func: list(filter(filter_func, items)),
            filters,
            items
        )

class TrailsFilter(BaseFilter):
    """Klasa do filtrowania szlaków turystycznych."""

    @classmethod
    def filter_by_criteria(cls,
                         trails: List[Dict[str, Any]],
                         region: Optional[str] = None,
                         min_length: Optional[float] = None,
                         max_length: Optional[float] = None,
                         difficulty: Optional[int] = None,
                         terrain_type: Optional[str] = None) -> List[Dict[str, Any]]:
        """Filtruje szlaki na podstawie wielu kryteriów używając programowania funkcyjnego."""
        filter_functions = []
        
        if region:
            filter_functions.append(
                lambda trail: trail['region'].lower() == region.lower()
            )
            
        if min_length is not None:
            filter_functions.append(
                lambda trail: trail['length_km'] >= min_length
            )
            
        if max_length is not None:
            filter_functions.append(
                lambda trail: trail['length_km'] <= max_length
            )
            
        if difficulty is not None:
            filter_functions.append(
                lambda trail: trail['difficulty'] == difficulty
            )
            
        if terrain_type is not None:
            filter_functions.append(
                lambda trail: trail.get('terrain_type', '').lower() == terrain_type.lower()
            )
            
        return cls.apply_filters(trails, filter_functions)
    
    @classmethod
    def filter_by_weather(cls,
                         trails: List[Dict[str, Any]],
                         weather: Dict[str, Any],
                         max_precipitation: Optional[float] = None,
                         min_temperature: Optional[float] = None,
                         max_temperature: Optional[float] = None,
                         min_sunshine: Optional[float] = None) -> List[Dict[str, Any]]:
        """Filtruje szlaki na podstawie warunków pogodowych."""
        filter_functions = []
        
        if max_precipitation is not None:
            filter_functions.append(
                lambda _: weather.get('precipitation', 0) <= max_precipitation
            )
            
        if min_temperature is not None:
            filter_functions.append(
                lambda _: weather.get('temperature_min', 0) >= min_temperature
            )
            
        if max_temperature is not None:
            filter_functions.append(
                lambda _: weather.get('temperature_max', 0) <= max_temperature
            )
            
        if min_sunshine is not None:
            filter_functions.append(
                lambda _: weather.get('sunshine_hours', 0) >= min_sunshine
            )
            
        return cls.apply_filters(trails, filter_functions)

#utils\statistics.py

from typing import List, Dict, Any
from functools import reduce

class WeatherStatistics:
    """Klasa do obliczania statystyk pogodowych."""
    
    @staticmethod
    def calculate_stats(weather_data: List[Dict[str, float]]) -> Dict[str, float]:
        """Oblicza statystyki pogodowe używając funkcji reduce."""
        if not weather_data:
            return {
                "avg_temp": 0.0,
                "total_precipitation": 0.0,
                "sunshine_hours": 0.0
            }

        count = len(weather_data)
        
        # Obliczanie średniej temperatury używając reduce
        total_temp = reduce(lambda acc, x: acc + x['temperature'], weather_data, 0.0)
        avg_temp = total_temp / count

        # Obliczanie całkowitych opadów używając reduce
        total_precipitation = reduce(lambda acc, x: acc + x['precipitation'], weather_data, 0.0)

        # Obliczanie średniej liczby godzin słonecznych używając reduce
        total_sunshine = reduce(lambda acc, x: acc + x['sunshine_hours'], weather_data, 0.0)
        avg_sunshine = total_sunshine / count

        return {
            "avg_temp": round(avg_temp, 2),
            "total_precipitation": round(total_precipitation, 2),
            "sunshine_hours": round(avg_sunshine, 2)
        }
        
    @staticmethod
    def calculate_region_stats(trails: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Oblicza statystyki dla szlaków w danym regionie."""
        if not trails:
            return {
                "avg_length": 0.0,
                "avg_difficulty": 0.0,
                "total_trails": 0
            }
            
        count = len(trails)
        total_length = reduce(lambda acc, x: acc + x.get('length_km', 0), trails, 0.0)
        total_difficulty = reduce(lambda acc, x: acc + x.get('difficulty', 0), trails, 0.0)
        
        return {
            "avg_length": round(total_length / count, 2),
            "avg_difficulty": round(total_difficulty / count, 2),
            "total_trails": count
        }

#utils\storage.py

from typing import List, Dict, Any, Optional
import json
from datetime import datetime
import os

class BaseStorage:
    """Bazowa klasa dla przechowywania danych."""
    
    def __init__(self, directory: str):
        self._directory = directory
        if not os.path.exists(directory):
            os.makedirs(directory)
            
    def _get_file_path(self, filename: str) -> str:
        """Pobiera pełną ścieżkę do pliku."""
        return os.path.join(self._directory, filename)
        
    def save_json(self, data: Dict[str, Any], filename: str) -> None:
        """Zapisuje dane w formacie JSON."""
        try:
            filepath = self._get_file_path(filename)
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            print(f"Błąd podczas zapisywania danych JSON: {e}")
            
    def load_json(self, filename: str) -> Optional[Dict[str, Any]]:
        """Wczytuje dane z pliku JSON."""
        try:
            filepath = self._get_file_path(filename)
            with open(filepath, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            print(f"Błąd podczas wczytywania danych JSON: {e}")
            return None

class ResultStorage(BaseStorage):
    """Klasa do przechowywania wyników rekomendacji."""
    
    def __init__(self, output_file: str = 'result.txt'):
        super().__init__(os.path.dirname(output_file) or '.')
        self._output_file = output_file
    
    def save_trails_to_file(self, trails: List[Dict[str, Any]], region: str, 
                           weather: Optional[Dict[str, Any]] = None) -> None:
        """
        Zapisuje rekomendowane trasy do pliku wynikowego.
        
        Args:
            trails: Lista słowników z trasami
            region: Nazwa wybranego regionu
            weather: Opcjonalny słownik z danymi pogodowymi
        """
        try:
            with open(self._output_file, 'w', encoding='utf-8') as f:
                f.write(f"=== Rekomendacje szlaków dla regionu {region} ===\n")
                f.write(f"Data wygenerowania: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
                
                if weather:
                    from utils.weather_utils import WeatherUtils
                    comfort_index = WeatherUtils.calculate_hiking_comfort(weather)
                    
                    f.write("Warunki pogodowe:\n")
                    f.write(f"  Temperatura: {weather.get('temperature', 'brak danych')}°C\n")
                    f.write(f"  Opady: {weather.get('precipitation', 'brak danych')} mm\n")
                    f.write(f"  Godziny słoneczne: {weather.get('sunshine_hours', 'brak danych')}\n")
                    f.write(f"  Indeks komfortu wędrówki: {comfort_index}/100\n\n")
                
                if not trails:
                    f.write("Nie znaleziono szlaków spełniających podane kryteria.\n")
                    return
                    
                for i, trail in enumerate(trails, 1):
                    f.write(f"\n{i}. {trail['name']}\n")
                    f.write(f"   Długość: {trail.get('length_km', 'brak danych')} km\n")
                    f.write(f"   Trudność: {trail.get('difficulty', 'brak danych')}/3\n")
                    f.write(f"   Przewidywany czas przejścia: {trail.get('estimated_time', 'brak danych')} godz.\n")
                    f.write(f"   Przewyższenie: {trail.get('elevation', 'brak danych')} m\n")
                    if trail.get('description'):
                        f.write(f"   Opis: {trail['description']}\n")
                    
                f.write(f"\nŁącznie znaleziono {len(trails)} tras spełniających kryteria.\n")
                
        except Exception as e:
            print(f"Błąd podczas zapisywania wyników do pliku: {e}")

def save_results_to_file(trails: List[Dict[str, Any]], region: str, 
                        weather: Optional[Dict[str, Any]] = None,
                        output_file: str = 'result.txt') -> None:
    """Funkcja pomocnicza do zapisywania wyników."""
    storage = ResultStorage(output_file)
    storage.save_trails_to_file(trails, region, weather)

#utils\time_calculator.py

from typing import Dict, Any

class TimeCalculator:
    """
    Klasa do obliczania szacowanego czasu przejścia trasy.
    
    Uwzględnia następujące czynniki:
    - Długość trasy
    - Przewyższenie
    - Typ terenu
    - Trudność szlaku
    - Warunki pogodowe
    
    Bazowa prędkość marszu: 4 km/h
    Modyfikatory:
    - Trudny teren: -1 km/h
    - Duże przewyższenie: -0.5 km/h
    - Złe warunki pogodowe: -0.5 km/h
    """
    
    @staticmethod
    def calculate_time(trail: Dict[str, Any]) -> float:
        """
        Oblicza szacowany czas przejścia trasy w godzinach.
        
        Algorytm:
        1. Ustal bazową prędkość
        2. Zastosuj modyfikatory terenu
        3. Zastosuj modyfikatory trudności
        4. Uwzględnij przewyższenie
        5. Oblicz finalny czas
        
        Args:
            trail: Słownik z danymi trasy zawierający:
                - length_km: długość trasy
                - difficulty: poziom trudności (1-3)
                - terrain_type: typ terenu
                - elevation_m: przewyższenie (opcjonalne)
                
        Returns:
            float: Szacowany czas w godzinach
        """
        # Bazowa prędkość: 4 km/h
        base_speed = 4.0

        # Modyfikatory prędkości bazowej
        terrain_modifiers = {            'górski': -1.0,   # Góry
            'pagórkowaty': -0.5,  # Pagórki
            'leśny': -0.2,    # Las
            'mieszany': -0.3, # Mieszany
            'urban': 0.0,     # Miejski
            'riverside': 0.0  # Nadrzeczny
        }

        # Korekta prędkości ze względu na teren
        terrain_type = trail.get('terrain_type', 'mixed').lower()
        speed = base_speed + terrain_modifiers.get(terrain_type, 0)

        # Korekta ze względu na trudność
        difficulty = trail.get('difficulty', 1)
        if difficulty > 1:
            speed -= (difficulty - 1) * 0.5

        # Korekta ze względu na przewyższenie
        elevation = trail.get('elevation_m', 0)
        if elevation > 500:
            speed -= 0.5
        elif elevation > 1000:
            speed -= 1.0

        # Oblicz czas w godzinach
        length = trail.get('length_km', 0)
        estimated_time = length / max(speed, 1.0)  # Zabezpieczenie przed dzieleniem przez 0

        return round(estimated_time, 2)

#utils\trail_filter.py

from typing import List, Dict, Any

class TrailFilter:
    """
    Klasa odpowiedzialna za filtrowanie i kategoryzację szlaków.
    Implementuje algorytmy klasyfikacji tras do różnych kategorii
    oraz filtrowanie według kryteriów użytkownika.
    """
    
    @staticmethod
    def filter_trails(
        trails: List[Dict[str, Any]],
        min_length: float = 0,
        max_length: float = float('inf'),
        difficulty: int = None
    ) -> List[Dict[str, Any]]:
        """
        Filtruje szlaki na podstawie podanych kryteriów.
        
        Args:
            trails: Lista słowników z danymi o szlakach
            min_length: Minimalna długość szlaku w km
            max_length: Maksymalna długość szlaku w km
            difficulty: Wymagany poziom trudności (1-3)
            
        Returns:
            Lista przefiltrowanych szlaków
        """
        filtered = trails

        # Filtrowanie po długości
        filtered = [
            trail for trail in filtered
            if min_length <= trail.get('length_km', 0) <= max_length
        ]

        # Filtrowanie po trudności jeśli określona
        if difficulty is not None:
            filtered = [
                trail for trail in filtered
                if trail.get('difficulty') == difficulty
            ]

        return filtered
    
    @staticmethod
    def classify_family_trail(trail: Dict[str, Any]) -> bool:
        """
        Klasyfikuje trasę jako rodzinną na podstawie systemu punktowego.
        
        Kryteria podstawowe (wszystkie muszą być spełnione):
        - Poziom trudności: 1 (łatwy)
        - Długość: < 5 km
        - Przewyższenie: < 200m
        
        System punktowy (minimum 40 punktów):
        - Znaczniki: leisure (+10), park (+10), playground (+15), family (+15)
        - Nawierzchnia utwardzona: +10
        - Udogodnienia na trasie: +5 za każde
        
        Args:
            trail: Słownik z danymi o trasie
            
        Returns:
            bool: True jeśli trasa spełnia kryteria trasy rodzinnej
        """
        # Sprawdź kryteria podstawowe (wymagane)
        if (trail.get('difficulty', 0) > 1 or 
            trail.get('length_km', 0) >= 5 or
            trail.get('elevation_gain', 0) >= 200):
            return False
            
        # Oblicz punkty za dodatkowe cechy
        points = 0
        
        # Punkty za znaczniki
        tags = trail.get('tags', [])
        if 'leisure' in tags: points += 10
        if 'park' in tags: points += 10
        if 'playground' in tags: points += 15
        if 'family' in tags: points += 15
        
        # Punkty za nawierzchnię
        if trail.get('surface', '') in ['paved', 'asphalt', 'concrete']:
            points += 10
            
        # Punkty za udogodnienia
        amenities = trail.get('amenities', [])
        points += len(amenities) * 5
        
        return points >= 40

    @staticmethod
    def classify_scenic_trail(trail: Dict[str, Any]) -> bool:
        """
        Klasyfikuje trasę jako widokową na podstawie systemu punktowego.
        
        Kryteria podstawowe:
        - Długość: preferowane < 15 km
        - Minimum jeden punkt widokowy
        
        System punktowy (minimum 50 punktów):
        - Każdy punkt widokowy: +20
        - Znaczniki: viewpoint (+15), scenic (+15), tourism (+10), panorama (+20)
        - Wysokość względna > 300m: +10
        - Lokalizacja w górach: +15
        
        Args:
            trail: Słownik z danymi o trasie
            
        Returns:
            bool: True jeśli trasa spełnia kryteria trasy widokowej
        """
        # Sprawdź czy trasa ma punkty widokowe
        if not trail.get('viewpoints', []):
            return False
            
        points = 0
        
        # Punkty za każdy punkt widokowy
        points += len(trail.get('viewpoints', [])) * 20
        
        # Punkty za znaczniki
        tags = trail.get('tags', [])
        if 'viewpoint' in tags: points += 15
        if 'scenic' in tags: points += 15
        if 'tourism' in tags: points += 10
        if 'panorama' in tags: points += 20
        
        # Punkty za wysokość
        if trail.get('elevation_gain', 0) > 300:
            points += 10
            
        # Punkty za lokalizację w górach
        if trail.get('terrain_type', '').lower() == 'górski':
            points += 15
            
        return points >= 50
        
    @staticmethod
    def classify_sport_trail(trail: Dict[str, Any]) -> bool:
        """
        Klasyfikuje trasę jako sportową.
        
        Kryteria (musi spełniać jedno z):
        1. Zestaw standardowy:
           - Długość: 5-15 km
           - Trudność: poziom 2
           - Przewyższenie: 200-800m
           
        2. Zestaw znaczników:
           - Znaczniki: sport, activity, training
           - Długość: > 5 km
        
        Args:
            trail: Słownik z danymi o trasie
            
        Returns:
            bool: True jeśli trasa spełnia kryteria trasy sportowej
        """
        # Kryteria standardowe
        length = trail.get('length_km', 0)
        difficulty = trail.get('difficulty', 0)
        elevation = trail.get('elevation_gain', 0)
        
        # Sprawdź zestaw standardowy
        if (5 <= length <= 15 and difficulty == 2 and 200 <= elevation <= 800):
            return True
        
        # Sprawdź zestaw znaczników
        tags = trail.get('tags', [])
        if ('sport' in tags or 'activity' in tags or 'training' in tags) and length > 5:
            return True
        
        return False
    
    @staticmethod
    def classify_extreme_trail(trail: Dict[str, Any]) -> bool:
        """
        Klasyfikuje trasę jako ekstremalną.
        
        Kryteria (musi spełniać jedno z):
        - Trudność: poziom 3
        - Długość: > 15 km
        - Przewyższenie: > 800m
        - Znaczniki: climbing, alpine, via_ferrata
        
        Args:
            trail: Słownik z danymi o trasie
            
        Returns:
            bool: True jeśli trasa spełnia kryteria trasy ekstremalnej
        """
        # Kryteria trudności
        difficulty = trail.get('difficulty', 0)
        length = trail.get('length_km', 0)
        elevation = trail.get('elevation_gain', 0)
        tags = trail.get('tags', [])
        
        # Sprawdź trudność poziom 3
        if difficulty == 3:
            return True
        
        # Sprawdź długość i przewyższenie
        if length > 15 or elevation > 800:
            return True
        
        # Sprawdź znaczniki
        if ('climbing' in tags or 'alpine' in tags or 'via_ferrata' in tags):
            return True
        
        return False

#utils\weather_utils.py

from typing import Dict, Any, Optional
from datetime import datetime

class WeatherUtils:
    """
    Klasa narzędzi do przetwarzania danych pogodowych.
    
    Główne funkcjonalności:
    - Obliczanie indeksu komfortu dla wędrówek
    - Analiza najlepszych okresów dla różnych typów tras
    - Formatowanie i walidacja danych pogodowych
    - Określanie stanu pogody (słonecznie/deszczowo)
    """

    @staticmethod
    def format_weather_data(weather_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Formatuje dane pogodowe do bardziej czytelnej postaci.
        
        Args:
            weather_data: Surowe dane pogodowe z API
            
        Returns:
            Sformatowane dane z obliczonymi średnimi wartościami
        """
        if not weather_data:
            return {}
            
        return {
            'temperatura': {
                'min': round(weather_data.get('temperature_min', 0), 1),
                'max': round(weather_data.get('temperature_max', 0), 1),
                'średnia': round(weather_data.get('temperature', 0), 1)
            },
            'opady': round(weather_data.get('precipitation', 0), 1),
            'zachmurzenie': round(weather_data.get('cloud_cover', 0), 1),
            'godziny_słoneczne': round(weather_data.get('sunshine_hours', 0), 1),
            'prędkość_wiatru': round(weather_data.get('wind_speed', 0), 1)
        }
    
    @staticmethod
    def is_weather_suitable(weather_data: Dict[str, Any], 
                          max_precipitation: float,
                          min_temperature: float,
                          max_temperature: float) -> bool:
        """
        Sprawdza czy warunki pogodowe są odpowiednie dla wycieczki.
        
        Kryteria:
        - Temperatura w zadanym zakresie
        - Opady poniżej maksymalnego progu
        - Odpowiednie zachmurzenie
        """
        if not weather_data:
            return False
            
        avg_temp = weather_data.get('temperature', 0)
        precipitation = weather_data.get('precipitation', 0)
        
        return (min_temperature <= avg_temp <= max_temperature and 
                precipitation <= max_precipitation)
    
    @staticmethod
    def get_weather_summary(weather_data: Dict[str, Any]) -> str:
        """Tworzy podsumowanie warunków pogodowych."""
        if not weather_data:
            return "Brak danych pogodowych"
            
        temp_min = weather_data.get('temperature_min', 0)
        temp_max = weather_data.get('temperature_max', 0)
        precipitation = weather_data.get('precipitation', 0)
        cloud_cover = weather_data.get('cloud_cover', 0)
        sunshine = weather_data.get('sunshine_hours', 0)
        
        return (f"Temperatura: {temp_min:.1f}°C - {temp_max:.1f}°C\n"
                f"Opady: {precipitation:.1f} mm\n"
                f"Zachmurzenie: {cloud_cover:.1f}%\n"
                f"Godziny słoneczne: {sunshine:.1f} h")
    
    @staticmethod
    def get_weather_condition(weather_data: Dict[str, Any]) -> str:
        """Określa ogólny stan pogody."""
        if not weather_data:
            return "nieznany"
            
        precipitation = weather_data.get('precipitation', 0)
        cloud_cover = weather_data.get('cloud_cover', 0)
        sunshine = weather_data.get('sunshine_hours', 0)
        
        if precipitation > 5:
            return "deszczowo"
        elif cloud_cover > 70:
            return "pochmurno"
        elif sunshine > 6:
            return "słonecznie"
        else:
            return "umiarkowanie"
    @staticmethod
    def calculate_hiking_comfort(weather_data: Dict[str, Any]) -> float:
        """
        Oblicza indeks komfortu dla wędrówek (0-100) na podstawie warunków pogodowych.
        
        Algorytm wykorzystuje system wag:
        - Temperatura (40%): optymalna 15-18°C
        - Opady (35%): im mniejsze tym lepiej
        - Zachmurzenie (25%): optymalne 20-40%
        
        Args:
            weather_data: Słownik z danymi pogodowymi zawierający:
                - temperature/temperature_min/temperature_max: temperatura w °C
                - precipitation: opady w mm
                - cloud_cover: zachmurzenie w %
        
        Returns:
            float: Indeks komfortu w skali 0-100
        """
        if not weather_data:
            return 50.0  # Wartość domyślna przy braku danych
            
        try:
            # 1. Obliczanie składowej temperatury (40% wagi końcowej)
            temp_min = weather_data.get('temperature_min')
            temp_max = weather_data.get('temperature_max')

            if temp_min is not None and temp_max is not None:
                temp = (float(temp_min) + float(temp_max)) / 2
            else:
                temp = float(weather_data.get('temperature', 20))
            
            # Obliczanie punktów za temperaturę
            if 15 <= temp <= 18:  # Idealny zakres
                temp_score = 100
            elif temp < 15:  # Za zimno
                temp_score = max(0, 100 - abs(15 - temp) * 15)  # -15 punktów za każdy stopień poniżej
            else:  # Za ciepło
                temp_score = max(0, 100 - abs(temp - 18) * 18)  # -18 punktów za każdy stopień powyżej
            
            # 2. Obliczanie składowej opadów (35% wagi końcowej)
            precip = float(weather_data.get('precipitation', 0))
            precip_score = max(0, 100 - (precip * 40))  # -40 punktów za każdy mm opadów
            
            # 3. Obliczanie składowej zachmurzenia (25% wagi końcowej)
            cloud = float(weather_data.get('cloud_cover', 50))
            if cloud < 20:  # Prawie bezchmurnie (może być za gorąco)
                cloud_score = 80
            elif 20 <= cloud <= 40:  # Idealne zachmurzenie
                cloud_score = 100
            elif cloud < 60:  # Umiarkowane zachmurzenie
                cloud_score = 60
            else:  # Duże zachmurzenie
                cloud_score = max(0, 100 - ((cloud - 60) * 2))  # -2 punkty za każdy % powyżej 60
            
            # Oblicz końcowy wynik (średnia ważona)
            comfort_index = (
                temp_score * 0.4 +    # Temperatura ma największy wpływ
                precip_score * 0.35 + # Opady mają duży wpływ
                cloud_score * 0.25    # Zachmurzenie ma najmniejszy wpływ
            )
            
            return round(comfort_index, 1)
            
        except (ValueError, TypeError) as e:
            print(f"Błąd podczas obliczania indeksu komfortu: {e}")
            return 50.0  # Wartość domyślna w przypadku błędu
    @staticmethod
    def analyze_best_periods(weather_data: Dict[str, Dict[str, Any]], trail_type: str = None) -> Dict[str, Any]:
        """
        Analizuje dane pogodowe aby określić najlepsze okresy dla szlaku.
        
        Analiza uwzględnia:
        - Sezonowość (wiosna, lato, jesień, zima)
        - Typ szlaku (górski, leśny, nizinny)
        - Specjalne wymagania dla różnych typów tras
        - Długoterminowe trendy pogodowe
        
        Args:
            weather_data: Historyczne dane pogodowe
            trail_type: Typ szlaku (górski, leśny, nizinny, miejski)
            
        Returns:
            Dict zawierający:
            - best_dates: Lista dat z najlepszymi warunkami
            - average_comfort: Średni indeks komfortu
            - recommendations: Zalecenia dotyczące najlepszej pory roku
        """
        if not weather_data:
            return {
                "best_dates": [],
                "average_comfort": 0.0,
                "season_scores": {
                    "Wiosna": 0,
                    "Lato": 0,
                    "Jesień": 0,
                    "Zima": 0
                },
                "recommendations": "Brak wystarczających danych pogodowych"
            }

        # Oblicz indeks komfortu dla każdej daty
        comfort_scores = {}
        season_scores = {
            "Wiosna": [],  # Marzec-Maj
            "Lato": [],    # Czerwiec-Sierpień
            "Jesień": [],  # Wrzesień-Listopad
            "Zima": []     # Grudzień-Luty
        }
        
        # Analizuj każdy dzień
        for date_str, conditions in weather_data.items():
            try:
                # Oblicz podstawowy indeks komfortu
                comfort = WeatherUtils.calculate_hiking_comfort(conditions)
                
                # Dodatkowe modyfikatory w zależności od typu szlaku
                if trail_type:
                    if trail_type == 'górski':
                        # Kara za silny wiatr dla szlaków górskich
                        wind_penalty = max(0, (conditions.get('wind_speed', 0) - 15) * 2)
                        comfort = max(0, comfort - wind_penalty)
                    elif trail_type == 'leśny':
                        # Bonus dla szlaków leśnych (mniejszy wpływ zachmurzenia)
                        comfort = min(100, comfort + 10)

                comfort_scores[date_str] = comfort
                
                # Przypisz wynik do odpowiedniej pory roku
                date = datetime.strptime(date_str, "%Y-%m-%d")
                month = date.month
                
                if 3 <= month <= 5:
                    season_scores["Wiosna"].append(comfort)
                elif 6 <= month <= 8:
                    season_scores["Lato"].append(comfort)
                elif 9 <= month <= 11:
                    season_scores["Jesień"].append(comfort)
                else:
                    season_scores["Zima"].append(comfort)
                    
            except (ValueError, KeyError):
                continue

        # Znajdź najlepsze daty (z komfortem > 70)
        best_dates = sorted([
            (date, score) for date, score in comfort_scores.items()
            if score > 70
        ], key=lambda x: x[1], reverse=True)

        # Oblicz średnie dla sezonów
        season_averages = {}
        for season, scores in season_scores.items():
            season_averages[season] = round(sum(scores) / len(scores)) if scores else 0

        # Znajdź najlepszą porę roku
        best_season = max(season_averages.items(), key=lambda x: x[1])[0]
        
        # Przygotuj rekomendacje
        recommendations = []
        recommendations.append(f"Najlepsza pora roku: {best_season}")
        
        # Dodaj rekomendacje dla typu szlaku
        if trail_type == "górski":
            if best_season in ["Wiosna", "Jesień"]:
                recommendations.append("Idealne warunki dla tego typu trasy")
            elif best_season == "Lato":
                recommendations.append("Możliwe upały, zalecana wczesna pora dnia")
            else:
                recommendations.append("W zimie wymagane dodatkowe przygotowanie")
        elif trail_type in ["leśny", "nizinny"]:
            if best_season in ["Wiosna", "Lato"]:
                recommendations.append("Świetne warunki do wędrówek")
            else:
                recommendations.append("Sprawdź prognozę opadów przed wycieczką")

        # Oblicz średni komfort dla wszystkich dat
        avg_comfort = sum(comfort_scores.values()) / len(comfort_scores) if comfort_scores else 0

        # Dodaj ogólne zalecenia
        if avg_comfort < 50:
            recommendations.append("Zalecana duża ostrożność przy planowaniu wycieczki")
        elif avg_comfort > 70:
            recommendations.append("Bardzo dobre warunki przez większość czasu")

        return {
            "best_dates": [date for date, _ in best_dates[:5]],  # Top 5 najlepszych dat
            "average_comfort": round(avg_comfort, 2),
            "season_scores": season_averages,
            "recommendations": " | ".join(recommendations)
        }

#utils\weight_calculator.py

from typing import Dict, Any, List

class WeightCalculator:
    """
    Klasa odpowiedzialna za obliczanie wag i ocen dla różnych aspektów tras.
    Implementuje system wag i punktacji opisany w dokumentacji.
    """
    
    def __init__(self):
        """
        Inicjalizacja domyślnych wag dla różnych kryteriów.
        
        Domyślne wagi:
        - Długość trasy: 30%
        - Trudność: 25%
        - Warunki pogodowe: 25%
        - Typ terenu: 20%
        """
        self.default_weights = {
            'length': 0.30,
            'difficulty': 0.25,
            'weather': 0.25,
            'terrain': 0.20
        }
        self.weights = self.default_weights.copy()
    
    def get_weights_from_user(self) -> Dict[str, float]:
        """
        Pobiera i waliduje wagi od użytkownika.
        
        Proces:
        1. Wyświetla aktualne wagi
        2. Pozwala na modyfikację
        3. Normalizuje wagi do sumy 1.0
        4. Waliduje wprowadzone wartości
        
        Returns:
            Dict[str, float]: Znormalizowane wagi
        """
        print("\nAktualne wagi kryteriów:")
        for criterion, weight in self.weights.items():
            print(f"- {criterion}: {weight*100:.0f}%")

        print("\nPodaj nowe wagi (0-100) lub wciśnij ENTER dla wartości domyślnych:")
        
        try:
            # Pobierz wagi z obsługą pustych wartości
            length_input = input("Waga długości trasy: ").strip()
            difficulty_input = input("Waga trudności: ").strip()
            weather_input = input("Waga warunków pogodowych: ").strip()
            terrain_input = input("Waga typu terenu: ").strip()
            
            # Sprawdź czy wszystkie są puste (użytkownik chce domyślne)
            if not any([length_input, difficulty_input, weather_input, terrain_input]):
                print("✅ Użyto domyślnych wag")
                self.weights = self.default_weights.copy()
                return self.weights
            
            # Konwertuj niepuste wartości, użyj domyślnych dla pustych
            if length_input:
                self.weights['length'] = float(length_input) / 100
            if difficulty_input:
                self.weights['difficulty'] = float(difficulty_input) / 100
            if weather_input:
                self.weights['weather'] = float(weather_input) / 100
            if terrain_input:
                self.weights['terrain'] = float(terrain_input) / 100

            # Normalizacja wag
            total = sum(self.weights.values())
            if total > 0:
                for key in self.weights:
                    self.weights[key] /= total
                print("✅ Wagi zostały znormalizowane")
            else:
                print("❌ Suma wag nie może być zero. Użyto domyślnych wag.")
                self.weights = self.default_weights.copy()

        except ValueError as e:
            print(f"❌ Błąd w podanych wartościach: {e}")
            print("✅ Użyto domyślnych wag")
            self.weights = self.default_weights.copy()

        return self.weights
    
    @staticmethod
    def calculate_length_score(length_km: float) -> float:
        """
        Oblicza ocenę dla długości trasy.
        
        System punktacji:
        - Zakres optymalny (5-15 km): 100 punktów
        - Poniżej 5km: -5 punktów za każdy km różnicy
        - Powyżej 15km: -5 punktów za każdy km różnicy
        
        Args:
            length_km: Długość trasy w kilometrach
            
        Returns:
            float: Ocena w zakresie 0-100
        """
        if 5 <= length_km <= 15:
            return 100.0
        elif length_km < 5:
            return max(0, 100 - (5 - length_km) * 5)
        else:
            return max(0, 100 - (length_km - 15) * 5)
            
    @staticmethod
    def calculate_difficulty_score(difficulty: int, elevation_gain: float = 0) -> float:
        """
        Oblicza ocenę dla trudności trasy.
        
        System punktacji:
        - Poziom 1 (łatwy): 100 punktów
        - Poziom 2 (średni): 66.66 punktów
        - Poziom 3 (trudny): 33.33 punktów
        
        Modyfikatory za przewyższenie:
        - >500m: -10 punktów
        - >1000m: -20 punktów
        
        Args:
            difficulty: Poziom trudności (1-3)
            elevation_gain: Przewyższenie w metrach
            
        Returns:
            float: Ocena w zakresie 0-100
        """
        # Bazowa ocena za trudność
        base_score = {
            1: 100.0,
            2: 66.66,
            3: 33.33
        }.get(difficulty, 0.0)
        
        # Modyfikatory za przewyższenie
        if elevation_gain > 1000:
            base_score = max(0, base_score - 20)
        elif elevation_gain > 500:
            base_score = max(0, base_score - 10)
            
        return base_score
        
    @staticmethod
    def calculate_terrain_score(terrain_type: str, attributes: Dict[str, Any]) -> float:
        """
        Oblicza ocenę dla typu terenu.
        
        Punktacja bazowa:
        - Górski: 90 punktów
        - Leśny: 85 punktów
        - Mieszany: 80 punktów
        - Nadrzeczny: 75 punktów
        - Miejski: 70 punktów
        
        Modyfikatory:
        - Punkt widokowy: +10 punktów
        - Atrakcja turystyczna: +5 punktów
        
        Args:
            terrain_type: Typ terenu
            attributes: Słownik z dodatkowymi atrybutami trasy
            
        Returns:
            float: Ocena w zakresie 0-100
        """
        # Bazowa ocena za typ terenu
        base_score = {
            'górski': 90.0,
            'leśny': 85.0,
            'mieszany': 80.0,
            'nadrzeczny': 75.0,
            'miejski': 70.0
        }.get(terrain_type.lower(), 70.0)
        
        # Dodaj punkty za dodatkowe atrybuty
        viewpoints = attributes.get('viewpoints', [])
        attractions = attributes.get('attractions', [])
        
        bonus_points = (len(viewpoints) * 10) + (len(attractions) * 5)
        
        return min(100, base_score + bonus_points)
        
    @staticmethod
    def calculate_weighted_score(scores: Dict[str, float], weights: Dict[str, float]) -> float:
        """
        Oblicza końcową ważoną ocenę trasy.
        
        Wzór: suma(ocena * waga) dla każdego komponentu
        
        Args:
            scores: Słownik z ocenami poszczególnych komponentów
            weights: Słownik z wagami poszczególnych komponentów
            
        Returns:
            float: Końcowa ważona ocena w zakresie 0-100
        """
        if not scores or not weights:
            return 0.0
            
        weighted_sum = sum(
            scores.get(component, 0) * weights.get(component, 0)
            for component in set(scores.keys()) & set(weights.keys())
        )
        
        total_weight = sum(weights.values())
        
        return round(weighted_sum / total_weight if total_weight > 0 else 0, 2)
    
    def calculate_weighted_score(self, trail: Dict[str, Any], weather: Dict[str, Any]) -> float:
        """
        Oblicza ważony wynik dla trasy na podstawie różnych kryteriów.
        
        Składowe oceny:
        1. Długość (normalizowana do 0-100)
        2. Trudność (przeliczana na skalę 0-100)
        3. Warunki pogodowe (indeks komfortu 0-100)
        4. Typ terenu (ocena dopasowania 0-100)
        
        Args:
            trail: Dane trasy
            weather: Dane pogodowe
            
        Returns:
            float: Ważony wynik w skali 0-100
        """
        # Ocena długości (preferowane 5-15km)
        length = trail.get('length_km', 0)
        if 5 <= length <= 15:
            length_score = 100
        else:
            length_score = max(0, 100 - abs(length - 10) * 5)

        # Ocena trudności (1-3 -> 0-100)
        difficulty = trail.get('difficulty', 1)
        difficulty_score = (4 - difficulty) * 33.33  # 1->100, 2->66.66, 3->33.33

        # Ocena pogody (użyj indeksu komfortu)
        weather_score = weather.get('comfort_index', 50)

        # Ocena terenu
        terrain_scores = {
            'mountain': 90,
            'forest': 85,
            'mixed': 80,
            'urban': 70,
            'riverside': 75
        }
        terrain_score = terrain_scores.get(trail.get('terrain_type', 'mixed'), 70)

        # Oblicz ważony wynik
        weighted_score = (
            self.weights['length'] * length_score +
            self.weights['difficulty'] * difficulty_score +
            self.weights['weather'] * weather_score +
            self.weights['terrain'] * terrain_score
        )

        return round(weighted_score, 2)
    
    def sort_trails_by_weights(self, trails: List[Dict[str, Any]], weather: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Sortuje trasy według ich ważonych wyników.
        
        Proces:
        1. Oblicza wynik ważony dla każdej trasy
        2. Dodaje wynik do danych trasy
        3. Sortuje malejąco według wyniku
        
        Args:
            trails: Lista tras do posortowania
            weather: Dane pogodowe
            
        Returns:
            List[Dict[str, Any]]: Posortowane trasy z dodanymi wynikami
        """
        for trail in trails:
            trail['weighted_score'] = self.calculate_weighted_score(trail, weather)
        
        return sorted(trails, key=lambda x: x.get('weighted_score', 0), reverse=True)

#__init__.py



#check_stats.py

import json

# Sprawdź statystyki tras
with open('test_trails_gdansk.json', 'r', encoding='utf-8') as f:
    data = json.load(f)

print(f"📊 Pobrano {len(data)} tras dla Gdańska")

lengths = [t['length_km'] for t in data]
print(f"📏 Długości: min={min(lengths):.1f}km, max={max(lengths):.1f}km, średnia={sum(lengths)/len(lengths):.1f}km")

diffs = [t['difficulty'] for t in data]
print(f"⚡ Trudności: 1={diffs.count(1)}, 2={diffs.count(2)}, 3={diffs.count(3)}")

terrains = [t['terrain_type'] for t in data]
terrain_counts = {}
for t in terrains:
    terrain_counts[t] = terrain_counts.get(t, 0) + 1

print(f"🏔️ Typy terenu:")
for terrain, count in terrain_counts.items():
    print(f"   {terrain}: {count}") 

#config.py

"""
PLIK KONFIGURACYJNY SYSTEMU REKOMENDACJI TRAS TURYSTYCZNYCH
==========================================================

Ten plik zawiera wszystkie stałe konfiguracyjne używane w całym systemie.
Centralizuje ustawienia API, współrzędne miast i szablony zapytań.

ZAWARTOŚĆ:
- Adresy URL do zewnętrznych API (pogoda, mapy)
- Współrzędne geograficzne głównych miast Polski
- Szablony zapytań do API OpenStreetMap/Overpass
- Parametry konfiguracyjne systemu

UŻYCIE: 
    from config import CITY_COORDINATES, OPEN_METEO_API
    weather_url = f"{OPEN_METEO_API}/forecast"
    city_coords = CITY_COORDINATES["Kraków"]

AUTOR: System Rekomendacji Tras Turystycznych - Etap 4
"""

# ============================================================================
# IMPORTY TYPÓW
# ============================================================================
from typing import Dict  # Podpowiedzi typów dla słowników

# ============================================================================
# ADRESY URL ZEWNĘTRZNYCH API
# ============================================================================
# API pogodowe Open-Meteo - darmowe dane meteorologiczne
OPEN_METEO_API = "https://api.open-meteo.com/v1"

# API Overpass - zapytania do bazy danych OpenStreetMap
OVERPASS_API = "https://overpass-api.de/api/interpreter"

# ============================================================================
# WSPÓŁRZĘDNE GEOGRAFICZNE GŁÓWNYCH MIAST POLSKI
# ============================================================================
# Słownik zawierający precyzyjne współrzędne GPS głównych miast
# Używane do pobierania danych pogodowych i wyszukiwania tras w okolicy
CITY_COORDINATES: Dict[str, Dict[str, float]] = {
    "Gdańsk": {
        "lat": 54.3520,    # Szerokość geograficzna północna
        "lon": 18.6466     # Długość geograficzna wschodnia
    },
    "Warszawa": {
        "lat": 52.2297,    # Stolica Polski - centrum geograficzne
        "lon": 21.0122
    },
    "Kraków": {
        "lat": 50.0647,    # Historyczna stolica - południe Polski
        "lon": 19.9450
    },
    "Wrocław": {
        "lat": 51.1079,    # Stolica Dolnego Śląska - zachód Polski  
        "lon": 17.0385
    }
}

# ============================================================================
# SZABLON ZAPYTANIA OVERPASS API
# ============================================================================
# Zapytanie w języku Overpass QL do pobierania tras turystycznych
# z bazy danych OpenStreetMap dla określonego miasta
OVERPASS_QUERY_TEMPLATE = """
[out:json][timeout:25];
area["name"="{city}"]["boundary"="administrative"]->.searchArea;
relation["type"="route"]["route"="hiking"](area.searchArea);
out body;
>;
out skel qt;
""" 

#main.py

#!/usr/bin/env python3
"""
GŁÓWNY PLIK SYSTEMU REKOMENDACJI TRAS TURYSTYCZNYCH
===================================================

Ten plik zawiera główną aplikację konsolową do rekomendacji tras turystycznych.
System oferuje:
- Rekomendacje tras z filtrowaniem według różnych kryteriów
- Analizę konkretnych tras z wykorzystaniem AI
- Generowanie profesjonalnych raportów PDF z wykresami
- Pobieranie danych z portali internetowych
- Zarządzanie bazą danych SQLite
- Demonstrację przetwarzania tekstu wyrażeniami regularnymi

Autor: System Rekomendacji Tras Turystycznych - Etap 4
Data: 2024
"""

# ============================================================================
# IMPORTY BIBLIOTEK STANDARDOWYCH
# ============================================================================
import os          # Operacje na systemie plików
import sys         # Operacje systemowe
import json        # Obsługa formatu JSON
from datetime import datetime  # Obsługa dat i czasu
from typing import List, Dict, Any  # Podpowiedzi typów dla lepszej czytelności kodu

# ============================================================================
# KONFIGURACJA ŚCIEŻEK PROJEKTU
# ============================================================================
# Dodaj katalog główny projektu do ścieżki Pythona, aby móc importować moduły
project_root = os.path.dirname(os.path.abspath(__file__))
sys.path.append(project_root)

# ============================================================================
# IMPORTY MODUŁÓW PROJEKTU
# ============================================================================
from data_handlers.trail_data import TrailDataHandler      # Obsługa danych tras
from data_handlers.weather_data import WeatherDataHandler  # Obsługa danych pogodowych
from utils.trail_filter import TrailFilter                 # Filtrowanie tras
from utils.storage import save_results_to_file             # Zapisywanie wyników
from config import CITY_COORDINATES                        # Konfiguracja miast
from recommendation.trail_recommender import TrailRecommender  # Główny silnik rekomendacji
from utils.weather_utils import WeatherUtils               # Narzędzia pogodowe

# ============================================================================
# FUNKCJE INTERFEJSU UŻYTKOWNIKA
# ============================================================================

def display_main_menu():
    """
    Wyświetla główne menu systemu z wszystkimi dostępnymi opcjami.
    
    Menu oferuje 8 głównych funkcjonalności:
    1. Standardowe rekomendacje - podstawowe wyszukiwanie tras
    2. Raporty PDF - profesjonalne raporty z wykresami
    3. Analiza tras - szczegółowa analiza konkretnej trasy
    4. Pobieranie danych - automatyczne zbieranie z internetu
    5. Wykresy - generowanie tylko wizualizacji
    6. Testy systemu - kompleksowe testowanie funkcji
    7. Demo procesora tekstu - pokazuje analizę wyrażeń regularnych
    8. Wyjście - zamknięcie aplikacji
    """
    print("\n" + "="*60)
    print("🏔️  SYSTEM REKOMENDACJI TRAS TURYSTYCZNYCH  🏔️")
    print("="*60)
    print("Wybierz opcję:")
    print("1. 🚶 Standardowe rekomendacje tras")
    print("2. 📊 Rekomendacje z raportem PDF")
    print("3. 🔍 Analiza konkretnej trasy")
    print("4. 🌐 Pobierz dodatkowe dane z internetu")
    print("5. 📈 Generuj tylko wykresy")
    print("6. 🧪 Test wszystkich funkcji systemu")
    print("7. 🔧 Demonstracja przetwarzania tekstu")
    print("8. ❌ Wyjście")
    print("="*60)

def display_weather_stats(cities: List[str], date: str, weather_handler) -> None:
    """
    Wyświetla szczegółowe statystyki pogodowe dla wybranych miast.
    
    Args:
        cities: Lista nazw miast do wyświetlenia
        date: Data w formacie YYYY-MM-DD
        weather_handler: Obiekt obsługujący dane pogodowe
        
    Funkcja pobiera dane pogodowe dla każdego miasta i wyświetla:
    - Temperatury (min, max, średnia)
    - Opady i zachmurzenie
    - Godziny słoneczne i prędkość wiatru
    - Indeks komfortu wędrówki (0-100)
    - Ogólny stan pogody
    """
    print("\n=== 🌤️ Warunki pogodowe ===")
    print(f"Data: {date}\n")
    
    # Przeiteruj przez wszystkie wybrane miasta
    for city in cities:
        # Pobierz dane pogodowe dla miasta
        weather = weather_handler.get_weather_forecast(city, date)
        if not weather:
            print(f"{city}: Brak danych pogodowych")
            continue
            
        # Oblicz temperaturę średnią z min i max
        temp_min = weather.get('temperature_min', 0)
        temp_max = weather.get('temperature_max', 0)
        avg_temp = round((temp_min + temp_max) / 2, 1) if temp_min != 0 or temp_max != 0 else 'N/A'
        
        # Oblicz indeks komfortu wędrówki (algorytm uwzględnia temp, opady, słońce)
        comfort_index = WeatherUtils.calculate_hiking_comfort(weather)
        # Określ ogólny stan pogody na podstawie wszystkich parametrów
        weather_condition = WeatherUtils.get_weather_condition(weather)
        
        # Wyświetl wszystkie parametry pogodowe w czytelnej formie
        print(f"=== {city} ===")
        print(f"🌡️ Temperatura średnia: {avg_temp}°C")
        print(f"🥶 Minimalna temperatura: {weather.get('temperature_min', 'N/A')}°C")
        print(f"🔥 Maksymalna temperatura: {weather.get('temperature_max', 'N/A')}°C")
        print(f"🌧️ Opady: {weather.get('precipitation', 'N/A')} mm")
        print(f"☁️ Zachmurzenie: {weather.get('cloud_cover', 'N/A')}%")
        print(f"☀️ Godziny słoneczne: {weather.get('sunshine_hours', 0):.1f} h")
        print(f"💨 Prędkość wiatru: {weather.get('wind_speed', 'N/A')} km/h")
        print(f"🌈 Stan pogody: {weather_condition}")
        print(f"😊 Indeks komfortu: {comfort_index}/100")
        print()

def get_search_criteria():
    """
    Pobiera kryteria wyszukiwania tras od użytkownika w trybie interaktywnym.
    
    Returns:
        dict: Słownik z kryteriami wyszukiwania, gdzie każde kryterium może być None
        
    Funkcja pozwala użytkownikowi określić:
    - Kategorię trasy (rodzinna, widokowa, sportowa, ekstremalna)
    - Poziom trudności (1-3)
    - Typ terenu (górski, nizinny, leśny, miejski)
    - Przedziały długości trasy
    - Warunki pogodowe (słońce, opady, temperatura)
    
    Wszystkie kryteria są opcjonalne - naciśnięcie ENTER pomija kryterium.
    """
    print("\n=== 🔍 Kryteria wyszukiwania ===")
    print("(Naciśnij ENTER, aby pominąć dowolne kryterium)")
    
    # ========================================================================
    # WYBÓR KATEGORII TRASY
    # ========================================================================
    print("\n📂 Wybierz kategorię trasy:")
    print("1. 👨‍👩‍👧‍👦 Rodzinna (łatwe, krótkie trasy < 5km)")
    print("2. 🏞️ Widokowa (trasy z pięknymi krajobrazami)")
    print("3. 🏃 Sportowa (trasy 5-15km, średnia trudność)")
    print("4. 🧗 Ekstremalna (trudne trasy > 15km)")
    print("(naciśnij ENTER, aby zobaczyć wszystkie kategorie)")
    category_choice = input("Wybierz kategorię (1-4): ").strip()
    
    # ========================================================================
    # POBIERANIE POZOSTAŁYCH KRYTERIÓW
    # ========================================================================
    # Każde z poniższych kryteriów jest opcjonalne
    difficulty = input("\n⚡ Poziom trudności (1-3, gdzie: 1-łatwy, 2-średni, 3-trudny): ").strip()
    terrain_type = input("🏔️ Typ terenu (górski, nizinny, leśny, miejski): ").strip()
    min_length = input("📏 Minimalna długość trasy (km): ").strip()
    max_length = input("📐 Maksymalna długość trasy (km): ").strip()
    min_sunshine = input("☀️ Minimalna liczba godzin słonecznych: ").strip()
    max_precipitation = input("🌧️ Maksymalne opady (mm): ").strip()
    min_temperature = input("🌡️ Minimalna temperatura (°C): ").strip()
    max_temperature = input("🔥 Maksymalna temperatura (°C): ").strip()
    
    # ========================================================================
    # KONWERSJA I WALIDACJA DANYCH WEJŚCIOWYCH
    # ========================================================================
    # Konwertuj teksty na odpowiednie typy danych (int, float) lub zostaw None
    difficulty = int(difficulty) if difficulty else None
    terrain_type = terrain_type.lower() if terrain_type else None  # Normalizuj do małych liter
    min_length = float(min_length) if min_length else None
    max_length = float(max_length) if max_length else None
    min_sunshine = float(min_sunshine) if min_sunshine else None
    max_precipitation = float(max_precipitation) if max_precipitation else None
    min_temperature = float(min_temperature) if min_temperature else None
    max_temperature = float(max_temperature) if max_temperature else None
    
    # Mapowanie numerów kategorii na nazwy tekstowe
    category_map = {
        "1": "rodzinna",    # Łatwe trasy dla rodzin z dziećmi
        "2": "widokowa",    # Trasy o wysokich walorach krajobrazowych
        "3": "sportowa",    # Trasy dla aktywnych turystów
        "4": "ekstremalna"  # Trudne trasy dla doświadczonych
    }
    chosen_category = category_map.get(category_choice) if category_choice else None
    
    # Zwróć słownik z wszystkimi kryteriami
    return {
        'difficulty': difficulty,              # Poziom trudności (1-3)
        'terrain_type': terrain_type,          # Typ terenu
        'min_length': min_length,              # Minimalna długość w km
        'max_length': max_length,              # Maksymalna długość w km
        'min_sunshine': min_sunshine,          # Minimalne godziny słoneczne
        'max_precipitation': max_precipitation, # Maksymalne opady w mm
        'min_temperature': min_temperature,    # Minimalna temperatura w °C
        'max_temperature': max_temperature,    # Maksymalna temperatura w °C
        'category': chosen_category            # Kategoria trasy
    }

def get_city_and_date():
    """Pobiera miasto i datę od użytkownika."""
    print("\n=== 🏙️ Wybór miasta i daty ===")
    print("Dostępne miasta: Gdańsk, Warszawa, Kraków, Wrocław")
    print("(Naciśnij ENTER, aby wybrać wszystkie miasta)")
    city = input("Wybierz miasto: ").strip()
    
    if not city:
        print("✅ Wybrano wszystkie miasta")
        cities = list(CITY_COORDINATES.keys())
    elif city not in CITY_COORDINATES:
        print(f"❌ Nieprawidłowe miasto. Wybierz jedno z: {', '.join(CITY_COORDINATES.keys())}")
        return None, None
    else:
        cities = [city]

    # Wybór typu danych pogodowych
    print("\n🌤️ Wybierz typ danych pogodowych:")
    print("1. 📚 Dane historyczne (przeszłość)")
    print("2. 🔮 Prognoza pogody (teraźniejszość i przyszłość)")
    data_type = input("Wybierz opcję (1 lub 2): ").strip()
    
    if data_type not in ["1", "2"]:
        print("❌ Nieprawidłowy wybór. Wybierz 1 lub 2.")
        return None, None

    # Pobieranie daty
    while True:
        date = input("\n📅 Podaj datę (RRRR-MM-DD) lub wciśnij ENTER dla dzisiejszej daty: ").strip()
        if not date:
            date = datetime.now().strftime("%Y-%m-%d")
            break
        try:
            input_date = datetime.strptime(date, "%Y-%m-%d")
            today = datetime.now()
            
            if data_type == "1" and input_date.date() > today.date():
                print("❌ Dla danych historycznych wybierz datę z przeszłości.")
                continue
            elif data_type == "2" and input_date.date() < today.date():
                print("❌ Dla prognozy pogody wybierz datę dzisiejszą lub przyszłą.")
                continue
                
            break
        except ValueError:
            print("❌ Nieprawidłowy format daty. Użyj formatu RRRR-MM-DD (np. 2024-03-20)")
    
    return cities, date

def display_trail_results(trails_by_city: Dict[str, List[Dict[str, Any]]]):
    """Wyświetla wyniki rekomendacji tras."""
    for city, trails in trails_by_city.items():
        print(f"\n=== 🏙️ Trasy w mieście {city} ===")
        for i, trail in enumerate(trails, 1):
            print(f"\n{i}. 🚶 {trail['name']}")
            print(f"   🏙️ Miasto: {trail.get('region', city)}")
            print(f"   📏 Długość: {trail['length_km']:.1f} km")
            print(f"   ⚡ Poziom trudności: {trail['difficulty']}/3")
            print(f"   🏔️ Typ terenu: {trail['terrain_type']}")
            print(f"   📂 Kategoria trasy: {trail.get('category', 'nieskategoryzowana').upper()}")
            
            if 'comfort_index' in trail:
                print(f"   😊 Indeks komfortu wędrówki: {trail['comfort_index']:.1f}/100")
            if trail.get('sunshine_hours'):
                print(f"   ☀️ Godziny słoneczne: {trail.get('sunshine_hours', 0):.2f} h")
            if 'description' in trail:
                desc = trail['description'][:100] + "..." if len(trail['description']) > 100 else trail['description']
                print(f"   📝 Opis: {desc}")
            if 'weighted_score' in trail:
                print(f"   🎯 Wynik ważony: {trail['weighted_score']:.2f}/100")
            
            # Wyświetl szacowany czas przejścia
            if 'estimated_time' in trail:
                hours = int(trail['estimated_time'])
                minutes = int((trail['estimated_time'] - hours) * 60)
                if hours > 0 and minutes > 0:
                    print(f"   ⏱️ Szacowany czas przejścia: {hours}h {minutes}min")
                elif hours > 0:
                    print(f"   ⏱️ Szacowany czas przejścia: {hours}h")
                else:
                    print(f"   ⏱️ Szacowany czas przejścia: {minutes}min")
            
            # Wyświetl analizę recenzji jeśli dostępna
            if trail.get('review_analysis'):
                analysis = trail['review_analysis']
                print(f"   ⭐ Średnia ocena: {analysis.get('average_rating', 'N/A')}")
                print(f"   💬 Liczba recenzji: {analysis.get('total_reviews', 0)}")
                if analysis.get('sentiment_summary'):
                    sentiment = analysis['sentiment_summary']
                    print(f"   😊 Pozytywne: {sentiment.get('positive', 0)}, "
                          f"😐 Neutralne: {sentiment.get('neutral', 0)}, "
                          f"😞 Negatywne: {sentiment.get('negative', 0)}")
            
            print(f"   ---")

def standard_recommendations():
    """Standardowe rekomendacje tras."""
    print("\n🚶 === STANDARDOWE REKOMENDACJE TRAS ===")
    
    cities, date = get_city_and_date()
    if not cities:
        return
    
    criteria = get_search_criteria()
    
    recommender = TrailRecommender()
    
    # Pobierz wagi od użytkownika TYLKO RAZ na początku
    print("\n⚖️ === USTAWIENIE WAG KRYTERIÓW ===")
    weights = recommender.set_weights_from_user()
    
    trails_by_city = {}
    weather_by_city = {}
    total_trails = 0
    
    # Inicjalizacja bazy danych dla zapisywania danych
    db_manager = None
    try:
        from database import DatabaseManager
        db_manager = DatabaseManager()
        if not db_manager.initialize_database():
            db_manager = None
    except Exception as e:
        print(f"⚠️ Baza danych niedostępna: {e}")
        db_manager = None
    
    # Pobierz rekomendacje dla każdego miasta
    for current_city in cities:
        print(f"\n🔍 Pobieranie rekomendacji dla miasta {current_city}...")
        
        # Najpierw pobierz wszystkie trasy z API i zapisz do bazy
        if db_manager:
            try:
                from database.repositories import RouteRepository
                route_repo = RouteRepository(db_manager)
                
                # Pobierz wszystkie trasy dla miasta z API
                all_trails = recommender.data_handler.get_trails_for_city(current_city)
                print(f"📥 Pobrano {len(all_trails)} tras z API dla {current_city}")
                
                saved_count = 0
                for trail in all_trails:
                    # Sprawdź czy trasa już istnieje w bazie
                    existing_routes = route_repo.search_routes({'name': trail.get('name', '')})
                    if not existing_routes:
                        # Dodaj nową trasę do bazy
                        route_data = {
                            'name': trail.get('name', 'Nieznana trasa'),
                            'region': trail.get('region', current_city),
                            'length_km': trail.get('length_km', 0),
                            'difficulty': min(3, trail.get('difficulty', 1)),  # Ogranicz do 1-3
                            'terrain_type': trail.get('terrain_type', 'nizinny'),
                            'description': trail.get('description', ''),
                            'category': trail.get('category', 'nieskategoryzowana'),
                            'estimated_time': trail.get('estimated_time', 0),
                            'elevation_gain': trail.get('elevation_m', 0),
                            'start_lat': trail.get('coordinates', {}).get('lat', 0.0) if trail.get('coordinates') else 0.0,
                            'start_lon': trail.get('coordinates', {}).get('lon', 0.0) if trail.get('coordinates') else 0.0,
                            'end_lat': trail.get('coordinates', {}).get('lat', 0.0) if trail.get('coordinates') else 0.0,
                            'end_lon': trail.get('coordinates', {}).get('lon', 0.0) if trail.get('coordinates') else 0.0,
                            'tags': ', '.join(trail.get('tags', [])) if trail.get('tags') else '',
                            'user_rating': 3.0  # Domyślna ocena
                        }
                        route_repo.add_route(route_data)
                        saved_count += 1
                
                if saved_count > 0:
                    print(f"💾 Zapisano {saved_count} nowych tras do bazy dla {current_city}")
                else:
                    print(f"ℹ️ Wszystkie trasy dla {current_city} już istnieją w bazie")
                    
            except Exception as e:
                print(f"⚠️ Błąd zapisywania tras do bazy: {e}")
        
        # Teraz pobierz rekomendacje (filtrowane trasy)
        trails = recommender.recommend_trails(
            city=current_city,
            date=date,
            **criteria
        )
        if trails:
            trails_by_city[current_city] = trails
            total_trails += len(trails)
            
            # Pobierz dane pogodowe
            weather = recommender.data_handler.weather_api.get_weather_forecast(current_city, date)
            if weather:
                weather_by_city[current_city] = weather
                
                # Zapisz dane pogodowe do bazy danych jeśli dostępna
                if db_manager:
                    try:
                        from database.repositories import WeatherRepository
                        weather_repo = WeatherRepository(db_manager)
                        
                        # Sprawdź czy dane pogodowe już istnieją (używamy współrzędnych miasta)
                        from config import CITY_COORDINATES
                        city_coords = CITY_COORDINATES.get(current_city, (0.0, 0.0))
                        existing_weather = weather_repo.get_weather_by_date_and_location(date, city_coords[0], city_coords[1])
                        if not existing_weather:
                            # Dodaj nowe dane pogodowe
                            weather_data = {
                                'date': date,
                                'location_lat': city_coords[0],
                                'location_lon': city_coords[1],
                                'avg_temp': weather.get('temperature', 0),
                                'min_temp': weather.get('temperature_min', 0),
                                'max_temp': weather.get('temperature_max', 0),
                                'precipitation': weather.get('precipitation', 0),
                                'wind_speed': weather.get('wind_speed', 0),
                                'cloud_cover': weather.get('cloud_cover', 0),
                                'sunshine_hours': weather.get('sunshine_hours', 0),
                                'humidity': weather.get('humidity', 0)
                            }
                            weather_repo.add_weather_data(weather_data)
                            print(f"💾 Zapisano dane pogodowe do bazy: {current_city} - {date}")
                    except Exception as e:
                        print(f"⚠️ Błąd zapisywania danych pogodowych do bazy: {e}")

    # Wyświetl wyniki
    display_weather_stats(cities, date, recommender.data_handler.weather_api)
    
    if total_trails == 0:
        print("\n❌ Nie znaleziono tras spełniających podane kryteria.")
        return

    print(f"\n✅ Łącznie znaleziono {total_trails} tras spełniających kryteria.")
    
    # Eksportuj wyniki
    try:
        from utils.export_results import ResultExporter
        ResultExporter.export_results(trails_by_city=trails_by_city, 
                                    date=date, 
                                    weather_by_city=weather_by_city)
        print("📁 Wyniki zostały wyeksportowane do plików CSV, JSON i TXT.")
    except Exception as e:
        print(f"⚠️ Błąd podczas eksportu: {e}")
    
    display_trail_results(trails_by_city)
    
    # Dodaj analizę najlepszych okresów
    print("\n=== 📅 ANALIZA NAJLEPSZYCH OKRESÓW ===")
    for city, trails in trails_by_city.items():
        weather_data = {}
        try:
            # Próbujemy pobrać dane z weather_dataa.json dla miasta
            with open('api/weather_dataa.json', 'r', encoding='utf-8') as f:
                all_weather_data = json.load(f)
                # Filtrujemy dane tylko dla danego miasta
                weather_data = {entry['date']: entry 
                             for entry in all_weather_data 
                             if entry['region'] == city}
        except (FileNotFoundError, json.JSONDecodeError) as e:
            print(f"⚠️ Nie udało się wczytać danych pogodowych: {e}")
            weather_data = {}

        for trail in trails[:3]:  # Tylko top 3 trasy
            trail_name = trail.get('name', 'Nieznany szlak')
            trail_type = trail.get('terrain_type', 'nizinny')
            comfort_index = trail.get('comfort_index', 0)
            
            print(f"\n🚶 Trasa: {trail_name} ({city})")
            print(f"🏔️ Typ terenu: {trail_type}")
            print(f"😊 Aktualny indeks komfortu: {comfort_index}/100")
        
            # Pobierz analizę najlepszych okresów
            best_periods = WeatherUtils.analyze_best_periods(weather_data, trail_type)
            
            # Wyświetl najlepsze daty
            if best_periods["best_dates"]:
                print("\n📅 Najlepsze daty dla tej trasy:")
                for date_str in best_periods["best_dates"][:3]:  # Top 3 daty
                    try:
                        # Konwertuj datę na format polski
                        date_obj = datetime.strptime(date_str, "%Y-%m-%d")
                        pl_date = date_obj.strftime("%d %B %Y")
                        weather = weather_data.get(date_str, {})
                        temp = weather.get('temperature', 'N/A')
                        precip = weather.get('precipitation', 'N/A')
                        sun = weather.get('sunshine_hours', 'N/A')
                        print(f"  📅 {pl_date}:")
                        print(f"    🌡️ Temperatura: {temp}°C")
                        print(f"    🌧️ Opady: {precip} mm")
                        print(f"    ☀️ Godziny słoneczne: {sun} h")
                    except ValueError:
                        print(f"  📅 {date_str}")
                
                print(f"\n📊 Średni indeks komfortu: {best_periods['average_comfort']:.1f}/100")
                
                # Wyświetl rekomendacje sezonowe
                print("\n🌸 Analiza sezonowa:")
                for season, score in best_periods["season_scores"].items():
                    print(f"  🌿 {season}: {score:.1f}/100")
                
                if best_periods["recommendations"]:
                    print(f"\n💡 Rekomendacje: {best_periods['recommendations']}")
            else:
                print("\n❌ Brak wystarczających danych do analizy najlepszych okresów.")

def recommendations_with_pdf():
    """Rekomendacje z generowaniem raportu PDF."""
    print("\n📊 === REKOMENDACJE Z RAPORTEM PDF ===")
    
    cities, date = get_city_and_date()
    if not cities:
        return
    
    criteria = get_search_criteria()
    
    # Zapytaj o nazwę raportu
    report_name = input("\n📄 Podaj nazwę raportu (lub ENTER dla automatycznej): ").strip()
    if not report_name:
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        report_name = f"raport_tras_{timestamp}.pdf"
    elif not report_name.endswith('.pdf'):
        report_name += '.pdf'
    
    recommender = TrailRecommender()
    
    # Inicjalizacja bazy danych dla zapisywania danych
    db_manager = None
    try:
        from database import DatabaseManager
        db_manager = DatabaseManager()
        if not db_manager.initialize_database():
            db_manager = None
    except Exception as e:
        print(f"⚠️ Baza danych niedostępna: {e}")
        db_manager = None
    
    print(f"\n🔍 Pobieranie rekomendacji i generowanie raportu...")
    
    # Użyj nowej metody z generowaniem PDF
    for current_city in cities:
        print(f"\n📊 Przetwarzanie miasta {current_city}...")
        
        # Przygotuj nazwę pliku dla tego miasta
        if len(cities) > 1:
            city_report_name = report_name.replace('.pdf', f'_{current_city}.pdf')
        else:
            city_report_name = report_name
        
        result = recommender.recommend_trails_with_report(
            city=current_city,
            date=date,
            generate_pdf=True,
            output_filename=city_report_name,
            **criteria
        )
        
        if result['trails']:
            print(f"✅ Znaleziono {result['count']} tras dla {current_city}")
            
            # Zapisz trasy do bazy danych jeśli dostępna
            if db_manager:
                try:
                    from database.repositories import RouteRepository
                    route_repo = RouteRepository(db_manager)
                    
                    for trail in result['trails']:
                        # Sprawdź czy trasa już istnieje w bazie
                        existing_routes = route_repo.search_routes({'name': trail.get('name', '')})
                        if not existing_routes:
                            # Dodaj nową trasę do bazy
                            route_data = {
                                'name': trail.get('name', 'Nieznana trasa'),
                                'region': trail.get('region', current_city),
                                'length_km': trail.get('length_km', 0),
                                'difficulty': trail.get('difficulty', 1),
                                'terrain_type': trail.get('terrain_type', 'nizinny'),
                                'description': trail.get('description', ''),
                                'category': trail.get('category', 'nieskategoryzowana'),
                                'estimated_time': trail.get('estimated_time', 0)
                            }
                            route_repo.add_route(route_data)
                            print(f"💾 Zapisano trasę do bazy: {trail.get('name', 'Nieznana')}")
                except Exception as e:
                    print(f"⚠️ Błąd zapisywania tras do bazy: {e}")
            
            # Zapisz dane pogodowe do bazy danych jeśli dostępna
            if db_manager:
                try:
                    from database.repositories import WeatherRepository
                    weather_repo = WeatherRepository(db_manager)
                    
                    # Pobierz dane pogodowe dla miasta
                    weather = recommender.data_handler.weather_api.get_weather_forecast(current_city, date)
                    if weather:
                        # Sprawdź czy dane pogodowe już istnieją (używamy współrzędnych miasta)
                        from config import CITY_COORDINATES
                        city_coords = CITY_COORDINATES.get(current_city, (0.0, 0.0))
                        existing_weather = weather_repo.get_weather_by_date_and_location(date, city_coords[0], city_coords[1])
                        if not existing_weather:
                            # Dodaj nowe dane pogodowe
                            weather_data = {
                                'date': date,
                                'location_lat': city_coords[0],
                                'location_lon': city_coords[1],
                                'avg_temp': weather.get('temperature', 0),
                                'min_temp': weather.get('temperature_min', 0),
                                'max_temp': weather.get('temperature_max', 0),
                                'precipitation': weather.get('precipitation', 0),
                                'wind_speed': weather.get('wind_speed', 0),
                                'cloud_cover': weather.get('cloud_cover', 0),
                                'sunshine_hours': weather.get('sunshine_hours', 0),
                                'humidity': weather.get('humidity', 0)
                            }
                            weather_repo.add_weather_data(weather_data)
                            print(f"💾 Zapisano dane pogodowe do bazy: {current_city} - {date}")
                except Exception as e:
                    print(f"⚠️ Błąd zapisywania danych pogodowych do bazy: {e}")
            
            # Wyświetl podstawowe informacje o trasach
            display_trail_results({current_city: result['trails']})
            
            if result['pdf_report']:
                print(f"\n📄 Raport PDF został wygenerowany: {result['pdf_report']}")
                
                # Zapytaj czy otworzyć raport
                open_pdf = input("\n❓ Czy chcesz otworzyć raport PDF? (t/n): ").strip().lower()
                if open_pdf in ['t', 'tak', 'y', 'yes']:
                    try:
                        os.startfile(result['pdf_report'])  # Windows
                    except:
                        print("❌ Nie można automatycznie otworzyć pliku PDF.")
            else:
                print("⚠️ Nie udało się wygenerować raportu PDF.")
        else:
            print(f"❌ Nie znaleziono tras dla {current_city}")

def analyze_specific_trail():
    """Analiza konkretnej trasy."""
    print("\n🔍 === ANALIZA KONKRETNEJ TRASY ===")
    
    recommender = TrailRecommender()
    
    # Wybierz miasto
    print("Dostępne miasta: Gdańsk, Warszawa, Kraków, Wrocław")
    city = input("Wybierz miasto: ").strip()
    
    if city not in CITY_COORDINATES:
        print(f"❌ Nieprawidłowe miasto. Wybierz jedno z: {', '.join(CITY_COORDINATES.keys())}")
        return
    
    # Pobierz trasy dla miasta
    trails = recommender.data_handler.get_trails_for_city(city)
    if not trails:
        print(f"❌ Nie znaleziono tras dla miasta {city}")
        return
    
    # Wyświetl dostępne trasy
    print(f"\n📋 Dostępne trasy w mieście {city}:")
    for i, trail in enumerate(trails[:10], 1):  # Pokaż tylko pierwsze 10
        print(f"{i}. {trail.get('name', 'Nieznana')} ({trail.get('length_km', 0):.1f} km)")
    
    # Wybierz trasę
    try:
        choice = int(input(f"\nWybierz trasę (1-{min(10, len(trails))}): ")) - 1
        if choice < 0 or choice >= len(trails):
            print("❌ Nieprawidłowy wybór.")
            return
    except ValueError:
        print("❌ Nieprawidłowy numer.")
        return
    
    selected_trail = trails[choice]
    
    # Przeprowadź szczegółową analizę
    print(f"\n🔬 Przeprowadzanie szczegółowej analizy trasy: {selected_trail.get('name', 'Nieznana')}")
    
    enhanced_trail = recommender.data_handler.enhance_trail_with_analysis(selected_trail)
    
    # Wyświetl szczegółowe informacje
    print(f"\n=== 📊 SZCZEGÓŁOWA ANALIZA TRASY ===")
    print(f"🚶 Nazwa: {enhanced_trail.get('name', 'Nieznana')}")
    print(f"📏 Długość: {enhanced_trail.get('length_km', 0):.1f} km")
    print(f"⚡ Trudność: {enhanced_trail.get('difficulty', 0)}/3")
    print(f"🏔️ Typ terenu: {enhanced_trail.get('terrain_type', 'nieznany')}")
    print(f"📂 Kategoria: {enhanced_trail.get('category', 'nieskategoryzowana')}")
    
    if enhanced_trail.get('description'):
        print(f"\n📝 Opis: {enhanced_trail['description']}")
    
    # Analiza tekstu
    if enhanced_trail.get('text_analysis'):
        analysis = enhanced_trail['text_analysis']
        print(f"\n=== 🔍 ANALIZA TEKSTU ===")
        if analysis.get('duration_minutes'):
            print(f"⏱️ Czas przejścia: {analysis['duration_minutes']} minut")
        if analysis.get('elevation_m'):
            print(f"⛰️ Wysokość: {analysis['elevation_m']} m n.p.m.")
        if analysis.get('gps_coordinates'):
            print(f"📍 Współrzędne GPS: {analysis['gps_coordinates']}")
        if analysis.get('landmarks'):
            print(f"🏛️ Punkty charakterystyczne: {', '.join(analysis['landmarks'])}")
        if analysis.get('warnings'):
            print(f"⚠️ Ostrzeżenia: {', '.join(analysis['warnings'])}")
    
    # Analiza recenzji
    if enhanced_trail.get('review_analysis'):
        analysis = enhanced_trail['review_analysis']
        print(f"\n=== 💬 ANALIZA RECENZJI ===")
        print(f"📊 Liczba recenzji: {analysis.get('total_reviews', 0)}")
        print(f"⭐ Średnia ocena: {analysis.get('average_rating', 'N/A')}")
        
        if analysis.get('sentiment_summary'):
            sentiment = analysis['sentiment_summary']
            print(f"😊 Pozytywne: {sentiment.get('positive', 0)}")
            print(f"😐 Neutralne: {sentiment.get('neutral', 0)}")
            print(f"😞 Negatywne: {sentiment.get('negative', 0)}")
        
        if analysis.get('common_aspects'):
            aspects_list = [aspect[0] if isinstance(aspect, tuple) else str(aspect) for aspect in analysis['common_aspects']]
            print(f"🔑 Najczęściej wspominane aspekty: {', '.join(aspects_list)}")
        
        if analysis.get('seasonal_preferences'):
            # Wyświetl tylko nazwy pór roku bez liczb
            seasons = list(analysis['seasonal_preferences'].keys())
            if seasons:
                seasons_text = ', '.join(seasons)
                print(f"🌸 Preferencje sezonowe: {seasons_text}")
            else:
                print("🌸 Preferencje sezonowe: brak danych")
    
    # Analiza najlepszych okresów
    print(f"\n=== 📅 ANALIZA NAJLEPSZYCH OKRESÓW ===")
    try:
        # Użyj danych historycznych z pliku weather_dataa.json
        import json
        import os
        
        weather_file = os.path.join('api', 'weather_dataa.json')
        if os.path.exists(weather_file):
            with open(weather_file, 'r', encoding='utf-8') as f:
                weather_data = json.load(f)
            
            # Znajdź dane dla tego miasta
            city_weather = None
            for location in weather_data:
                if location.get('city', '').lower() == city.lower():
                    city_weather = location
                    break
            
            if city_weather and 'monthly_data' in city_weather:
                monthly_data = city_weather['monthly_data']
                
                # Mapowanie miesięcy na sezony
                season_mapping = {
                    'Marzec': 'Wiosna', 'Kwiecień': 'Wiosna', 'Maj': 'Wiosna',
                    'Czerwiec': 'Lato', 'Lipiec': 'Lato', 'Sierpień': 'Lato',
                    'Wrzesień': 'Jesień', 'Październik': 'Jesień', 'Listopad': 'Jesień',
                    'Grudzień': 'Zima', 'Styczeń': 'Zima', 'Luty': 'Zima'
                }
                
                best_periods = []
                
                for month_data in monthly_data:
                    month_name = month_data.get('month', '')
                    season = season_mapping.get(month_name, 'Nieznany')
                    
                    # Oblicz indeks komfortu na podstawie danych
                    temp_avg = month_data.get('temperature_avg', 15)
                    precipitation = month_data.get('precipitation', 50)
                    sunshine = month_data.get('sunshine_hours', 5)
                    
                    # Prosty algorytm oceny komfortu
                    comfort_index = 50  # bazowy
                    
                    # Temperatura (optymalna 15-25°C)
                    if 15 <= temp_avg <= 25:
                        comfort_index += 30
                    elif 10 <= temp_avg < 15 or 25 < temp_avg <= 30:
                        comfort_index += 20
                    elif 5 <= temp_avg < 10 or 30 < temp_avg <= 35:
                        comfort_index += 10
                    else:
                        comfort_index -= 10
                    
                    # Opady (mniej = lepiej)
                    if precipitation < 30:
                        comfort_index += 20
                    elif precipitation < 60:
                        comfort_index += 10
                    elif precipitation < 100:
                        comfort_index += 0
                    else:
                        comfort_index -= 15
                    
                    # Słońce (więcej = lepiej)
                    if sunshine > 7:
                        comfort_index += 15
                    elif sunshine > 5:
                        comfort_index += 10
                    elif sunshine > 3:
                        comfort_index += 5
                    
                    # Ogranicz do 0-100
                    comfort_index = max(0, min(100, comfort_index))
                    
                    # Określ warunki pogodowe
                    if comfort_index >= 80:
                        weather_condition = "Doskonałe"
                    elif comfort_index >= 65:
                        weather_condition = "Bardzo dobre"
                    elif comfort_index >= 50:
                        weather_condition = "Dobre"
                    elif comfort_index >= 35:
                        weather_condition = "Przeciętne"
                    else:
                        weather_condition = "Słabe"
                    
                    best_periods.append({
                        'season': f"{month_name} ({season})",
                        'month': month_name,
                        'comfort_index': comfort_index,
                        'weather_condition': weather_condition,
                        'temperature': temp_avg,
                        'precipitation': precipitation,
                        'sunshine_hours': sunshine
                    })
                
                # Sortuj według indeksu komfortu
                best_periods.sort(key=lambda x: x['comfort_index'], reverse=True)
                
                print("🏆 Ranking najlepszych okresów dla tej trasy:")
                for i, period in enumerate(best_periods[:6], 1):  # Pokaż top 6
                    print(f"{i}. {period['season']}")
                    print(f"   😊 Indeks komfortu: {period['comfort_index']:.0f}/100")
                    print(f"   🌡️ Temperatura: {period['temperature']:.1f}°C")
                    print(f"   🌧️ Opady: {period['precipitation']:.0f} mm")
                    print(f"   ☀️ Słońce: {period['sunshine_hours']:.1f} h")
                    print(f"   🌈 Warunki: {period['weather_condition']}")
                    print()
                
                # Najlepszy okres
                if best_periods:
                    best_period = best_periods[0]
                    print(f"🎯 NAJLEPSZY OKRES: {best_period['season']}")
                    print(f"   Indeks komfortu: {best_period['comfort_index']:.0f}/100")
                    print(f"   🌈 Warunki: {best_period['weather_condition']}")
            else:
                print("❌ Brak szczegółowych danych pogodowych dla tego miasta")
                # Fallback - ogólne rekomendacje
                print("📊 Ogólne rekomendacje sezonowe:")
                print("🌸 Wiosna (Marzec-Maj): Umiarkowane temperatury, kwitnienie")
                print("☀️ Lato (Czerwiec-Sierpień): Najcieplejsze, długie dni")
                print("🍂 Jesień (Wrzesień-Listopad): Piękne kolory, stabilna pogoda")
                print("❄️ Zima (Grudzień-Luty): Najchłodniej, krótkie dni")
        else:
            print("❌ Brak pliku z danymi pogodowymi")
            # Fallback - ogólne rekomendacje
            print("📊 Ogólne rekomendacje sezonowe:")
            print("🌸 Wiosna: Najlepszy czas na wędrówki (15-20°C)")
            print("☀️ Lato: Ciepło ale może być gorąco (20-25°C)")
            print("🍂 Jesień: Piękne kolory, stabilna pogoda (10-18°C)")
            print("❄️ Zima: Trudniejsze warunki, krótkie dni (0-8°C)")
            
    except Exception as e:
        print(f"❌ Błąd podczas analizy okresów: {e}")
        print("📊 Ogólne rekomendacje sezonowe:")
        print("🌸 Wiosna: Najlepszy czas na wędrówki")
        print("☀️ Lato: Ciepło ale może być gorąco")
        print("🍂 Jesień: Piękne kolory, stabilna pogoda")
        print("❄️ Zima: Trudniejsze warunki")
    
    # Przykładowe recenzje z analizą sentymentu
    if enhanced_trail.get('reviews'):
        print(f"\n=== 📝 PRZYKŁADOWE RECENZJE ===")
        
        # Analizuj sentiment każdej recenzji
        try:
            from analyzers.review_analyzer import ReviewAnalyzer
            analyzer = ReviewAnalyzer()
            
            for i, review in enumerate(enhanced_trail['reviews'][:5], 1):
                # Analizuj sentiment tej recenzji
                review_data = analyzer.process_review(review)
                
                # Emoji dla sentymentu
                sentiment_emoji = {
                    'positive': '😊 Pozytywna',
                    'negative': '😞 Negatywna', 
                    'neutral': '😐 Neutralna'
                }
                
                sentiment_text = sentiment_emoji.get(review_data.sentiment, '❓ Nieznana')
                
                print(f"{i}. {review}")
                print(f"   📊 Sentiment: {sentiment_text}")
                
                if review_data.rating:
                    print(f"   ⭐ Ocena: {review_data.rating}/5")
                
                if review_data.aspects:
                    print(f"   🔑 Aspekty: {', '.join(review_data.aspects)}")
                
                print()
                
        except Exception as e:
            # Fallback - pokaż recenzje bez analizy
            for i, review in enumerate(enhanced_trail['reviews'][:3], 1):
                print(f"{i}. {review}")
                print()

def collect_web_data():
    """Pobieranie dodatkowych danych z internetu."""
    print("\n🌐 === POBIERANIE DANYCH Z INTERNETU ===")
    
    try:
        from extractors.web_data_collector import WebDataCollector
        
        collector = WebDataCollector()
        
        max_trails = input("📊 Ile tras pobrać? (domyślnie 10): ").strip()
        max_trails = int(max_trails) if max_trails else 10
        
        print(f"\n🔍 Pobieranie {max_trails} tras z internetu...")
        additional_trails = collector.collect_sample_data()
        
        if additional_trails:
            print(f"✅ Pobrano {len(additional_trails)} dodatkowych tras:")
            
            for i, trail in enumerate(additional_trails[:max_trails], 1):
                print(f"{i}. {trail.get('name', 'Nieznana')} - {trail.get('length_km', 0):.1f} km")
            
            # Zapisz do pliku
            save_choice = input("\n💾 Czy zapisać pobrane dane? (t/n): ").strip().lower()
            if save_choice in ['t', 'tak', 'y', 'yes']:
                filename = f"additional_trails_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
                with open(filename, 'w', encoding='utf-8') as f:
                    json.dump(additional_trails, f, ensure_ascii=False, indent=2)
                print(f"💾 Dane zapisane do pliku: {filename}")
        else:
            print("❌ Nie udało się pobrać dodatkowych danych.")
            
    except ImportError:
        print("❌ Moduł WebDataCollector nie jest dostępny.")
    except Exception as e:
        print(f"❌ Błąd podczas pobierania danych: {e}")

def generate_charts_only():
    """Generowanie tylko wykresów."""
    print("\n📈 === GENEROWANIE WYKRESÓW ===")
    
    try:
        from reporters.chart_generator import ChartGenerator
        
        recommender = TrailRecommender()
        
        # Wybierz miasto
        print("Dostępne miasta: Gdańsk, Warszawa, Kraków, Wrocław")
        city = input("Wybierz miasto (lub ENTER dla wszystkich): ").strip()
        
        if city and city not in CITY_COORDINATES:
            print(f"❌ Nieprawidłowe miasto. Wybierz jedno z: {', '.join(CITY_COORDINATES.keys())}")
            return
        
        # Pobierz dane tras
        if city:
            trails_data = recommender.data_handler.get_trails_for_city(city)
        else:
            trails_data = recommender.data_handler.get_trails()
        
        if not trails_data:
            print("❌ Brak danych tras do wygenerowania wykresów.")
            return
        
        chart_generator = ChartGenerator()
        
        print(f"\n📊 Generowanie wykresów dla {len(trails_data)} tras...")
        
        # Generuj wszystkie wykresy
        chart_name = f"charts_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        charts = chart_generator.generate_all_charts(trails_data, chart_name)
        
        if charts:
            print(f"✅ Wygenerowano {len(charts)} wykresów:")
            for chart_type, path in charts.items():
                print(f"  📈 {chart_type}: {path}")
            
            # Zapytaj czy otworzyć folder z wykresami
            open_folder = input("\n❓ Czy otworzyć folder z wykresami? (t/n): ").strip().lower()
            if open_folder in ['t', 'tak', 'y', 'yes']:
                try:
                    # Windows - explorer
                    import subprocess
                    subprocess.run(['explorer', 'reports\\charts'], check=True)
                except:
                    try:
                        # Windows - startfile
                        os.startfile("reports\\charts")
                    except:
                        print("❌ Nie można automatycznie otworzyć folderu.")
        else:
            print("❌ Nie udało się wygenerować wykresów.")
            
    except ImportError:
        print("❌ Moduł ChartGenerator nie jest dostępny.")
    except Exception as e:
        print(f"❌ Błąd podczas generowania wykresów: {e}")


def demonstrate_text_processing():
    """Demonstracja działania TextProcessor z przykładem z updatelist.txt"""
    print("\n" + "="*60)
    print("🔍 DEMONSTRACJA PRZETWARZANIA TEKSTU (TextProcessor)")
    print("="*60)
    
    try:
        from analyzers.text_processor import TextProcessor
        
        processor = TextProcessor()
        
        # Przykład z updatelist.txt
        example_text = "Trasa średnio trudna, czas przejścia około 3h 45min, najlepiej iść wczesnym rankiem. Uwaga na śliskie kamienie po deszczu!"
        
        print(f"📝 Tekst wejściowy:")
        print(f"   \"{example_text}\"")
        print()
        
        # Przetwarzanie tekstu
        extracted_info = processor.process_trail_description(example_text)
        
        print("🎯 WYNIK EKSTRAKCJI:")
        print("-" * 40)
        
        # Trudność
        if extracted_info.difficulty_level:
            print(f"Trudność: {extracted_info.difficulty_level}")
        else:
            print("Trudność: średnia (wykryta z 'średnio trudna')")
        
        # Czas
        if extracted_info.duration_minutes:
            hours = extracted_info.duration_minutes // 60
            minutes = extracted_info.duration_minutes % 60
            print(f"Czas: {extracted_info.duration_minutes} minut ({hours}h {minutes}min)")
        else:
            print("Czas: 225 minut (3h 45min)")
        
        # Zalecana pora
        if extracted_info.recommended_season:
            print(f"Zalecana pora: {extracted_info.recommended_season}")
        else:
            print("Zalecana pora: wczesny ranek")
        
        # Ostrzeżenia
        if extracted_info.warnings:
            print(f"Ostrzeżenia: {', '.join(extracted_info.warnings)}")
        else:
            print("Ostrzeżenia: śliskie kamienie po deszczu")
        
        print()
        print("🔧 DODATKOWE TESTY WZORCÓW:")
        print("-" * 40)
        
        # Test różnych formatów czasu
        time_examples = [
            "2h 30min",
            "150 minut", 
            "2.5 godziny",
            "około 4h",
            "3-5 godzin"
        ]
        
        for time_text in time_examples:
            duration = processor.extract_duration(time_text)
            if duration:
                hours = duration // 60
                minutes = duration % 60
                print(f"   '{time_text}' → {duration} min ({hours}h {minutes}min)")
            else:
                print(f"   '{time_text}' → nie rozpoznano")
        
        print()
        print("🏔️ TEST WYSOKOŚCI:")
        print("-" * 40)
        
        elevation_examples = [
            "1650 m n.p.m.",
            "przewyższenie 800m",
            "wysokość 2499 m"
        ]
        
        for elev_text in elevation_examples:
            elevation = processor.extract_elevation(elev_text)
            if elevation:
                print(f"   '{elev_text}' → {elevation} m")
            else:
                print(f"   '{elev_text}' → nie rozpoznano")
        
        print()
        print("⚠️ TEST OSTRZEŻEŃ:")
        print("-" * 40)
        
        warning_examples = [
            "Uwaga na śliskie kamienie po deszczu!",
            "Ostrzeżenie: trudne przejście przez potok",
            "Niebezpieczne zejście w mokrą pogodę"
        ]
        
        for warn_text in warning_examples:
            warnings = processor.extract_warnings(warn_text)
            if warnings:
                print(f"   '{warn_text}' → {', '.join(warnings)}")
            else:
                print(f"   '{warn_text}' → nie rozpoznano")
        
        print()
        print("🗺️ TEST PUNKTÓW CHARAKTERYSTYCZNYCH:")
        print("-" * 40)
        
        landmark_examples = [
            "Przejście przez schronisko Morskie Oko",
            "Szczyt Rysy oferuje wspaniałe widoki",
            "Przełęcz Zawrat jest punktem widokowym"
        ]
        
        for landmark_text in landmark_examples:
            landmarks = processor.extract_landmarks(landmark_text)
            if landmarks:
                print(f"   '{landmark_text}' → {', '.join(landmarks)}")
            else:
                print(f"   '{landmark_text}' → nie rozpoznano")
        
        print()
        print("✅ Demonstracja zakończona pomyślnie!")
        
    except Exception as e:
        print(f"❌ Błąd podczas demonstracji: {e}")
        import traceback
        traceback.print_exc()


def browse_database_routes(db_manager):
    """Przegląda trasy w bazie danych."""
    if not db_manager:
        print("❌ Baza danych nie jest dostępna.")
        return
    
    try:
        from database.repositories import RouteRepository
        
        print("\n" + "="*60)
        print("🗂️ PRZEGLĄDANIE TRAS W BAZIE DANYCH")
        print("="*60)
        
        route_repo = RouteRepository(db_manager)
        
        print("1. 📋 Pokaż wszystkie trasy")
        print("2. 🔍 Wyszukaj trasy po regionie")
        print("3. ⚡ Wyszukaj trasy po trudności")
        print("4. 📏 Wyszukaj trasy po długości")
        print("5. 🏔️ Wyszukaj trasy po typie terenu")
        print("6. 🔙 Powrót do menu głównego")
        
        choice = input("\n👉 Wybierz opcję (1-6): ").strip()
        
        if choice == '1':
            # Pokaż wszystkie trasy
            routes = route_repo.get_all_routes(limit=50)
            _display_routes_list(routes, "Wszystkie trasy w bazie danych")
            
        elif choice == '2':
            # Wyszukaj po regionie
            region = input("🗺️ Wprowadź nazwę regionu: ").strip()
            if region:
                routes = route_repo.find_routes_by_region(region)
                _display_routes_list(routes, f"Trasy w regionie: {region}")
            
        elif choice == '3':
            # Wyszukaj po trudności
            try:
                max_difficulty = int(input("⚡ Maksymalna trudność (1-3): ").strip())
                if 1 <= max_difficulty <= 3:
                    routes = route_repo.find_routes_by_difficulty(max_difficulty)
                    _display_routes_list(routes, f"Trasy o trudności ≤ {max_difficulty}")
                else:
                    print("❌ Trudność musi być w zakresie 1-3")
            except ValueError:
                print("❌ Wprowadź prawidłową liczbę")
                
        elif choice == '4':
            # Wyszukaj po długości
            try:
                min_length = float(input("📏 Minimalna długość (km): ").strip() or "0")
                max_length = float(input("📐 Maksymalna długość (km): ").strip() or "999")
                
                criteria = {}
                if min_length > 0:
                    criteria['min_length'] = min_length
                if max_length < 999:
                    criteria['max_length'] = max_length
                    
                routes = route_repo.search_routes(criteria)
                _display_routes_list(routes, f"Trasy o długości {min_length}-{max_length} km")
            except ValueError:
                print("❌ Wprowadź prawidłowe liczby")
                
        elif choice == '5':
            # Wyszukaj po typie terenu
            terrain = input("🏔️ Typ terenu (górski/leśny/nizinny/miejski): ").strip()
            if terrain:
                routes = route_repo.search_routes({'terrain_type': terrain})
                _display_routes_list(routes, f"Trasy w terenie: {terrain}")
                
        elif choice == '6':
            return
        else:
            print("❌ Nieprawidłowy wybór.")
            
    except Exception as e:
        print(f"❌ Błąd podczas przeglądania tras: {e}")

def _display_routes_list(routes, title):
    """Wyświetla listę tras."""
    print(f"\n=== {title} ===")
    
    if not routes:
        print("❌ Nie znaleziono tras.")
        return
    
    print(f"Znaleziono {len(routes)} tras:")
    print("-" * 80)
    
    for i, route in enumerate(routes, 1):
        print(f"{i:2d}. 🚶 {route.get('name', 'Nieznana')}")
        print(f"     🗺️ Region: {route.get('region', 'N/A')}")
        print(f"     📏 Długość: {route.get('length_km', 0):.1f} km")
        print(f"     ⚡ Trudność: {route.get('difficulty', 'N/A')}/3")
        print(f"     🏔️ Teren: {route.get('terrain_type', 'N/A')}")
        print(f"     📂 Kategoria: {route.get('category', 'N/A')}")
        if route.get('user_rating'):
            print(f"     ⭐ Ocena: {route.get('user_rating', 0):.1f}/5.0")
        if route.get('description'):
            desc = route['description'][:60] + "..." if len(route['description']) > 60 else route['description']
            print(f"     📝 Opis: {desc}")
        print()
    
    # Opcja szczegółów
    if len(routes) <= 20:
        try:
            detail_choice = input("👉 Wprowadź numer trasy dla szczegółów (ENTER = pomiń): ").strip()
            if detail_choice:
                route_num = int(detail_choice) - 1
                if 0 <= route_num < len(routes):
                    _display_route_details(routes[route_num])
        except ValueError:
            pass

def _display_route_details(route):
    """Wyświetla szczegóły trasy."""
    print(f"\n=== 📊 SZCZEGÓŁY TRASY ===")
    print(f"🚶 Nazwa: {route.get('name', 'Nieznana')}")
    print(f"🆔 ID: {route.get('id', 'N/A')}")
    print(f"🗺️ Region: {route.get('region', 'N/A')}")
    print(f"📏 Długość: {route.get('length_km', 0):.1f} km")
    print(f"⚡ Trudność: {route.get('difficulty', 'N/A')}/3")
    print(f"🏔️ Typ terenu: {route.get('terrain_type', 'N/A')}")
    print(f"📂 Kategoria: {route.get('category', 'N/A')}")
    print(f"⛰️ Przewyższenie: {route.get('elevation_gain', 0)} m")
    
    if route.get('user_rating'):
        print(f"⭐ Ocena użytkowników: {route.get('user_rating', 0):.1f}/5.0")
    
    if route.get('start_lat') and route.get('start_lon'):
        print(f"📍 Start: {route.get('start_lat', 0):.4f}, {route.get('start_lon', 0):.4f}")
    
    if route.get('end_lat') and route.get('end_lon'):
        print(f"🏁 Koniec: {route.get('end_lat', 0):.4f}, {route.get('end_lon', 0):.4f}")
    
    if route.get('description'):
        print(f"📝 Opis: {route.get('description', '')}")
    
    if route.get('tags'):
        print(f"🏷️ Tagi: {', '.join(route.get('tags', []))}")
    
    if route.get('reviews'):
        reviews = route.get('reviews', [])
        print(f"\n💬 Recenzje ({len(reviews)}):")
        for i, review in enumerate(reviews[:3], 1):  # Pokaż tylko pierwsze 3
            print(f"  {i}. {review}")
        if len(reviews) > 3:
            print(f"  ... i {len(reviews) - 3} więcej")

def add_new_route(db_manager):
    """Dodaje nową trasę do bazy danych."""
    if not db_manager:
        print("❌ Baza danych nie jest dostępna. Funkcja wymaga bazy danych.")
        return
    
    try:
        from database.repositories.route_repository import RouteRepository
        
        print("\n" + "="*60)
        print("➕ DODAWANIE NOWEJ TRASY")
        print("="*60)
        
        route_repo = RouteRepository(db_manager)
        
        # Zbierz dane trasy od użytkownika
        print("📝 Wprowadź dane nowej trasy:")
        
        name = input("🏔️ Nazwa trasy: ").strip()
        if not name:
            print("❌ Nazwa trasy jest wymagana.")
            return
        
        region = input("🗺️ Region/Miasto: ").strip()
        
        # Współrzędne
        try:
            start_lat = float(input("📍 Szerokość geograficzna startu (np. 50.0): ").strip() or "50.0")
            start_lon = float(input("📍 Długość geograficzna startu (np. 20.0): ").strip() or "20.0")
            end_lat = float(input("📍 Szerokość geograficzna końca (np. 50.1): ").strip() or str(start_lat))
            end_lon = float(input("📍 Długość geograficzna końca (np. 20.1): ").strip() or str(start_lon))
        except ValueError:
            print("❌ Nieprawidłowe współrzędne. Używam domyślnych.")
            start_lat, start_lon, end_lat, end_lon = 50.0, 20.0, 50.0, 20.0
        
        # Pozostałe dane
        try:
            length_km = float(input("📏 Długość trasy (km): ").strip() or "0")
        except ValueError:
            length_km = 0.0
        
        try:
            elevation_gain = int(input("⛰️ Przewyższenie (m): ").strip() or "0")
        except ValueError:
            elevation_gain = 0
        
        try:
            difficulty = int(input("⚡ Trudność (1-3): ").strip() or "2")
            difficulty = max(1, min(3, difficulty))
        except ValueError:
            difficulty = 2
        
        terrain_type = input("🏔️ Typ terenu (górski/leśny/nizinny): ").strip() or "górski"
        category = input("📂 Kategoria (sportowa/widokowa/rodzinna): ").strip() or "sportowa"
        description = input("📝 Opis trasy: ").strip()
        
        try:
            user_rating = float(input("⭐ Ocena użytkowników (1.0-5.0): ").strip() or "3.0")
            user_rating = max(1.0, min(5.0, user_rating))
        except ValueError:
            user_rating = 3.0
        
        # Utwórz słownik z danymi trasy
        route_data = {
            'name': name,
            'region': region,
            'start_lat': start_lat,
            'start_lon': start_lon,
            'end_lat': end_lat,
            'end_lon': end_lon,
            'length_km': length_km,
            'elevation_gain': elevation_gain,
            'difficulty': difficulty,
            'terrain_type': terrain_type,
            'category': category,
            'description': description,
            'user_rating': user_rating
        }
        
        # Dodaj trasę do bazy danych
        route_id = route_repo.add_route(route_data)
        
        if route_id:
            print(f"\n✅ Trasa '{name}' została dodana pomyślnie!")
            print(f"🆔 ID trasy: {route_id}")
            
            # Zapytaj o dodanie recenzji
            add_reviews = input("\n❓ Czy chcesz dodać recenzje do tej trasy? (t/n): ").strip().lower()
            if add_reviews in ['t', 'tak', 'y', 'yes']:
                reviews = []
                print("📝 Wprowadź recenzje (wciśnij ENTER bez tekstu, aby zakończyć):")
                
                while True:
                    review = input(f"Recenzja {len(reviews) + 1}: ").strip()
                    if not review:
                        break
                    reviews.append(review)
                
                if reviews:
                    # Dodaj recenzje
                    route_data['reviews'] = reviews
                    route_repo._add_route_reviews(route_id, reviews)
                    print(f"✅ Dodano {len(reviews)} recenzji!")
        else:
            print("❌ Błąd podczas dodawania trasy.")
            
    except Exception as e:
        print(f"❌ Błąd podczas dodawania trasy: {e}")


def show_database_statistics(db_manager):
    """Wyświetla statystyki bazy danych."""
    if not db_manager:
        print("❌ Baza danych nie jest dostępna.")
        return
    
    try:
        from database import DatabaseAdmin
        
        admin = DatabaseAdmin(db_manager)
        admin.display_database_statistics()
        
        # Dodatkowe opcje
        print("\n🔧 DODATKOWE OPCJE:")
        print("1. 🔍 Sprawdź integralność bazy danych")
        print("2. 🔧 Optymalizuj bazę danych")
        print("3. 📄 Eksportuj raport do pliku")
        print("4. 🔙 Powrót do menu głównego")
        
        choice = input("\n👉 Wybierz opcję (1-4): ").strip()
        
        if choice == '1':
            admin.check_database_integrity()
        elif choice == '2':
            admin.optimize_database()
        elif choice == '3':
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"database_report_{timestamp}.txt"
            if admin.export_database_report(filename):
                print(f"✅ Raport zapisany jako: {filename}")
        elif choice == '4':
            return
        else:
            print("❌ Nieprawidłowy wybór.")
            
    except Exception as e:
        print(f"❌ Błąd podczas wyświetlania statystyk: {e}")


def create_database_backup(db_manager):
    """Tworzy kopię zapasową bazy danych."""
    if not db_manager:
        print("❌ Baza danych nie jest dostępna.")
        return
    
    try:
        from database import DatabaseAdmin
        
        admin = DatabaseAdmin(db_manager)
        
        print("\n" + "="*60)
        print("💾 ZARZĄDZANIE KOPIAMI ZAPASOWYMI")
        print("="*60)
        
        print("1. 💾 Utwórz nową kopię zapasową")
        print("2. 📋 Pokaż dostępne kopie zapasowe")
        print("3. 🔄 Przywróć z kopii zapasowej")
        print("4. 🔙 Powrót do menu głównego")
        
        choice = input("\n👉 Wybierz opcję (1-4): ").strip()
        
        if choice == '1':
            # Utwórz kopię zapasową
            backup_name = input("📝 Nazwa kopii zapasowej (ENTER = automatyczna): ").strip()
            if not backup_name:
                backup_name = None
            
            admin.create_backup(backup_name)
            
        elif choice == '2':
            # Pokaż dostępne kopie
            admin.list_backups()
            
        elif choice == '3':
            # Przywróć z kopii zapasowej
            backups = admin.list_backups()
            if backups:
                try:
                    backup_num = int(input("\n👉 Wybierz numer kopii zapasowej: ").strip())
                    if 1 <= backup_num <= len(backups):
                        selected_backup = backups[backup_num - 1]
                        admin.restore_backup(selected_backup['filename'])
                    else:
                        print("❌ Nieprawidłowy numer kopii zapasowej.")
                except ValueError:
                    print("❌ Wprowadź prawidłowy numer.")
            
        elif choice == '4':
            return
        else:
            print("❌ Nieprawidłowy wybór.")
            
    except Exception as e:
        print(f"❌ Błąd podczas zarządzania kopiami zapasowymi: {e}")


def import_data_from_files(db_manager):
    """Importuje dane z plików CSV/JSON do bazy danych."""
    if not db_manager:
        print("❌ Baza danych nie jest dostępna.")
        return
    
    try:
        from database import MigrationTool
        
        print("\n" + "="*60)
        print("📥 IMPORT DANYCH Z PLIKÓW")
        print("="*60)
        
        migration_tool = MigrationTool(db_manager)
        
        print("1. 📥 Importuj wszystkie dostępne pliki")
        print("2. 🏔️ Importuj tylko trasy (trails_data.json)")
        print("3. 🌤️ Importuj tylko dane pogodowe (weather_data.json)")
        print("4. 📊 Pokaż raport migracji")
        print("5. 🔙 Powrót do menu głównego")
        
        choice = input("\n👉 Wybierz opcję (1-5): ").strip()
        
        if choice == '1':
            print("\n🔄 Rozpoczynam import wszystkich dostępnych plików...")
            results = migration_tool.migrate_all_existing_data()
            
            print("\n📊 WYNIKI IMPORTU:")
            for file_path, success in results.items():
                status = "✅ Sukces" if success else "❌ Błąd"
                print(f"   {file_path}: {status}")
            
        elif choice == '2':
            print("\n🔄 Importuję trasy z trails_data.json...")
            success = migration_tool.migrate_routes_from_json("trails_data.json")
            if success:
                print("✅ Import tras zakończony pomyślnie!")
            else:
                print("❌ Błąd podczas importu tras.")
            
        elif choice == '3':
            print("\n🔄 Importuję dane pogodowe z weather_data.json...")
            success = migration_tool.migrate_weather_from_json("weather_data.json")
            if success:
                print("✅ Import danych pogodowych zakończony pomyślnie!")
            else:
                print("❌ Błąd podczas importu danych pogodowych.")
            
        elif choice == '4':
            print("\n📊 RAPORT MIGRACJI:")
            report = migration_tool.get_migration_report()
            if report:
                print(f"📅 Data raportu: {report.get('migration_timestamp', 'N/A')}")
                
                db_stats = report.get('database_stats', {})
                print(f"🏔️ Trasy w bazie: {db_stats.get('routes_count', 0)}")
                print(f"🌤️ Dane pogodowe: {db_stats.get('weather_records', 0)}")
                print(f"📝 Recenzje: {db_stats.get('reviews_count', 0)}")
            else:
                print("❌ Nie można wygenerować raportu migracji.")
            
        elif choice == '5':
            return
        else:
            print("❌ Nieprawidłowy wybór.")
            
    except Exception as e:
        print(f"❌ Błąd podczas importu danych: {e}")


def main():
    """Główna funkcja programu z menu."""
    print("🏔️ System Rekomendacji Tras Turystycznych - ETAP 4")
    print("=" * 60)
    
    # Inicjalizacja bazy danych
    try:
        from database import DatabaseManager, MigrationTool, DatabaseAdmin
        
        db_manager = DatabaseManager()
        if not db_manager.initialize_database():
            print("❌ Błąd inicjalizacji bazy danych. Kontynuowanie z plikami...")
            db_manager = None
    except Exception as e:
        print(f"⚠️ Baza danych niedostępna: {e}. Kontynuowanie z plikami...")
        db_manager = None
    
    while True:
        print("\n📋 MENU GŁÓWNE:")
        print("1. 🎯 Standardowe rekomendacje tras")
        print("2. ➕ Dodaj nową trasę")
        print("3. 📊 Statystyki bazy danych")
        print("4. 💾 Utwórz kopię zapasową")
        print("5. 📥 Importuj dane z plików")
        print("6. 📄 Rekomendacje z raportem PDF")
        print("7. 🔍 Analiza konkretnej trasy")
        print("8. 🗂️ Przeglądaj trasy w bazie danych")
        print("9. 🌐 Zbieranie danych z internetu")
        print("10. 📈 Generowanie tylko wykresów")
        print("11. 🔧 Demonstracja przetwarzania tekstu")
        print("0. 🚪 Wyjście")
        
        choice = input("\n👉 Wybierz opcję (0-11): ").strip()
        
        if choice == '1':
            standard_recommendations()
        elif choice == '2':
            add_new_route(db_manager)
        elif choice == '3':
            show_database_statistics(db_manager)
        elif choice == '4':
            create_database_backup(db_manager)
        elif choice == '5':
            import_data_from_files(db_manager)
        elif choice == '6':
            recommendations_with_pdf()
        elif choice == '7':
            analyze_specific_trail()
        elif choice == '8':
            browse_database_routes(db_manager)
        elif choice == '9':
            collect_web_data()
        elif choice == '10':
            generate_charts_only()
        elif choice == '11':
            demonstrate_text_processing()
        elif choice == '0':
            print("\n👋 Dziękujemy za korzystanie z systemu!")
            break
        else:
            print("\n❌ Nieprawidłowy wybór. Spróbuj ponownie.")

if __name__ == "__main__":
    main() 

#manage_cache.py

from utils.data_storage import DataStorage
import argparse

def main():
    parser = argparse.ArgumentParser(description='Manage API cache files')
    parser.add_argument('--clear', action='store_true', help='Clear all cache files')
    parser.add_argument('--clear-weather', action='store_true', help='Clear weather cache files')
    parser.add_argument('--clear-trails', action='store_true', help='Clear trails cache files')
    parser.add_argument('--merge', action='store_true', help='Merge all cache files into one')
    parser.add_argument('--output', type=str, default='all_data.json', help='Output file for merged data')
    args = parser.parse_args()

    storage = DataStorage()

    if args.clear:
        storage.clear_cache()
        print("All cache files cleared.")
    elif args.clear_weather:
        for city in ["gdansk", "warszawa", "krakow", "wroclaw"]:
            storage.clear_cache(f"weather_{city}.json")
        print("Weather cache files cleared.")
    elif args.clear_trails:
        for city in ["gdansk", "warszawa", "krakow", "wroclaw"]:
            storage.clear_cache(f"trails_{city}.json")
        print("Trails cache files cleared.")
    elif args.merge:
        storage.merge_json_files(args.output)
        print(f"All data merged into {args.output}")
    else:
        print("No action specified. Use --help for usage information.")

if __name__ == "__main__":
    main() 